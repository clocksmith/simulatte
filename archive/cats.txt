
public/36/boot.js

import Utils from "./utils.js";
import StorageModule from "./storage.js";

const bootstrap = async () => {
  const loadingContainer = Utils.$id("loading-container");
  const bootLog = Utils.$id("boot-log");
  const appRoot = Utils.$id("app-root");

  const logToBootScreen = (level, message, ...details) => {
    const timestamp = new Date().toISOString();
    const line = `[${timestamp}] [${level.toUpperCase()}] ${message} ${details
      .map((d) => JSON.stringify(d))
      .join(" ")}\n`;
    if (bootLog) {
      bootLog.textContent += line;
      bootLog.scrollTop = bootLog.scrollHeight;
    }

    const consoleMethod =
      level === "error"
        ? console.error
        : level === "warn"
        ? console.warn
        : console.log;
    consoleMethod(line.trim());
  };

  let config = null;
  let storage = null;
  let logger = null;

  try {
    logToBootScreen("info", "Boot sequence started...");

    logToBootScreen("info", "Fetching configuration...");
    const configResponse = await fetch("config.json");
    if (!configResponse.ok)
      throw new Error(`Failed to fetch config.json: ${configResponse.status}`);
    config = await configResponse.json();
    logToBootScreen("info", `Configuration loaded (v${config.version})`);

    Utils.logger.init(config);
    logger = Utils.logger;
    logger.logEvent("info", "Utilities and Logger initialized.");

    storage = StorageModule(config, logger);
    if (!storage) throw new Error("Storage module initialization failed.");
    logger.logEvent("info", "Storage module initialized.");
    const usage = storage.getStorageUsage();
    logger.logEvent(
      "info",
      `Initial storage usage: ${(usage.used / 1024).toFixed(
        1
      )}KB (${usage.percent.toFixed(1)}%)`
    );

    let state = storage.getState();
    if (state) {
      if (state.version !== config.version) {
        logger.logEvent(
          "warn",
          `State version mismatch (State: ${state.version}, Config: ${config.version}). Re-initializing state.`
        );
        state = null;
        storage.removeState();
      } else {
        logger.logEvent("info", `Existing state found (v${state.version}).`);
      }
    } else {
      logger.logEvent(
        "info",
        "No existing state found. Initializing new state."
      );
    }

    logger.logEvent("info", "Loading core application modules...");

    const StateManager = (await import("./state-manager.js")).default(
      config,
      logger,
      storage
    );
    const ApiClient = (await import("./api-client.js")).default(config, logger);
    const MCPConverter = (await import("./mcp-converter.js")).default(
      config,
      logger
    );

    const ToolRunner = (await import("./tool-runner.js")).default(
      config,
      logger
    );
    const CycleLogic = (await import("./cycle-logic.js")).default(
      config,
      logger,
      Utils,
      storage,
      StateManager,
      ApiClient,
      MCPConverter,
      ToolRunner
    );
    const UIManager = (await import("./ui-manager.js")).default(
      config,
      logger,
      Utils,
      storage,
      StateManager,
      CycleLogic
    );

    logger.logEvent("info", "Core modules loaded.");

    StateManager.init(state);
    logger.logEvent("info", "StateManager initialized.");

    CycleLogic.init();
    logger.logEvent("info", "CycleLogic initialized.");

    await UIManager.init();
    logger.logEvent("info", "UIManager initialized.");

    logger.logEvent("info", "Bootstrap complete. Launching application.");
    if (loadingContainer) loadingContainer.classList.add("hidden");
    if (appRoot) appRoot.classList.remove("hidden");
  } catch (error) {
    const errorMsg = `FATAL BOOTSTRAP ERROR: ${error.message}`;
    logToBootScreen("error", errorMsg, error.stack);

    if (bootLog) {
      bootLog.style.color = "var(--error-color)";
      bootLog.style.borderColor = "var(--error-color)";
    }
    if (appRoot) appRoot.classList.add("hidden");

    if (!bootLog && loadingContainer) {
      loadingContainer.innerHTML = `<h1 style="color: var(--error-color);">Initialization Failed</h1><pre style="color: var(--error-color); text-align: left; white-space: pre-wrap;">${errorMsg}\n${
        error.stack || ""
      }</pre>`;
    }
  }
};

bootstrap();

public/36/index.html

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dreamer (Tool Factory)</title>
    <link
      rel="icon"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='15' fill='%23ccc'/%3E%3Cpath d='M30 70 L50 30 L70 70 Z' fill='%23333'/%3E%3Cpath d='M40 60 L60 60 L50 45 Z' fill='%23fff'/%3E%3C/svg%3E"
    />
    <link rel="stylesheet" href="ui-style.css" />
  </head>
  <body>
    <div id="loading-container">
      <h1>Loading DREAMER...</h1>
      <pre id="boot-log"></pre>
    </div>
    <div id="app-root" class="hidden"></div>
    <div id="notifications-container"></div>

    <script type="module" src="boot.js"></script>
  </body>
</html>

public/36/state-manager.js

const StateManagerModule = (config, logger, storage) => {
  if (!config || !logger || !storage) {
    logger?.logEvent(
      "error",
      "StateManager requires config, logger, and storage."
    );
    return null;
  }

  let state = null;
  let isInitialized = false;

  const getDefaultState = () => ({
    version: config.version,
    apiKey: "",
    tools: {},
    lastError: null,
    stats: {
      toolsGenerated: 0,
      cyclesRun: 0,
      apiCalls: 0,
      errors: 0,
    },
  });

  const validateState = (loadedState) => {
    if (!loadedState || typeof loadedState !== "object") return false;
    if (loadedState.version !== config.version) {
      logger.logEvent(
        "warn",
        `State version mismatch. Loaded: ${loadedState.version}, Expected: ${config.version}. Discarding loaded state.`
      );
      return false;
    }

    if (typeof loadedState.tools !== "object" || loadedState.tools === null)
      return false;
    if (typeof loadedState.stats !== "object" || loadedState.stats === null)
      return false;

    return true;
  };

  const init = (initialStateFromStorage = null) => {
    if (isInitialized) {
      logger.logEvent("warn", "StateManager init called multiple times.");
      return;
    }
    logger.logEvent("info", "Initializing StateManager...");

    if (initialStateFromStorage && validateState(initialStateFromStorage)) {
      state = initialStateFromStorage;
      isInitialized = true;
      logger.logEvent(
        "info",
        `StateManager initialized with existing state v${state.version}`
      );
    } else {
      if (initialStateFromStorage) {
        logger.logEvent(
          "warn",
          "Invalid initial state provided or validation failed. Initializing with default."
        );
      }
      state = getDefaultState();
      isInitialized = true;
      logger.logEvent(
        "info",
        `StateManager initialized with default state v${state.version}`
      );
      saveState();
    }
  };

  const getState = () => {
    if (!isInitialized) {
      logger.logEvent(
        "error",
        "Attempted to get state before StateManager initialized."
      );
      return null;
    }
    return state;
  };

  const updateState = (newState) => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    if (!validateState(newState)) {
      throw new Error("Attempted to set invalid state.");
    }
    state = newState;
  };

  const saveState = () => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    try {
      storage.saveState(state);
      logger.logEvent("debug", "State saved successfully.");
    } catch (e) {
      logger.logEvent("error", "Failed to save state to storage.", e);
      state.lastError = `Failed to save state: ${e.message}`;
    }
  };

  const addTool = (
    toolId,
    mcpDefinition,
    jsImplementation,
    toolMetadata = {}
  ) => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    if (!state.tools) state.tools = {};
    if (state.tools[toolId]) {
      logger.logEvent(
        "warn",
        `Overwriting existing tool definition for ID: ${toolId}`
      );
    }
    if (
      !mcpDefinition ||
      typeof mcpDefinition !== "object" ||
      !mcpDefinition.name
    ) {
      throw new Error(`Invalid MCP definition provided for tool ID: ${toolId}`);
    }
    if (typeof jsImplementation !== "string" || jsImplementation.length === 0) {
      throw new Error(
        `Invalid JS implementation provided for tool ID: ${toolId}`
      );
    }

    state.tools[toolId] = {
      id: toolId,
      mcpDefinition: mcpDefinition,
      jsImplementation: jsImplementation,
      metadata: {
        createdAt: new Date().toISOString(),
        createdBy: "LLM",
        version: toolMetadata.version || "1.0.0",
        description: mcpDefinition.description || "(No description)",
        name: mcpDefinition.name,
        ...toolMetadata,
      },
    };
    state.stats.toolsGenerated = (state.stats.toolsGenerated || 0) + 1;
    logger.logEvent(
      "info",
      `Tool added/updated: ${toolId} (${mcpDefinition.name})`
    );
    saveState();
  };

  const getTool = (toolId) => {
    if (!isInitialized) return null;
    return state.tools?.[toolId] ?? null;
  };

  const listTools = () => {
    if (!isInitialized) return [];
    return Object.values(state.tools || {});
  };

  const deleteTool = (toolId) => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    if (state.tools && state.tools[toolId]) {
      delete state.tools[toolId];
      logger.logEvent("info", `Tool deleted: ${toolId}`);
      saveState();
      return true;
    }
    logger.logEvent("warn", `Attempted to delete non-existent tool: ${toolId}`);
    return false;
  };

  const setApiKey = (key) => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    if (typeof key !== "string") return;
    state.apiKey = key;
    logger.logEvent("info", `API Key ${key ? "set" : "cleared"} in state.`);
  };

  const incrementCycle = () => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    state.stats.cyclesRun = (state.stats.cyclesRun || 0) + 1;
  };

  const incrementApiCall = () => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    state.stats.apiCalls = (state.stats.apiCalls || 0) + 1;
  };

  const incrementErrorCount = () => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    state.stats.errors = (state.stats.errors || 0) + 1;
  };

  const setLastError = (errorMessage) => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    state.lastError = errorMessage;
  };

  return {
    init,
    getState,
    updateState,
    saveState,
    addTool,
    getTool,
    listTools,
    deleteTool,
    setApiKey,
    incrementCycle,
    incrementApiCall,
    incrementErrorCount,
    setLastError,
    isInitialized: () => isInitialized,
  };
};

export default StateManagerModule;

public/36/config.json

{
  "appName": "Dreamer Tool Factory (DTF)",
  "version": "1.0.0",
  "storagePrefix": "_dtf_",
  "stateKeyBase": "dtf_state_v",
  "sessionKeyBase": "dtf_session_v",
  "maxLogEntries": 10000,
  "maxArtifactSizeBytes": 4194304,
  "defaultModel": "gemini-2.5-pro-exp-03-25",
  "geminiApiBaseUrl": "https://generativelanguage.googleapis.com/v1beta/models/",
  "apiRetryDelayBaseMs": 1500,
  "apiMaxRetries": 2,
  "toolRunnerTimeoutMs": 15000,
  "defaultPromptArtifactId": "prompt.tool-generator.default",
  "storageQuotaBytes": 5242880,
  "storageQuotaWarnThreshold": 0.9
}

public/36/prompt-tool-generator.txt

You are an expert tool designer and JavaScript developer. Your task is to create BOTH a valid MCP (Model Context Protocol) tool definition JSON object AND a functional JavaScript implementation string based on the user's request.

User Request:
"[[USER_REQUEST]]"

Instructions:
1.  **Design the MCP Tool Definition:**
    *   Create a JSON object representing the tool according to MCP schema standards (focus on 'name', 'description', 'inputSchema' with properties, types, descriptions, and required fields).
    *   The tool name should be descriptive, use camelCase or snake_case.
    *   Ensure inputSchema types are standard JSON types ('string', 'number', 'integer', 'boolean', 'array', 'object'). Provide clear descriptions for each parameter. Only use simple types (string, number, integer, boolean) or arrays of these simple types for parameters. Avoid nested objects in the schema properties.
2.  **Implement the JavaScript Function:**
    *   Write a JavaScript string containing an 'async function run(args)' that takes a single argument 'args' (matching the 'properties' defined in your MCP inputSchema).
    *   The function should perform the requested action and return the result. The result should ideally be a JSON-serializable object, often indicating success/failure, e.g., `{ success: true, data: ... }` or `{ success: false, error: '...' }`.
    *   Use standard JavaScript (ES6+). You have access to a restricted 'console' object for logging (console.log, console.warn, console.error). Do NOT attempt to access 'window', 'document', make direct external network calls (like fetch), or use other browser-specific APIs. Keep implementations self-contained and focused on data processing or simple logic based on the inputs.
    *   Handle potential errors gracefully within the function (e.g., using try/catch) and return meaningful error information.
3.  **Output Format:** Respond ONLY with a single valid JSON object containing exactly two keys:
    *   `mcpDefinition`: The JSON object for the MCP tool definition.
    *   `jsImplementation`: The JavaScript code string for the 'async function run(args)'.

Example MCP Definition Structure:
{
  "name": "exampleToolName",
  "description": "A clear description of what the tool does.",
  "inputSchema": {
    "type": "object",
    "properties": {
      "param1": { "type": "string", "description": "Description of param1." },
      "param2": { "type": "number", "description": "Description of param2." }
    },
    "required": ["param1"]
  }
}

Example JS Implementation Structure (String):
"async function run(args) {\\n  const { param1, param2 } = args;\\n  console.log('Executing tool with:', args);\\n  try {\\n    const result = String(param1).toUpperCase() + (Number(param2) || 0);\\n    return { success: true, data: result };\\n  } catch (error) {\\n    console.error('Tool execution failed:', error);\\n    return { success: false, error: error.message };\\n  }\\n}"

Ensure the generated JSON is valid and the JavaScript string is correctly escaped if necessary within the final JSON output. Do not include ```json markdown backticks around the final JSON output.

public/36/ui-style.css

:root {
  --bg-color: #2d2d2d;
  --fg-color: #dadada;
  --border-color: #777;
  --accent-color: #811dbc;
  --error-color: #dd3642;
  --warn-color: #ffc410;
  --success-color: #66aa66;
  --font-family: monospace, sans-serif;
  --padding-sm: 0.5rem;
  --padding-md: 1rem;
  --padding-lg: 1.5rem;
  --border-radius: 4px;
}

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: var(--font-family);
  background-color: var(--bg-color);
  color: var(--fg-color);
  line-height: 1.6;
  padding: var(--padding-md);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

#loading-container {
  text-align: center;
  padding-top: 3rem;
}

#boot-log {
  background-color: #111;
  border: 1px solid var(--border-color);
  color: #ccc;
  font-size: 0.85em;
  max-height: 60vh;
  overflow-y: auto;
  padding: var(--padding-sm);
  text-align: left;
  white-space: pre-wrap;
  word-wrap: break-word;
  margin-top: var(--padding-md);
  border-radius: var(--border-radius);
}

#app-root {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  gap: var(--padding-md);
}

.hidden {
  display: none !important;
}

h1,
h2,
h3 {
  margin-bottom: var(--padding-md);
  color: var(--accent-color);
  border-bottom: 1px solid var(--border-color);
  padding-bottom: var(--padding-sm);
}

h1 {
  font-size: 1.5rem;
}
h2 {
  font-size: 1.3rem;
}
h3 {
  font-size: 1.15rem;
}

fieldset {
  border: 1px solid var(--border-color);
  padding: var(--padding-md);
  border-radius: var(--border-radius);
  margin-bottom: var(--padding-md);
}

legend {
  font-weight: bold;
  padding: 0 var(--padding-sm);
  color: var(--fg-color);
}

label {
  display: block;
  margin-bottom: var(--padding-sm);
  font-weight: bold;
}

input[type="text"],
input[type="password"],
textarea,
select {
  width: 100%;
  padding: var(--padding-sm);
  background-color: #4d4d4d;
  color: var(--fg-color);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  font-family: inherit;
  font-size: 1em;
  margin-bottom: var(--padding-md);
}

textarea {
  min-height: 100px;
  resize: vertical;
}

button {
  background-color: var(--accent-color);
  color: white;
  border: none;
  padding: var(--padding-sm) var(--padding-md);
  border-radius: var(--border-radius);
  cursor: pointer;
  font-family: inherit;
  font-size: 1em;
  transition: background-color 0.2s ease;
}

button:hover:not(:disabled) {
  background-color: #a35dc1;
}

button:disabled {
  background-color: #6d6d6d;
  cursor: not-allowed;
}

pre {
  background-color: #111;
  border: 1px solid var(--border-color);
  padding: var(--padding-sm);
  border-radius: var(--border-radius);
  overflow-x: auto;
  font-size: 0.9em;
  margin-bottom: var(--padding-sm);
  max-height: 300px;
  overflow-y: auto;
}

code {
  font-family: var(--font-family);
}

#notifications-container {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 1000;
  width: 300px;
  max-width: 90vw;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.notification {
  padding: var(--padding-sm) var(--padding-md);
  border-radius: var(--border-radius);
  color: #111;
  font-size: 0.9em;
  opacity: 0.95;
  border-left: 5px solid transparent;
  word-wrap: break-word;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.notification.info {
  background-color: #e0f2f7;
  border-left-color: #29b6f6;
}
.notification.warn {
  background-color: #fff3e0;
  border-left-color: var(--warn-color);
}
.notification.error {
  background-color: #ffebee;
  border-left-color: var(--error-color);
}
.notification.success {
  background-color: #e8f5e9;
  border-left-color: var(--success-color);
}

.notification button {
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  font-size: 1.2em;
  line-height: 1;
  padding: 0 0 0 var(--padding-sm);
  opacity: 0.6;
  margin-left: auto;
}

.notification button:hover {
  opacity: 1;
}

.tool-list {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: var(--padding-md);
}

.log-entry {
  margin-bottom: 2px;
  line-height: 1.3;
}
.log-error {
  color: var(--error-color);
  font-weight: bold;
}
.log-warn {
  color: var(--warn-color);
}
.log-info {
  color: #ccc;
}
.log-debug {
  color: #888;
}
.log-success {
  color: var(--success-color);
  font-weight: bold;
}

.control-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: var(--padding-sm);
  align-items: center;
}

.api-key-input {
  display: flex;
  align-items: baseline;
  gap: var(--padding-sm);
}

.api-key-input label {
  flex-shrink: 0;
  margin-bottom: 0;
}
.api-key-input input {
  flex-grow: 1;
  margin-bottom: 0;
}

public/36/tool-card.wc.js

import Utils from "./utils.js";

const template = document.createElement("template");
template.innerHTML = `
<style>
    :host {
        display: block;
        border: 1px solid var(--border-color, #444);
        border-radius: var(--border-radius, 4px);
        padding: var(--padding-md, 1rem);
        background-color: #2a2a2a;
        container-type: inline-size; 
    }
    h3 {
        margin-top: 0;
        margin-bottom: var(--padding-sm, 0.5rem);
        font-size: 1.1em;
        color: var(--accent-color, #007bff);
        word-break: break-all; 
    }
    .description {
        font-size: 0.9em;
        margin-bottom: var(--padding-md, 1rem);
        color: #ccc;
    }
    .metadata span {
        display: block;
        font-size: 0.8em;
        color: #aaa;
        margin-bottom: 2px;
    }
     .metadata strong {
        color: #ccc;
        min-width: 80px;
        display: inline-block;
     }
    details {
        margin-top: var(--padding-md, 1rem);
        border-top: 1px dashed var(--border-color, #444);
        padding-top: var(--padding-sm, 0.5rem);
    }
    summary {
        cursor: pointer;
        font-weight: bold;
        margin-bottom: var(--padding-sm, 0.5rem);
    }
    pre {
        margin-top: var(--padding-sm, 0.5rem);
        white-space: pre-wrap;
        word-wrap: break-word;
        max-height: 250px; 
    }
    .actions {
        margin-top: var(--padding-md, 1rem);
        border-top: 1px solid var(--border-color, #444);
        padding-top: var(--padding-md, 1rem);
        display: flex;
        flex-wrap: wrap; 
        gap: var(--padding-sm, 0.5rem);
    }
    button {
        font-size: 0.9em;
        padding: 0.4rem 0.8rem;
    }
    .delete-button {
        background-color: var(--error-color, #dc3545) !important; 
         margin-left: auto; 
    }
    .delete-button:hover {
        background-color: #a71d2a !important;
    }

     @container (max-width: 350px) {
         h3 { font-size: 1em; }
         .description { font-size: 0.85em; }
         .actions { justify-content: space-between; } 
         .delete-button { margin-left: 0; } 
     }


</style>
<h3 id="name">Tool Name</h3>
<p class="description" id="description">Tool description...</p>
<div class="metadata">
    <span><strong>ID:</strong> <code id="tool-id">tool-id</code></span>
    <span><strong>Created:</strong> <span id="created-at">timestamp</span></span>
    <span><strong>Version:</strong> <span id="version">1.0.0</span></span>
</div>
<details>
    <summary>View Definition (MCP)</summary>
    <pre><code id="mcp-definition">{}</code></pre>
</details>
<details>
    <summary>View Implementation (JS)</summary>
    <pre><code id="js-implementation">async function run(args) { }</code></pre>
</details>
<div class="actions">
    <button class="execute-button" title="Execute this tool">Execute</button>
    <button class="delete-button" title="Delete this tool permanently">Delete</button>
</div>
`;

class ToolCardComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: "open" });
    this.shadowRoot.appendChild(template.content.cloneNode(true));
    this._toolData = null;
  }

  setToolData(data) {
    if (
      !data ||
      !data.id ||
      !data.metadata ||
      !data.mcpDefinition ||
      !data.jsImplementation
    ) {
      console.error("Invalid tool data passed to tool-card:", data);

      this.shadowRoot.getElementById("name").textContent = "Invalid Tool Data";
      this.shadowRoot.getElementById("description").textContent = "";
      this.shadowRoot.getElementById("tool-id").textContent = data?.id || "N/A";
      this.shadowRoot.getElementById("created-at").textContent = "";
      this.shadowRoot.getElementById("version").textContent = "";
      this.shadowRoot.getElementById("mcp-definition").textContent = "";
      this.shadowRoot.getElementById("js-implementation").textContent = "";

      return;
    }
    this._toolData = data;
    this.render();
  }

  render() {
    if (!this._toolData) return;

    const nameEl = this.shadowRoot.getElementById("name");
    const descEl = this.shadowRoot.getElementById("description");
    const idEl = this.shadowRoot.getElementById("tool-id");
    const createdEl = this.shadowRoot.getElementById("created-at");
    const versionEl = this.shadowRoot.getElementById("version");
    const mcpEl = this.shadowRoot.getElementById("mcp-definition");
    const jsEl = this.shadowRoot.getElementById("js-implementation");

    nameEl.textContent = this._toolData.metadata.name || "(Unnamed Tool)";
    descEl.textContent =
      this._toolData.metadata.description || "(No description provided)";
    idEl.textContent = this._toolData.id;
    createdEl.textContent = this._toolData.metadata.createdAt
      ? new Date(this._toolData.metadata.createdAt).toLocaleString()
      : "N/A";
    versionEl.textContent = this._toolData.metadata.version || "N/A";

    try {
      mcpEl.textContent = JSON.stringify(this._toolData.mcpDefinition, null, 2);
    } catch (e) {
      mcpEl.textContent = `Error displaying MCP JSON: ${e.message}\n\n${this._toolData.mcpDefinition}`;
      mcpEl.style.color = "var(--error-color, red)";
    }

    const escape = Utils?.escapeHtml || ((str) => str);
    jsEl.innerHTML = escape(this._toolData.jsImplementation);
  }

  connectedCallback() {
    this.shadowRoot
      .querySelector(".delete-button")
      .addEventListener("click", () => {
        if (this._toolData) {
          this.dispatchEvent(
            new CustomEvent("delete-tool", {
              detail: {
                toolId: this._toolData.id,
                toolName: this._toolData.metadata.name,
              },
              bubbles: true,
              composed: true,
            })
          );
        }
      });

    this.shadowRoot
      .querySelector(".execute-button")
      .addEventListener("click", () => {
        if (this._toolData) {
          let args = {};
          const props = this._toolData.mcpDefinition?.inputSchema?.properties;
          if (props && Object.keys(props).length > 0) {
            try {
              const argsString = prompt(
                `Enter arguments as JSON for ${
                  this._toolData.metadata.name
                }:\n${JSON.stringify(
                  Object.keys(props)
                )}\nExample: {"param1": "value1", ...}`
              );
              if (argsString === null) {
                return;
              }
              args = argsString.trim() ? JSON.parse(argsString) : {}; // Handle empty input as empty object
            } catch (e) {
              alert(`Invalid JSON input: ${e.message}`);
              return;
            }
          } else {
            console.log(
              `Executing ${this._toolData.metadata.name} with no arguments.`
            );
          }

          this.dispatchEvent(
            new CustomEvent("execute-tool", {
              detail: {
                toolId: this._toolData.id,
                toolName: this._toolData.metadata.name,
                args: args,
              },
              bubbles: true,
              composed: true,
            })
          );
        }
      });
  }
}

export default ToolCardComponent;

public/36/ui-manager.js

import Utils from "./utils.js";
import ToolCardComponent from "./tool-card.wc.js";

const UIManagerModule = (
  config,
  logger,
  Utils,
  storage,
  StateManager,
  CycleLogic
) => {
  if (
    !config ||
    !logger ||
    !Utils ||
    !storage ||
    !StateManager ||
    !CycleLogic
  ) {
    logger?.logEvent("error", "UIManager requires all core modules.");
    return null;
  }

  let uiRefs = {};
  let isInitialized = false;

  const getRefs = () => {
    const ids = [
      "app-version",
      "storage-usage",
      "api-key-input",
      "save-api-key-button",
      "export-state-button",
      "import-state-button",
      "import-file-input",
      "download-log-button",
      "clear-storage-button",
      "status-indicator",
      "tool-request-input",
      "create-tool-button",
      "tool-list-container",
      "notifications-container",
      "main-content",
      "app-root",
    ];
    const refs = {};
    ids.forEach((id) => {
      refs[id.replace(/-(\w)/g, (match, p1) => p1.toUpperCase())] =
        Utils.$id(id);
    });

    return refs;
  };

  const updateStatus = (message, isActive = false, isError = false) => {
    if (uiRefs.statusIndicator) {
      uiRefs.statusIndicator.textContent = `Status: ${message}`;
      uiRefs.statusIndicator.style.color = isError
        ? "var(--error-color)"
        : isActive
        ? "var(--warn-color)"
        : "#aaa";
      uiRefs.statusIndicator.style.fontWeight =
        isActive || isError ? "bold" : "normal";
    }
  };

  const showNotification = (message, type = "info", duration = 5000) => {
    if (!uiRefs.notificationsContainer) return;
    const notification = document.createElement("div");
    notification.className = `notification ${type}`;
    notification.textContent = message;

    const closeButton = document.createElement("button");
    closeButton.innerHTML = "&times;";
    closeButton.onclick = () => notification.remove();
    notification.appendChild(closeButton);

    uiRefs.notificationsContainer.appendChild(notification);

    if (duration > 0) {
      setTimeout(() => {
        if (notification.parentElement) {
          // Check if still attached
          notification.remove();
        }
      }, duration);
    }
  };

  const updateStorageUsageDisplay = () => {
    if (uiRefs.storageUsage) {
      const usage = storage.getStorageUsage();
      if (usage.used >= 0) {
        uiRefs.storageUsage.textContent = `${(usage.used / 1024).toFixed(
          1
        )}KB (${usage.percent.toFixed(1)}%)`;
        if (usage.percent > config.storageQuotaWarnThreshold * 100) {
          uiRefs.storageUsage.style.color = "var(--warn-color)";
          uiRefs.storageUsage.style.fontWeight = "bold";
        } else {
          uiRefs.storageUsage.style.color = "inherit";
          uiRefs.storageUsage.style.fontWeight = "normal";
        }
      } else {
        uiRefs.storageUsage.textContent = `Error`;
        uiRefs.storageUsage.style.color = "var(--error-color)";
      }
    }
  };

  const renderToolList = () => {
    if (!uiRefs.toolListContainer) return;
    const tools = StateManager.listTools();
    uiRefs.toolListContainer.innerHTML = "";

    if (tools.length === 0) {
      uiRefs.toolListContainer.innerHTML = "<p>No tools generated yet.</p>";
      return;
    }

    tools.sort((a, b) =>
      (a.metadata?.name ?? "").localeCompare(b.metadata?.name ?? "")
    );

    tools.forEach((toolData) => {
      const toolCard = document.createElement("tool-card");
      toolCard.setToolData(toolData);

      toolCard.addEventListener("delete-tool", (event) => {
        const toolIdToDelete = event.detail.toolId;
        if (
          confirm(
            `Are you sure you want to delete the tool "${event.detail.toolName}" (${toolIdToDelete})? This cannot be undone.`
          )
        ) {
          try {
            storage.deleteArtifact(toolIdToDelete, "mcp.json");
            storage.deleteArtifact(toolIdToDelete, "impl.js");

            if (StateManager.deleteTool(toolIdToDelete)) {
              showNotification(
                `Tool "${event.detail.toolName}" deleted.`,
                "success"
              );
              renderToolList();
              updateStorageUsageDisplay();
            } else {
              showNotification(
                `Failed to delete tool "${event.detail.toolName}" from state.`,
                "error"
              );
            }
          } catch (e) {
            logger.logEvent(
              "error",
              `Error deleting tool ${toolIdToDelete} artifacts or state.`,
              e
            );
            showNotification(`Error deleting tool: ${e.message}`, "error");
          }
        }
      });

      toolCard.addEventListener("execute-tool", async (event) => {
        const { toolId, toolName, args } = event.detail;
        const tool = StateManager.getTool(toolId);
        if (tool && ToolRunner) {
          updateStatus(`Executing ${toolName}...`, true);
          try {
            const result = await ToolRunner.runJsImplementation(
              tool.jsImplementation,
              args
            );
            showNotification(
              `Tool ${toolName} executed. Result: ${JSON.stringify(result)}`,
              "info",
              8000
            );
            updateStatus("Idle");
          } catch (e) {
            showNotification(
              `Tool ${toolName} execution failed: ${e.message}`,
              "error"
            );
            updateStatus(`Execution failed`, false, true);
          }
        } else {
          showNotification(
            `Could not find tool or runner for ${toolName}.`,
            "error"
          );
          logger.logEvent(
            "error",
            `Execute failed: Tool data or runner missing for ${toolId}`
          );
        }
      });

      uiRefs.toolListContainer.appendChild(toolCard);
    });
  };

  const setupEventListeners = () => {
    uiRefs.saveApiKeyButton?.addEventListener("click", () => {
      const key = uiRefs.apiKeyInput?.value.trim() ?? "";
      StateManager.setApiKey(key);
      StateManager.saveState();
      showNotification(key ? "API Key saved." : "API Key cleared.", "info");
    });

    uiRefs.createToolButton?.addEventListener("click", async () => {
      const request = uiRefs.toolRequestInput?.value.trim() ?? "";
      if (!request) {
        showNotification("Please enter a description for the tool.", "warn");
        return;
      }
      if (!StateManager.getState()?.apiKey) {
        showNotification("Please set your Gemini API Key first.", "warn");
        return;
      }

      uiRefs.createToolButton.disabled = true;
      uiRefs.createToolButton.textContent = "Generating...";
      updateStatus("Generating tool...", true);

      const progressCallback = (type, data) => {
        logger.logEvent("debug", `Generation Progress - Type: ${type}`, data);
        if (type === "status") {
          updateStatus(data.message, data.active, data.isError);
        } else if (type === "error") {
          showNotification(`Generation Error: ${data.message}`, "error");
        } else if (type === "success") {
          showNotification(
            `Tool "${data.tool?.metadata?.name}" generated successfully!`,
            "success"
          );
          renderToolList();
          if (uiRefs.toolRequestInput) uiRefs.toolRequestInput.value = "";
        } else if (type === "final") {
          uiRefs.createToolButton.disabled = false;
          uiRefs.createToolButton.textContent = "Generate Tool";
          updateStorageUsageDisplay();
        }
      };

      await CycleLogic.generateTool(request, progressCallback);
    });

    uiRefs.exportStateButton?.addEventListener("click", () => {
      try {
        const stateToExport = StateManager.getState();
        if (!stateToExport) {
          showNotification("Cannot export: State not available.", "warn");
          return;
        }
        const dataStr = JSON.stringify(stateToExport, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `reploid-v2-state_${
          new Date().toISOString().split("T")[0]
        }.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showNotification("State exported.", "info");
      } catch (e) {
        logger.logEvent("error", "State export failed", e);
        showNotification(`State export failed: ${e.message}`, "error");
      }
    });

    uiRefs.importStateButton?.addEventListener("click", () => {
      uiRefs.importFileInput?.click();
    });

    uiRefs.importFileInput?.addEventListener("change", (event) => {
      const file = event.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          if (!e.target?.result)
            throw new Error("File content is empty or unreadable.");
          const importedState = JSON.parse(e.target.result);

          if (
            importedState &&
            typeof importedState === "object" &&
            importedState.version
          ) {
            if (importedState.version !== config.version) {
              showNotification(
                `Import failed: Version mismatch (File: ${importedState.version}, App: ${config.version})`,
                "error"
              );
            } else {
              StateManager.updateState(importedState);
              StateManager.saveState();

              if (uiRefs.apiKeyInput)
                uiRefs.apiKeyInput.value = importedState.apiKey || "";
              renderToolList();
              updateStorageUsageDisplay();
              showNotification("State imported successfully.", "success");
            }
          } else {
            throw new Error("Invalid state file format.");
          }
        } catch (err) {
          logger.logEvent("error", "State import failed", err);
          showNotification(`Import failed: ${err.message}`, "error");
        } finally {
          if (uiRefs.importFileInput) uiRefs.importFileInput.value = "";
        }
      };
      reader.onerror = (e) => {
        logger.logEvent("error", "File reading error during import", e);
        showNotification("Failed to read the selected file.", "error");
        if (uiRefs.importFileInput) uiRefs.importFileInput.value = "";
      };
      reader.readAsText(file);
    });

    uiRefs.downloadLogButton?.addEventListener("click", () => {
      try {
        const logData = logger.getLogBuffer();
        const blob = new Blob([logData], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `reploid-v2-log_${new Date()
          .toISOString()
          .replace(/[:.]/g, "-")}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (e) {
        logger.logEvent("error", "Log download failed", e);
        showNotification(`Log download failed: ${e.message}`, "error");
      }
    });

    uiRefs.clearStorageButton?.addEventListener("click", () => {
      if (
        confirm(
          "WARNING: This will delete ALL Reploid v2 data (state and generated tools) from your browser. Are you sure?"
        )
      ) {
        try {
          const count = storage.clearAllReploidData();
          showNotification(
            `Cleared ${count} items from storage. Reloading...`,
            "warn",
            3000
          );
          setTimeout(() => window.location.reload(), 1500);
        } catch (e) {
          logger.logEvent("error", "Failed to clear storage", e);
          showNotification(`Failed to clear storage: ${e.message}`, "error");
        }
      }
    });
  };

  const init = async () => {
    if (isInitialized) return;
    logger.logEvent("info", "Initializing UIManager...");

    if (!customElements.get("tool-card")) {
      customElements.define("tool-card", ToolCardComponent);
      logger.logEvent("debug", "Registered tool-card Web Component.");
    } else {
      logger.logEvent("debug", "tool-card Web Component already registered.");
    }

    uiRefs = getRefs();

    try {
      const response = await fetch("ui-body.html");
      if (!response.ok)
        throw new Error(`Failed to fetch ui-body.html: ${response.status}`);
      const uiHtml = await response.text();

      const appRoot = uiRefs.appRoot || Utils.$id("app-root");
      if (appRoot) {
        appRoot.innerHTML = uiHtml;
        uiRefs = getRefs();
      } else {
        throw new Error(
          "App root container (#app-root) not found in index.html"
        );
      }
    } catch (e) {
      logger.logEvent("error", "Failed to load main UI body", e);
      document.body.innerHTML = `<div style='color:red'><h1>UI Load Error</h1><p>${e.message}</p></div>`;
      return;
    }

    const initialState = StateManager.getState();
    if (initialState && uiRefs.apiKeyInput) {
      uiRefs.apiKeyInput.value = initialState.apiKey || "";
    }
    if (uiRefs.appVersion) {
      uiRefs.appVersion.textContent = config.version;
    }

    updateStorageUsageDisplay();
    renderToolList();
    setupEventListeners();
    updateStatus("Initialized");

    isInitialized = true;
    logger.logEvent("info", "UIManager initialized.");
  };

  return {
    init,
    showNotification,
    updateStatus,
    renderToolList,
    updateStorageUsageDisplay,
  };
};

export default UIManagerModule;

public/36/mcp-converter.js

const MCPConverterModule = (config, logger) => {
  if (!config || !logger) {
    console.error("MCPConverterModule requires config and logger.");
    return null;
  }

  const mapMcpTypeToGemini = (mcpType) => {
    switch (mcpType?.toLowerCase()) {
      case "string":
        return "STRING";
      case "integer":
        return "INTEGER";
      case "number":
        return "NUMBER";
      case "boolean":
        return "BOOLEAN";
      case "array":
        return "ARRAY";
      case "object":
        return "OBJECT";
      default:
        logger.logEvent(
          "warn",
          `Unsupported MCP type encountered during conversion: ${mcpType}. Mapping to STRING.`
        );
        return "STRING";
    }
  };

  const convertMcpProperties = (mcpProps) => {
    if (!mcpProps || typeof mcpProps !== "object") return {};
    const geminiProps = {};
    for (const key in mcpProps) {
      if (Object.hasOwnProperty.call(mcpProps, key)) {
        if (key === "$schema" || key === "additionalProperties") continue;

        const mcpProp = mcpProps[key];
        if (!mcpProp || typeof mcpProp !== "object") {
          logger.logEvent(
            "warn",
            `Skipping invalid MCP property definition for key: ${key}`
          );
          continue;
        }

        geminiProps[key] = {
          type: mapMcpTypeToGemini(mcpProp.type),
          description: mcpProp.description || `Parameter ${key}`,
        };
        if (Array.isArray(mcpProp.enum) && mcpProp.enum.length > 0) {
          geminiProps[key].enum = mcpProp.enum;
        }
        if (
          mcpProp.type === "array" &&
          mcpProp.items &&
          typeof mcpProp.items === "object"
        ) {
          if (mcpProp.items.type) {
            geminiProps[key].items = {
              type: mapMcpTypeToGemini(mcpProp.items.type),
            };
          } else {
            logger.logEvent(
              "warn",
              `MCP array property '${key}' has items definition without a 'type'. Skipping items conversion.`
            );
          }
        }

        if (mcpProp.type === "object" && mcpProp.properties) {
          logger.logEvent(
            "warn",
            `MCP property '${key}' is a nested object. Gemini FunctionDeclaration parameters generally expect a flat structure. Conversion might be partial or inaccurate.`
          );

          geminiProps[key].properties = convertMcpProperties(
            mcpProp.properties
          );
          if (Array.isArray(mcpProp.required)) {
            geminiProps[key].required = mcpProp.required;
          }
        }
      }
    }
    return geminiProps;
  };

  const mcpToGeminiFunctionDeclaration = (mcpDefinition) => {
    if (!mcpDefinition || typeof mcpDefinition !== "object") {
      throw new Error("Invalid MCP definition object provided for conversion.");
    }
    if (!mcpDefinition.name || typeof mcpDefinition.name !== "string") {
      throw new Error("MCP definition must have a valid 'name' string.");
    }
    if (
      !mcpDefinition.inputSchema ||
      typeof mcpDefinition.inputSchema !== "object"
    ) {
      logger.logEvent(
        "warn",
        `MCP definition for '${mcpDefinition.name}' missing or has invalid 'inputSchema'. Creating declaration with no parameters.`
      );
      return {
        name: mcpDefinition.name,
        description:
          mcpDefinition.description || `Function ${mcpDefinition.name}`,
        parameters: { type: "OBJECT", properties: {} },
      };
    }

    if (mcpDefinition.inputSchema.type?.toLowerCase() !== "object") {
      logger.logEvent(
        "warn",
        `MCP inputSchema type for '${mcpDefinition.name}' is not 'object' (${mcpDefinition.inputSchema.type}). Forcing to OBJECT for Gemini compatibility.`
      );
    }

    const geminiParameters = {
      type: "OBJECT",
      properties: convertMcpProperties(mcpDefinition.inputSchema.properties),
      required: Array.isArray(mcpDefinition.inputSchema.required)
        ? mcpDefinition.inputSchema.required
        : [],
    };

    if (
      Object.keys(geminiParameters.properties).length === 0 &&
      geminiParameters.required.length === 0
    ) {
    } else {
      geminiParameters.required = geminiParameters.required.filter((reqKey) =>
        geminiParameters.properties.hasOwnProperty(reqKey)
      );
    }

    const geminiDeclaration = {
      name: mcpDefinition.name,
      description:
        mcpDefinition.description || `Function ${mcpDefinition.name}`,
      parameters: geminiParameters,
    };

    logger.logEvent(
      "debug",
      `Converted MCP tool '${mcpDefinition.name}' to Gemini FunctionDeclaration.`
    );
    return geminiDeclaration;
  };

  const geminiToMcpFunctionDefinition = (geminiDeclaration) => {
    logger.logEvent(
      "warn",
      "Conversion from Gemini FunctionDeclaration back to MCP is not fully implemented."
    );

    if (!geminiDeclaration || !geminiDeclaration.name) {
      throw new Error(
        "Invalid Gemini declaration provided for conversion back to MCP."
      );
    }
    const mapGeminiTypeToMcp = (geminiType) => {
      switch (geminiType) {
        case "STRING":
          return "string";
        case "INTEGER":
          return "integer";
        case "NUMBER":
          return "number";
        case "BOOLEAN":
          return "boolean";
        case "ARRAY":
          return "array";
        case "OBJECT":
          return "object";
        default:
          return "string";
      }
    };

    const convertGeminiProperties = (geminiProps) => {
      if (!geminiProps) return {};
      const mcpProps = {};
      for (const key in geminiProps) {
        const geminiProp = geminiProps[key];
        mcpProps[key] = {
          type: mapGeminiTypeToMcp(geminiProp.type),
          description: geminiProp.description || "",
        };
        if (geminiProp.enum) mcpProps[key].enum = geminiProp.enum;
      }
      return mcpProps;
    };

    const mcpDefinition = {
      name: geminiDeclaration.name,
      description: geminiDeclaration.description || "",
      inputSchema: {
        type: "object",
        properties: convertGeminiProperties(
          geminiDeclaration.parameters?.properties
        ),
        required: geminiDeclaration.parameters?.required || [],
      },
    };
    return mcpDefinition;
  };

  return {
    mcpToGeminiFunctionDeclaration,
    geminiToMcpFunctionDefinition,
  };
};

export default MCPConverterModule;

public/36/ui-body.html

<header>
  <h1>
    DREAMER D<sub>esign</sub> R<sub>adiates</sub> E<sub>legant</sub> A<sub
      >nd</sub
    >
    M<sub>odular</sub> E<sub>lements</sub> RECOMBINED R<sub>ecursive</sub> E<sub
    >lement</sub> C<sub>reator</sub> O<sub>ptimized</sub> M<sub
      >eticulously</sub
    >
    B<sub>y</sub> I<sub>nfinite</sub> N<sub>etwork</sub> E<sub>volution</sub>
    DREAMER
  </h1>
</header>
<main id="main-content">
  <section id="controls-section">
    <fieldset>
      <legend>Controls</legend>
      <div class="control-grid">
        <div class="api-key-input">
          <label for="api-key-input">Gemini API Key:</label>
          <input
            type="password"
            id="api-key-input"
            placeholder="Enter your API key"
          />
        </div>
        <button id="save-api-key-button">Save Key</button>
        <button id="export-state-button">Export State</button>
        <button id="import-state-button">Import State</button>
        <input
          type="file"
          id="import-file-input"
          accept=".json"
          class="hidden"
        />
        <button id="download-log-button">Download Logs</button>
        <button
          id="clear-storage-button"
          style="background-color: var(--error-color)"
        >
          Clear Storage
        </button>
      </div>
      <div
        id="status-indicator"
        style="margin-top: var(--padding-sm); font-style: italic; color: #aaa"
      >
        Status: Idle
      </div>
    </fieldset>
  </section>

  <section id="tool-creation-section">
    <fieldset>
      <legend>Create New Tool</legend>
      <label for="tool-request-input"
        >Describe the tool you want to create:</label
      >
      <textarea
        id="tool-request-input"
        rows="4"
        placeholder="e.g., 'Create a tool named calculateCircleArea that takes a radius number and returns the area.'"
      ></textarea>
      <button id="create-tool-button">Generate Tool</button>
    </fieldset>
  </section>

  <section id="tool-library-section">
    <h2>Generated Tool Library</h2>
    <div id="tool-list-container" class="tool-list">
      <p>No tools generated yet.</p>
    </div>
  </section>
</main>
<footer>
  <p>
    Dreamer x<sup>2</sup> - v<span id="app-version"><sup>?.<sup>?.<sup>?.</sup></sub></sup></span>
    <div>| Storage: <span id="storage-usage">?KB (?%)</span></div>
  </p>
</footer>

public/36/api-client.js

const ApiClientModule = (config, logger) => {
  if (!config || !logger) {
    console.error("ApiClientModule requires config and logger.");
    return null;
  }

  let currentAbortController = null;
  const API_ENDPOINT_BASE = config.geminiApiBaseUrl;
  const RETRY_DELAY_BASE_MS = config.apiRetryDelayBaseMs;
  const DEFAULT_MAX_OUTPUT_TOKENS = 8192;

  const sanitizeLlmJsonResponse = (rawText) => {
    if (!rawText || typeof rawText !== "string") return null;
    let text = rawText.trim();

    const codeBlockMatch = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
    if (codeBlockMatch && codeBlockMatch[1]) {
      text = codeBlockMatch[1].trim();
      try {
        JSON.parse(text);
        return text;
      } catch (e) {
        logger.logEvent(
          "warn",
          `JSON content within code block failed validation: ${e.message}`
        );
      }
    }

    const firstBrace = text.indexOf("{");
    const firstBracket = text.indexOf("[");
    let startIndex = -1;

    if (firstBrace !== -1 && firstBracket !== -1) {
      startIndex = Math.min(firstBrace, firstBracket);
    } else {
      startIndex = Math.max(firstBrace, firstBracket);
    }

    if (startIndex !== -1) {
      text = text.substring(startIndex);
      const startChar = text[0];
      const endChar = startChar === "{" ? "}" : "]";
      let balance = 0;
      let lastValidIndex = -1;
      let inString = false;
      let escapeNext = false;

      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (inString) {
          if (escapeNext) {
            escapeNext = false;
          } else if (char === "\\") {
            escapeNext = true;
          } else if (char === '"') {
            inString = false;
          }
        } else {
          if (char === '"') {
            inString = true;
          } else if (char === startChar) {
            balance++;
          } else if (char === endChar) {
            balance--;
          }
        }
        if (!inString && balance === 0 && startIndex === 0) {
          lastValidIndex = i;
          break;
        } else if (!inString && balance === 0 && i > 0 && startIndex > 0) {
          lastValidIndex = i;
          break;
        }
      }

      if (lastValidIndex !== -1) {
        const potentialJson = text.substring(0, lastValidIndex + 1);
        try {
          JSON.parse(potentialJson);
          return potentialJson;
        } catch (e) {
          logger.logEvent(
            "warn",
            `Heuristic JSON sanitization failed validation: ${e.message}`
          );
        }
      } else {
        logger.logEvent(
          "warn",
          "JSON sanitization failed: Unbalanced structure found via heuristic."
        );
      }
    }

    logger.logEvent(
      "warn",
      "JSON sanitization failed: Could not extract valid JSON structure."
    );
    return null;
  };

  const callApiWithRetry = async (
    prompt,
    modelName,
    apiKey,
    functionDeclarations = [],
    generationConfigOverrides = {},
    progressCallback = (type, data) => {}
  ) => {
    if (currentAbortController) {
      logger.logEvent(
        "warn",
        "Aborting previous API call before starting new one."
      );
      currentAbortController.abort("New call initiated");
    }
    currentAbortController = new AbortController();
    let attempt = 0;
    const maxRetries = config.apiMaxRetries;
    let currentDelay = RETRY_DELAY_BASE_MS;

    while (attempt <= maxRetries) {
      const attemptMsg = attempt > 0 ? `[RETRY ${attempt}/${maxRetries}]` : "";
      progressCallback("status", {
        message: `${attemptMsg} Calling Gemini (${modelName})...`,
        active: true,
      });

      try {
        const apiEndpoint = `${API_ENDPOINT_BASE}${modelName}:streamGenerateContent`;
        const safetySettings = [
          "HATE_SPEECH",
          "HARASSMENT",
          "SEXUALLY_EXPLICIT",
          "DANGEROUS_CONTENT",
        ].map((cat) => ({
          category: `HARM_CATEGORY_${cat}`,
          threshold: "BLOCK_MEDIUM_AND_ABOVE",
        }));

        const generationConfig = {
          temperature: 0.5,
          maxOutputTokens: DEFAULT_MAX_OUTPUT_TOKENS,
          ...generationConfigOverrides,
        };

        const requestBody = {
          contents: [{ role: "user", parts: [{ text: prompt }] }],
          safetySettings: safetySettings,
          generationConfig: generationConfig,
          ...(functionDeclarations?.length > 0 && {
            tools: [{ functionDeclarations: functionDeclarations }],
            tool_config: { function_calling_config: { mode: "ANY" } },
          }),
        };

        if (functionDeclarations?.length === 0) {
          requestBody.generationConfig.responseMimeType = "application/json";
        }

        logger.logEvent("debug", `API Request Body (Attempt ${attempt})`, {
          endpoint: apiEndpoint,
          hasTools: functionDeclarations.length > 0,
        });

        const response = await fetch(`${apiEndpoint}?key=${apiKey}&alt=sse`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody),
          signal: currentAbortController.signal,
        });

        if (!response.ok || !response.body) {
          let errBodyText = "(Failed to read error body)";
          try {
            errBodyText = await response.text();
          } catch (e) {}
          let errJson = {};
          try {
            errJson = JSON.parse(errBodyText);
          } catch (e) {}
          const errorMessage =
            errJson?.error?.message || response.statusText || errBodyText;
          const error = new Error(
            `API Error (${response.status}): ${errorMessage}`
          );
          error.status = response.status;
          throw error;
        }

        progressCallback("status", {
          message: "Receiving stream...",
          active: true,
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let accumulatedText = "";
        let accumulatedFunctionCalls = [];
        let totalInputTokens = 0;
        let totalOutputTokens = 0;
        let finalFinishReason = "UNKNOWN";
        let blockReason = null;
        let safetyRatings = [];

        while (true) {
          if (currentAbortController?.signal.aborted)
            throw new Error("Aborted");
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              try {
                const chunk = JSON.parse(line.substring(6));

                if (chunk.promptFeedback?.blockReason) {
                  blockReason = chunk.promptFeedback.blockReason;
                  safetyRatings = chunk.promptFeedback.safetyRatings || [];
                  throw new Error(`API Blocked (Prompt): ${blockReason}`);
                }
                if (chunk.error) {
                  throw new Error(
                    `API Error in chunk: ${chunk.error.message || "Unknown"}`
                  );
                }

                totalInputTokens =
                  chunk.usageMetadata?.promptTokenCount ?? totalInputTokens;
                totalOutputTokens =
                  chunk.usageMetadata?.candidatesTokenCount ??
                  totalOutputTokens;

                const candidate = chunk.candidates?.[0];
                if (candidate) {
                  finalFinishReason =
                    candidate.finishReason || finalFinishReason;
                  safetyRatings = candidate.safetyRatings || safetyRatings;
                  if (finalFinishReason === "SAFETY") {
                    blockReason = "SAFETY";
                    throw new Error(`API Response Blocked: SAFETY`);
                  }

                  const parts = candidate.content?.parts ?? [];
                  for (const part of parts) {
                    if (part.text) {
                      accumulatedText += part.text;
                      progressCallback("progress", {
                        type: "text",
                        content: part.text,
                        accumulated: accumulatedText,
                      });
                    } else if (part.functionCall) {
                      const existingCallIndex =
                        accumulatedFunctionCalls.findIndex(
                          (fc) => fc.name === part.functionCall.name
                        );
                      if (existingCallIndex > -1) {
                        accumulatedFunctionCalls[existingCallIndex] =
                          part.functionCall;
                      } else {
                        accumulatedFunctionCalls.push(part.functionCall);
                      }
                      progressCallback("progress", {
                        type: "functionCall",
                        content: part.functionCall,
                        accumulated: [...accumulatedFunctionCalls],
                      });
                    }
                  }
                }
                if (totalInputTokens > 0 || totalOutputTokens > 0) {
                  progressCallback("status", {
                    message: `Tokens: In ${totalInputTokens}, Out ${totalOutputTokens}`,
                    active: true,
                  });
                }
              } catch (e) {
                if (
                  e.message.includes("API Blocked") ||
                  e.message.includes("API Error in chunk") ||
                  e.message.includes("Aborted")
                )
                  throw e;
                logger.logEvent(
                  "warn",
                  `Failed to parse/process SSE chunk: ${e.message}`,
                  line
                );
              }
            }
          }
        }

        progressCallback("status", {
          message: `Stream finished (${finalFinishReason}). Processing...`,
          active: true,
        });
        logger.logEvent(
          "info",
          `API Stream OK. Finish:${finalFinishReason}. Tokens In:${totalInputTokens}, Out:${totalOutputTokens}`
        );

        let resultType = "empty";
        let resultData = null;
        if (accumulatedFunctionCalls.length > 0) {
          resultType = "functionCall";
          resultData = accumulatedFunctionCalls;
        } else if (accumulatedText) {
          resultType = "text";
          resultData = accumulatedText;
        }

        const finalResult = {
          type: resultType,
          data: resultData,
          inputTokenCount: totalInputTokens,
          outputTokenCount: totalOutputTokens,
          finishReason: finalFinishReason,
          blockReason: blockReason,
          safetyRatings: safetyRatings,
        };
        progressCallback("result", finalResult);
        currentAbortController = null;
        return finalResult;
      } catch (error) {
        const isAbort = error.message.includes("Aborted");
        if (isAbort) {
          progressCallback("status", { message: "Aborted.", active: false });
          progressCallback("error", { message: error.message });
          currentAbortController = null;
          throw error;
        }

        const status = error.status || 0;
        const reason = error.message || "Unknown API error";
        progressCallback("status", {
          message: `Error (${status}): ${reason.substring(0, 50)}... Retrying?`,
          active: true,
          isError: true,
        });
        progressCallback("error", { message: reason, status: status });

        logger.logEvent(
          "warn",
          `API attempt ${attempt} failed: ${reason}. Status: ${status}. Retries left: ${
            maxRetries - attempt
          }`
        );
        attempt++;

        if (
          attempt > maxRetries ||
          status === 400 ||
          status === 401 ||
          status === 403 ||
          status === 404 ||
          error.message.includes("API Blocked")
        ) {
          logger.logEvent(
            "error",
            `API call failed permanently after ${
              attempt - 1
            } attempts or due to non-retryable error (${status}).`
          );
          progressCallback("status", {
            message: `API Failed (${status})`,
            active: false,
            isError: true,
          });
          currentAbortController = null;
          throw error;
        }

        const delayMs = Math.min(currentDelay * 2 ** (attempt - 1), 30000);
        progressCallback("status", {
          message: `Retrying in ${Math.round(delayMs / 1000)}s...`,
          active: true,
        });
        if (currentAbortController?.signal.aborted)
          throw new Error("Aborted during retry delay");
        await new Promise((resolve) => setTimeout(resolve, delayMs));
        if (currentAbortController?.signal.aborted)
          throw new Error("Aborted after retry delay");
      }
    }

    currentAbortController = null;
    throw new Error("API call failed after exhausting all retries.");
  };

  const abortCurrentCall = (reason = "User requested abort") => {
    if (currentAbortController) {
      logger.logEvent(
        "info",
        `User requested API call abort. Reason: ${reason}`
      );
      currentAbortController.abort(reason);
      currentAbortController = null;
    } else {
      logger.logEvent("info", "No active API call to abort.");
    }
  };

  return {
    callApiWithRetry,
    abortCurrentCall,
    sanitizeLlmJsonResponse,
  };
};

export default ApiClientModule;

public/36/utils.js

const UtilsModule = (() => {
  let config = null;
  let logBufferArray = [];
  let logBufferIndex = 0;
  let logBufferInitialized = false;

  const MAX_LOG_ENTRIES = () => config?.maxLogEntries ?? 1000;

  const initLogBuffer = (cfg) => {
    config = cfg;
    logBufferArray = new Array(MAX_LOG_ENTRIES());
    logBufferArray.fill(null);
    logBufferIndex = 0;
    logBufferArray[
      logBufferIndex++
    ] = `Reploid v2 Log Start - ${new Date().toISOString()}\n=========================================\n`;
    logBufferInitialized = true;
  };

  const stringifyDetail = (detail) => {
    if (detail === undefined || detail === null) return "";
    if (typeof detail === "string") return detail;
    if (detail instanceof Error)
      return `Error: ${detail.message}${
        detail.stack ? `\nStack: ${detail.stack}` : ""
      }`;
    try {
      return JSON.stringify(
        detail,
        (key, value) =>
          typeof value === "bigint" ? value.toString() + "n" : value,
        null,
        2
      );
    } catch (e) {
      return "[Unserializable Object]";
    }
  };

  const logger = {
    init: initLogBuffer,
    logEvent: (level = "info", message = "[No Message]", ...details) => {
      if (!logBufferInitialized) {
        console.warn(
          "Logger not initialized before first log event. Attempting default init."
        );
        initLogBuffer({});
      }

      const timestamp = new Date().toISOString();
      const levelUpper = String(level).toUpperCase();
      let logLine = `[${timestamp}] [${levelUpper}] ${String(message)}`;

      const detailsString = details
        .map(stringifyDetail)
        .filter((s) => s !== "")
        .join(" | ");
      if (detailsString) {
        logLine += ` | ${detailsString}`;
      }

      const currentMaxEntries = MAX_LOG_ENTRIES();
      logBufferArray[logBufferIndex % currentMaxEntries] = logLine;
      logBufferIndex++;

      const consoleMethod =
        level?.toLowerCase() === "error"
          ? console.error
          : level?.toLowerCase() === "warn"
          ? console.warn
          : level?.toLowerCase() === "debug"
          ? console.debug
          : console.log;

      consoleMethod(logLine);
    },

    getLogBuffer: () => {
      if (!logBufferInitialized) return "Log buffer not initialized.\n";
      const currentMaxEntries = MAX_LOG_ENTRIES();
      const bufferSize = Math.min(logBufferIndex, currentMaxEntries);
      const startIndex =
        logBufferIndex <= currentMaxEntries
          ? 0
          : logBufferIndex % currentMaxEntries;
      const logLines = [];
      for (let i = 0; i < bufferSize; i++) {
        const currentIndex = (startIndex + i) % currentMaxEntries;
        if (logBufferArray[currentIndex] !== null) {
          logLines.push(logBufferArray[currentIndex]);
        }
      }
      let logContent = logLines.join("\n") + "\n";

      if (logBufferIndex > currentMaxEntries) {
        logContent =
          `... (Log truncated - showing last ${currentMaxEntries} entries) ...\n` +
          logContent;
      }
      return logContent;
    },
    setLogBuffer: (newBuffer) => {
      if (!logBufferInitialized) {
        initLogBuffer({});
      }
      if (typeof newBuffer === "string") {
        const lines = newBuffer.split("\n").filter((line) => line.trim());
        const currentMaxEntries = MAX_LOG_ENTRIES();
        logBufferArray = new Array(currentMaxEntries).fill(null);

        const startIndex = Math.max(0, lines.length - currentMaxEntries);
        logBufferIndex = 0;

        let loadedCount = 0;
        for (let i = startIndex; i < lines.length; i++) {
          if (logBufferIndex < currentMaxEntries) {
            logBufferArray[logBufferIndex] = lines[i];
            logBufferIndex++;
            loadedCount++;
          } else {
            break;
          }
        }

        if (lines.length > currentMaxEntries) {
          const header = `... (Log truncated during import - loaded last ${loadedCount} lines) ...`;

          logBufferArray.unshift(header);
          if (logBufferIndex < currentMaxEntries) {
            logBufferIndex++;
          } else {
            logBufferArray[currentMaxEntries - 1] =
              logBufferArray[currentMaxEntries - 2];
            logBufferArray[0] = header;
          }
        } else {
          logBufferIndex = loadedCount;
        }
      } else {
        logger.logEvent(
          "warn",
          "setLogBuffer received invalid buffer type, resetting."
        );
        initLogBuffer(config);
      }
    },
    getConfig: () => config,
  };

  const $id = (id) => document.getElementById(id);
  const $ = (selector, parent = document) => parent.querySelector(selector);
  const $$ = (selector, parent = document) =>
    Array.from(parent.querySelectorAll(selector));

  const escapeHtml = (unsafe) => {
    if (unsafe === null || unsafe === undefined) return "";
    return String(unsafe)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  };

  const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

  const generateUUID = () => {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      function (c) {
        const r = (Math.random() * 16) | 0,
          v = c == "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      }
    );
  };

  return {
    logger,
    $id,
    $,
    $$,
    escapeHtml,
    delay,
    generateUUID,
  };
})();

export default UtilsModule;

public/36/tool-runner.js

const ToolRunnerModule = (config, logger) => {
  if (!config || !logger) {
    console.error("ToolRunnerModule requires config and logger.");
    return null;
  }

  const EXECUTION_TIMEOUT_MS = config.toolRunnerTimeoutMs || 10000;

  const runJsImplementation = async (jsCodeString, args) => {
    logger.logEvent(
      "info",
      `Attempting to execute generated JS implementation.`
    );
    logger.logEvent(
      "debug",
      `Executing code:`,
      jsCodeString.substring(0, 200) + "..."
    );
    logger.logEvent("debug", `With arguments:`, args);

    if (typeof jsCodeString !== "string" || jsCodeString.trim() === "") {
      throw new Error("Provided JS code string is empty or invalid.");
    }

    if (
      !jsCodeString.includes("async function run") &&
      !jsCodeString.includes("run = async")
    ) {
      logger.logEvent(
        "warn",
        "Generated JS code might be missing expected 'async function run(args)' structure."
      );
    }

    return new Promise(async (resolve, reject) => {
      let timeoutId = null;
      try {
        const AsyncFunction = Object.getPrototypeOf(
          async function () {}
        ).constructor;

        const restrictedConsole = {
          log: (...logArgs) => logger.logEvent("info", "Tool Log:", ...logArgs),
          warn: (...logArgs) =>
            logger.logEvent("warn", "Tool Warn:", ...logArgs),
          error: (...logArgs) =>
            logger.logEvent("error", "Tool Error:", ...logArgs),
        };

        const func = new AsyncFunction(
          "args",
          "console",
          jsCodeString + "\n\nreturn run(args);"
        );

        timeoutId = setTimeout(() => {
          reject(
            new Error(
              `Tool execution timed out after ${EXECUTION_TIMEOUT_MS}ms`
            )
          );
        }, EXECUTION_TIMEOUT_MS);

        const result = await func(args, restrictedConsole);
        clearTimeout(timeoutId);
        logger.logEvent("info", "Tool execution completed successfully.");
        logger.logEvent("debug", "Tool result:", result);
        resolve(result);
      } catch (error) {
        clearTimeout(timeoutId);
        logger.logEvent("error", "Error executing generated JS code:", error);
        reject(new Error(`Tool execution failed: ${error.message}`));
      }
    });
  };

  return {
    runJsImplementation,
  };
};

export default ToolRunnerModule;

public/36/cycle-logic.js

const CycleLogicModule = (
  config,
  logger,
  Utils,
  storage,
  StateManager,
  ApiClient,
  MCPConverter,
  ToolRunner
) => {
  if (
    !config ||
    !logger ||
    !Utils ||
    !storage ||
    !StateManager ||
    !ApiClient ||
    !MCPConverter ||
    !ToolRunner
  ) {
    logger?.logEvent("error", "CycleLogic requires all core modules.");
    return null;
  }

  let _isRunning = false;
  let isLogicInitialized = false;
  let _currentPromptArtifactId = config.defaultPromptArtifactId;

  const init = () => {
    if (isLogicInitialized) {
      logger.logEvent("warn", "CycleLogic init called multiple times.");
      return;
    }
    logger.logEvent("info", "Initializing CycleLogic...");
    isLogicInitialized = true;
    logger.logEvent("info", "CycleLogic initialized.");
  };

  const isRunning = () => _isRunning;

  const _assembleGeneratorPrompt = (toolRequest) => {
    const promptTemplate = ```
You are an expert tool designer and JavaScript developer. Your task is to create BOTH a valid MCP (Model Context Protocol) tool definition JSON object AND a functional JavaScript implementation string based on the user's request.

User Request:
"${toolRequest}"

Instructions:
1.  **Design the MCP Tool Definition:**
    *   Create a JSON object representing the tool according to MCP schema standards (focus on 'name', 'description', 'inputSchema' with properties, types, descriptions, and required fields).
    *   The tool name should be descriptive, use camelCase or snake_case.
    *   Ensure inputSchema types are standard JSON types ('string', 'number', 'integer', 'boolean', 'array', 'object'). Provide clear descriptions for each parameter.
2.  **Implement the JavaScript Function:**
    *   Write a JavaScript string containing an 'async function run(args)' that takes a single argument 'args' (matching the 'properties' defined in your MCP inputSchema).
    *   The function should perform the requested action and return the result.
    *   Use standard JavaScript (ES6+). You have access to a restricted 'console' object for logging (console.log, console.warn, console.error). Do NOT attempt to access 'window', 'document', or make external network calls directly unless the tool's explicit purpose is to wrap an API call (which is advanced). Keep implementations self-contained if possible.
    *   Handle potential errors gracefully within the function (e.g., using try/catch) and return meaningful error information if necessary.
3.  **Output Format:** Respond ONLY with a single JSON object containing two keys:
    *   \`mcpDefinition\`: The JSON object for the MCP tool definition.
    *   \`jsImplementation\`: The JavaScript code string for the 'async function run(args)'.

Example MCP Definition Structure:
{
  "name": "exampleToolName",
  "description": "A clear description of what the tool does.",
  "inputSchema": {
    "type": "object",
    "properties": {
      "param1": { "type": "string", "description": "Description of param1." },
      "param2": { "type": "number", "description": "Description of param2." }
    },
    "required": ["param1"]
  }
}

Example JS Implementation Structure (String):
"async function run(args) {\\n  const { param1, param2 } = args;\\n  console.log('Executing tool with:', args);\\n  try {\\n    const result = param1.toUpperCase() + (param2 || 0);\\n    return { success: true, data: result };\\n  } catch (error) {\\n    console.error('Tool execution failed:', error);\\n    return { success: false, error: error.message };\\n  }\\n}"

Ensure the generated JSON is valid and the JavaScript string is correctly escaped if necessary within the final JSON output.
        ```;
    logger.logEvent(
      "debug",
      "Assembled tool generator prompt for request:",
      toolRequest
    );
    return promptTemplate;
  };

  const generateTool = async (
    toolRequest,
    progressCallback = (type, data) => {}
  ) => {
    if (_isRunning) {
      logger.logEvent(
        "warn",
        "Tool generation request ignored: Already running."
      );
      progressCallback("error", {
        message: "Tool generation already in progress.",
      });
      return null;
    }
    if (
      !toolRequest ||
      typeof toolRequest !== "string" ||
      toolRequest.trim().length === 0
    ) {
      logger.logEvent("error", "Invalid tool request provided.");
      progressCallback("error", { message: "Tool request cannot be empty." });
      return null;
    }

    const state = StateManager.getState();
    if (!state) {
      logger.logEvent("error", "Cannot generate tool: StateManager not ready.");
      progressCallback("error", { message: "System state not available." });
      return null;
    }
    if (!state.apiKey) {
      logger.logEvent("error", "Cannot generate tool: API Key not set.");
      progressCallback("error", { message: "API Key is required." });
      return null;
    }

    _isRunning = true;
    StateManager.incrementCycle();
    progressCallback("status", {
      message: "Starting tool generation cycle...",
      active: true,
    });
    let generatedToolData = null;

    try {
      const prompt = _assembleGeneratorPrompt(toolRequest);
      const modelName = config.defaultModel;
      const apiKey = state.apiKey;

      StateManager.incrementApiCall();
      const apiResult = await ApiClient.callApiWithRetry(
        prompt,
        modelName,
        apiKey,
        [],
        { temperature: 0.3 },
        progressCallback
      );
      StateManager.setLastError(null);

      if (apiResult.type !== "text" || !apiResult.data) {
        throw new Error(
          `API did not return expected text content. Type: ${apiResult.type}, FinishReason: ${apiResult.finishReason}`
        );
      }

      progressCallback("status", {
        message: "Parsing LLM response...",
        active: true,
      });
      const rawJsonResponse = apiResult.data;
      const sanitizedJson = ApiClient.sanitizeLlmJsonResponse(rawJsonResponse);

      if (!sanitizedJson) {
        logger.logEvent(
          "error",
          "Failed to sanitize or extract valid JSON from LLM response.",
          { rawResponse: rawJsonResponse }
        );
        throw new Error(
          "LLM response did not contain valid JSON after sanitization."
        );
      }

      const parsedResponse = JSON.parse(sanitizedJson);

      if (
        !parsedResponse.mcpDefinition ||
        typeof parsedResponse.mcpDefinition !== "object" ||
        !parsedResponse.mcpDefinition.name
      ) {
        throw new Error(
          "LLM response JSON is missing a valid 'mcpDefinition' object with a 'name'."
        );
      }
      if (
        !parsedResponse.jsImplementation ||
        typeof parsedResponse.jsImplementation !== "string"
      ) {
        throw new Error(
          "LLM response JSON is missing a valid 'jsImplementation' string."
        );
      }

      const mcpDef = parsedResponse.mcpDefinition;
      const jsImpl = parsedResponse.jsImplementation;
      const toolId = `${mcpDef.name}-${Utils.generateUUID().substring(0, 8)}`;

      logger.logEvent(
        "info",
        `Successfully generated tool definition and implementation for: ${mcpDef.name} (ID: ${toolId})`
      );
      progressCallback("status", {
        message: `Generated ${mcpDef.name}. Saving...`,
        active: true,
      });

      try {
        const mcpJsonString = JSON.stringify(mcpDef, null, 2);
        storage.setArtifactContent(toolId, "mcp.json", mcpJsonString);
        logger.logEvent(
          "debug",
          `Saved MCP definition artifact: ${storage.getArtifactKey(
            toolId,
            "mcp.json"
          )}`
        );
      } catch (e) {
        logger.logEvent(
          "error",
          `Failed to save MCP definition artifact for ${toolId}`,
          e
        );

        StateManager.incrementErrorCount();
        StateManager.setLastError(`Failed to save MCP artifact: ${e.message}`);
      }

      try {
        storage.setArtifactContent(toolId, "impl.js", jsImpl);
        logger.logEvent(
          "debug",
          `Saved JS implementation artifact: ${storage.getArtifactKey(
            toolId,
            "impl.js"
          )}`
        );
      } catch (e) {
        logger.logEvent(
          "error",
          `Failed to save JS implementation artifact for ${toolId}`,
          e
        );

        StateManager.incrementErrorCount();
        StateManager.setLastError(`Failed to save JS artifact: ${e.message}`);
      }

      StateManager.addTool(toolId, mcpDef, jsImpl, {
        sourceRequest: toolRequest,
      });

      generatedToolData = StateManager.getTool(toolId);

      progressCallback("status", {
        message: "Tool generation complete.",
        active: false,
      });
      progressCallback("success", { tool: generatedToolData });
    } catch (error) {
      logger.logEvent("error", "Tool generation cycle failed.", error);
      StateManager.incrementErrorCount();
      StateManager.setLastError(error.message);
      progressCallback("status", {
        message: `Error: ${error.message}`,
        active: false,
        isError: true,
      });
      progressCallback("error", { message: error.message });
      generatedToolData = null;
    } finally {
      _isRunning = false;

      progressCallback("final", {});
    }
    return generatedToolData;
  };

  const abortGeneration = () => {
    if (_isRunning) {
      logger.logEvent("info", "Attempting to abort tool generation.");
      ApiClient.abortCurrentCall("User abort request");
      _isRunning = false;
    } else {
      logger.logEvent("info", "Abort request ignored: No generation running.");
    }
  };

  return {
    init,
    isRunning,
    generateTool,
    abortGeneration,
  };
};

export default CycleLogicModule;

public/36/storage.js

const StorageModule = (config, logger) => {
  if (!config || !logger) {
    console.error("StorageModule requires config and logger.");
    return null;
  }

  const LS_PREFIX = config.storagePrefix;
  const STATE_KEY_BASE = config.stateKeyBase;
  const SESSION_KEY_BASE = config.sessionKeyBase;
  const MAX_ARTIFACT_SIZE_BYTES = config.maxArtifactSizeBytes;
  const VERSION_MAJOR = String(config.version).split(".")[0];
  const stateKey = STATE_KEY_BASE + VERSION_MAJOR;
  const sessionStateKey = SESSION_KEY_BASE + VERSION_MAJOR;
  const QUOTA_BYTES = config.storageQuotaBytes;
  const QUOTA_WARN_THRESHOLD = config.storageQuotaWarnThreshold;

  const getStorageUsage = () => {
    let totalBytes = 0;
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith(LS_PREFIX) || key === stateKey)) {
          const value = localStorage.getItem(key);
          totalBytes += (value?.length ?? 0) * 2;
        }
      }
      const percent = QUOTA_BYTES > 0 ? (totalBytes / QUOTA_BYTES) * 100 : 0;
      return { used: totalBytes, quota: QUOTA_BYTES, percent: percent };
    } catch (e) {
      logger.logEvent("error", "Failed to calculate storage usage", e);
      return { used: -1, quota: QUOTA_BYTES, percent: -1 };
    }
  };

  const checkQuotaAndLog = (key, value) => {
    const usage = getStorageUsage();
    const estimatedNewSize = (value?.length ?? 0) * 2;
    const currentItemSize = (localStorage.getItem(key)?.length ?? 0) * 2;
    const estimatedUsageAfter = usage.used - currentItemSize + estimatedNewSize;

    if (
      usage.used >= 0 &&
      estimatedUsageAfter / QUOTA_BYTES > QUOTA_WARN_THRESHOLD
    ) {
      logger.logEvent(
        "warn",
        `LocalStorage usage high (${(
          (estimatedUsageAfter / QUOTA_BYTES) *
          100
        ).toFixed(1)}%) after setting key: ${key}`
      );
    }
    if (usage.used >= 0 && estimatedUsageAfter > QUOTA_BYTES) {
      const errorMsg = `Estimated usage ${(
        (estimatedUsageAfter / QUOTA_BYTES) *
        100
      ).toFixed(1)}% exceeds quota.`;
      logger.logEvent(
        "error",
        `LocalStorage Quota Exceeded estimation for key: ${key}`,
        errorMsg
      );

      return false;
    }
    return true;
  };

  const _get = (key) => {
    try {
      return localStorage.getItem(key);
    } catch (e) {
      logger.logEvent("error", `LocalStorage GET Error: ${key}`, e);
      return null;
    }
  };

  const _set = (key, value) => {
    if (typeof value !== "string") {
      logger.logEvent(
        "error",
        `Attempted to store non-string value for key: ${key}`,
        { type: typeof value }
      );
      throw new Error(`Invalid value type for localStorage: ${typeof value}`);
    }
    if (value.length * 2 > MAX_ARTIFACT_SIZE_BYTES) {
      const msg = `Value exceeds size limit (${
        value.length * 2
      } > ${MAX_ARTIFACT_SIZE_BYTES} bytes) for key: ${key}`;
      logger.logEvent("error", msg);
      throw new Error(msg);
    }

    checkQuotaAndLog(key, value);

    try {
      localStorage.setItem(key, value);
      return true;
    } catch (e) {
      let errorMessage = `LocalStorage SET Error: ${key}`;
      if (
        e.name === "QuotaExceededError" ||
        (e.code && (e.code === 22 || e.code === 1014))
      ) {
        const usage = getStorageUsage();
        errorMessage = `LocalStorage Quota Exceeded for key: ${key}. Usage: ${(
          usage.used /
          1024 /
          1024
        ).toFixed(2)}MB / ${(QUOTA_BYTES / 1024 / 1024).toFixed(2)}MB.`;
        logger.logEvent("error", errorMessage, e);
        throw new Error(errorMessage);
      } else {
        logger.logEvent("error", errorMessage, e);
        throw e;
      }
    }
  };

  const _remove = (key) => {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (e) {
      logger.logEvent("error", `LocalStorage REMOVE Error: ${key}`, e);
      return false;
    }
  };

  const getArtifactKey = (artifactId, version = "latest") => {
    if (
      !artifactId ||
      typeof artifactId !== "string" ||
      typeof version !== "string"
    ) {
      throw new Error(
        `Invalid arguments for getArtifactKey: ID=${artifactId}, Version=${version}`
      );
    }
    return `${LS_PREFIX}artifact:${artifactId}:${version}`;
  };

  const getArtifactContent = (artifactId, version = "latest") => {
    return _get(getArtifactKey(artifactId, version));
  };

  const setArtifactContent = (artifactId, version = "latest", content) => {
    return _set(getArtifactKey(artifactId, version), content);
  };

  const deleteArtifact = (artifactId, version = "latest") => {
    return _remove(getArtifactKey(artifactId, version));
  };

  const listArtifacts = () => {
    const artifacts = [];
    const prefix = `${LS_PREFIX}artifact:`;
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key?.startsWith(prefix)) {
          const parts = key.substring(prefix.length).split(":");
          if (parts.length === 2) {
            artifacts.push({ id: parts[0], version: parts[1], key: key });
          } else {
            logger.logEvent("warn", `Found malformed artifact key: ${key}`);
          }
        }
      }
    } catch (e) {
      logger.logEvent("error", "Failed to list artifacts from localStorage", e);
    }
    return artifacts;
  };

  const getState = () => {
    const json = _get(stateKey);
    if (!json) return null;
    try {
      return JSON.parse(json);
    } catch (e) {
      logger.logEvent(
        "error",
        `Failed to parse state from localStorage: ${e.message}. Removing invalid state.`
      );
      _remove(stateKey);
      return null;
    }
  };

  const saveState = (stateObj) => {
    if (!stateObj || typeof stateObj !== "object") {
      throw new Error("Invalid state object provided to saveState.");
    }
    try {
      const stateString = JSON.stringify(stateObj);
      return _set(stateKey, stateString);
    } catch (e) {
      logger.logEvent("error", "Failed to save state", e);

      throw new Error(`Failed to save state: ${e.message}`);
    }
  };

  const removeState = () => {
    return _remove(stateKey);
  };

  const getSessionState = () => {
    try {
      const json = sessionStorage.getItem(sessionStateKey);
      if (!json) return null;
      return JSON.parse(json);
    } catch (e) {
      logger.logEvent("error", `Failed to parse session state: ${e.message}`);
      try {
        sessionStorage.removeItem(sessionStateKey);
      } catch (removeError) {
        logger.logEvent(
          "warn",
          "Failed to remove invalid session state item.",
          removeError
        );
      }
      return null;
    }
  };

  const saveSessionState = (stateObj) => {
    if (!stateObj || typeof stateObj !== "object") {
      throw new Error("Invalid state object provided to saveSessionState.");
    }
    try {
      const stateString = JSON.stringify(stateObj);
      sessionStorage.setItem(sessionStateKey, stateString);
      return true;
    } catch (e) {
      logger.logEvent("error", `SessionStorage SET Error`, e);
      if (e.name === "QuotaExceededError") {
        throw new Error(`SessionStorage Quota Exceeded.`);
      }
      throw e;
    }
  };

  const removeSessionState = () => {
    try {
      sessionStorage.removeItem(sessionStateKey);
    } catch (e) {
      logger.logEvent("warn", `SessionStorage REMOVE Error`, e);
    }
  };

  const clearAllReploidData = () => {
    logger.logEvent("warn", "Initiating storage clear for Reploid v2 data.");
    let keysToRemove = [];
    let removedCount = 0;
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith(LS_PREFIX) || key === stateKey)) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach((key) => {
        if (_remove(key)) {
          removedCount++;
        }
      });
      logger.logEvent(
        "info",
        `Removed ${removedCount} keys from localStorage.`
      );

      try {
        sessionStorage.clear();
        logger.logEvent("info", "Cleared SessionStorage.");
      } catch (e) {
        logger.logEvent("warn", "Failed to clear SessionStorage.", e);
      }
    } catch (e) {
      logger.logEvent("error", `Error during clearAllReploidData`, e);
    }
    return removedCount;
  };

  return {
    LS_PREFIX,
    getArtifactKey,
    getArtifactContent,
    setArtifactContent,
    deleteArtifact,
    listArtifacts,
    getState,
    saveState,
    removeState,
    getSessionState,
    saveSessionState,
    removeSessionState,
    clearAllReploidData,
    getStorageUsage,
  };
};

export default StorageModule;
