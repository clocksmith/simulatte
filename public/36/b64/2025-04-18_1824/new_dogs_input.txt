--- CATS_START_FILE: boot.js ---
import Utils from "./utils.js";
import StorageModule from "./storage.js";

const bootstrap = async () => {
  const loadingContainer = Utils.$id("loading-container");
  const bootLog = Utils.$id("boot-log");
  const appRoot = Utils.$id("app-root");

  const logToBootScreen = (level, message, ...details) => {
    const timestamp = new Date().toISOString();
    const line = `[${timestamp}] [${level.toUpperCase()}] ${message} ${details
      .map((d) => JSON.stringify(d))
      .join(" ")}\n`;
    if (bootLog) {
      bootLog.textContent += line;
      bootLog.scrollTop = bootLog.scrollHeight;
    }

    const consoleMethod =
      level === "error"
        ? console.error
        : level === "warn"
        ? console.warn
        : console.log;
    consoleMethod(line.trim());
  };

  let config = null;
  let storage = null;
  let logger = null;

  try {
    logToBootScreen("info", "Boot sequence started...");

    logToBootScreen("info", "Fetching configuration...");
    const configResponse = await fetch("config.json");
    if (!configResponse.ok)
      throw new Error(`Failed to fetch config.json: ${configResponse.status}`);
    config = await configResponse.json();
    logToBootScreen("info", `Configuration loaded (v${config.version})`);

    Utils.logger.init(config);
    logger = Utils.logger;
    logger.logEvent("info", "Utilities and Logger initialized.");

    storage = StorageModule(config, logger);
    if (!storage) throw new Error("Storage module initialization failed.");
    logger.logEvent("info", "Storage module initialized.");
    const usage = storage.getStorageUsage();
    logger.logEvent(
      "info",
      `Initial storage usage: ${(usage.used / 1024).toFixed(
        1
      )}KB (${usage.percent.toFixed(1)}%)`
    );

    let state = storage.getState();
    if (state) {
      if (state.version !== config.version) {
        logger.logEvent(
          "warn",
          `State version mismatch (State: ${state.version}, Config: ${config.version}). Re-initializing state.`
        );
        state = null;
        storage.removeState();
      } else {
        logger.logEvent("info", `Existing state found (v${state.version}).`);
      }
    } else {
      logger.logEvent(
        "info",
        "No existing state found. Initializing new state."
      );
    }

    logger.logEvent("info", "Loading core application modules...");

    const StateManager = (await import("./state-manager.js")).default(
      config,
      logger,
      storage
    );
    const ApiClient = (await import("./api-client.js")).default(config, logger);
    const MCPConverter = (await import("./mcp-converter.js")).default(
      config,
      logger
    );
    const ToolRunner = (await import("./tool-runner.js")).default(
      config,
      logger
    );
    const CycleLogic = (await import("./cycle-logic.js")).default(
      config,
      logger,
      Utils,
      storage,
      StateManager,
      ApiClient,
      MCPConverter,
      ToolRunner
    );
    const UIManager = (await import("./ui-manager.js")).default(
      config,
      logger,
      Utils,
      storage,
      StateManager,
      CycleLogic
    );

    logger.logEvent("info", "Core modules loaded.");

    StateManager.init(state);
    logger.logEvent("info", "StateManager initialized.");

    CycleLogic.init();
    logger.logEvent("info", "CycleLogic initialized.");

    await UIManager.init();
    logger.logEvent("info", "UIManager initialized.");

    logger.logEvent("info", "Bootstrap complete. Launching application.");
    if (loadingContainer) loadingContainer.classList.add("hidden");
    if (appRoot) appRoot.classList.remove("hidden");
  } catch (error) {
    const errorMsg = `FATAL BOOTSTRAP ERROR: ${error.message}`;
    logToBootScreen("error", errorMsg, error.stack);

    if (bootLog) {
      bootLog.style.color = "var(--error-color)";
      bootLog.style.borderColor = "var(--error-color)";
    }
    if (appRoot) appRoot.classList.add("hidden");

    if (!bootLog && loadingContainer) {
      loadingContainer.innerHTML = `<h1 style="color: var(--error-color);">Initialization Failed</h1><pre style="color: var(--error-color); text-align: left; white-space: pre-wrap;">${errorMsg}\n${
        error.stack || ""
      }</pre>`;
    }
  }
};

bootstrap();

--- CATS_END_FILE ---
--- CATS_START_FILE: index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dreamer (Tool Factory)</title>
    <link
      rel="icon"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='15' fill='%23ccc'/%3E%3Cpath d='M30 70 L50 30 L70 70 Z' fill='%23333'/%3E%3Cpath d='M40 60 L60 60 L50 45 Z' fill='%23fff'/%3E%3C/svg%3E"
    />
    <link rel="stylesheet" href="ui-style.css" />
  </head>
  <body>
    <div id="loading-container">
      <h1>Loading DREAMER...</h1>
      <pre id="boot-log"></pre>
    </div>
    <div id="app-root" class="hidden"></div>
    <div id="notifications-container"></div>

    <script type="module" src="boot.js"></script>
  </body>
</html>

--- CATS_END_FILE ---
--- CATS_START_FILE: state-manager.js ---
const StateManagerModule = (config, logger, storage) => {
  if (!config || !logger || !storage) {
    logger?.logEvent(
      "error",
      "StateManager requires config, logger, and storage."
    );
    return null;
  }

  let state = null;
  let isInitialized = false;
  const sessionApiKey = "dtf_session_apiKey"; // Key for sessionStorage

  const getDefaultState = () => ({
    version: config.version,
    tools: {},
    lastError: null,
    stats: {
      toolsGenerated: 0,
      cyclesRun: 0,
      apiCalls: 0,
      errors: 0,
    },
  });

  const validateState = (loadedState) => {
    if (!loadedState || typeof loadedState !== "object") return false;
    if (loadedState.version !== config.version) {
      logger.logEvent(
        "warn",
        `State version mismatch. Loaded: ${loadedState.version}, Expected: ${config.version}. Discarding loaded state.`
      );
      return false;
    }

    if (typeof loadedState.tools !== "object" || loadedState.tools === null)
      return false;
    if (typeof loadedState.stats !== "object" || loadedState.stats === null)
      return false;

    return true;
  };

  const init = (initialStateFromStorage = null) => {
    if (isInitialized) {
      logger.logEvent("warn", "StateManager init called multiple times.");
      return;
    }
    logger.logEvent("info", "Initializing StateManager...");

    if (initialStateFromStorage && validateState(initialStateFromStorage)) {
      state = initialStateFromStorage;
      isInitialized = true;
      logger.logEvent(
        "info",
        `StateManager initialized with existing state v${state.version}`
      );
    } else {
      if (initialStateFromStorage) {
        logger.logEvent(
          "warn",
          "Invalid initial state provided or validation failed. Initializing with default."
        );
      }
      state = getDefaultState();
      isInitialized = true;
      logger.logEvent(
        "info",
        `StateManager initialized with default state v${state.version}`
      );
      saveState();
    }
  };

  const getState = () => {
    if (!isInitialized) {
      logger.logEvent(
        "error",
        "Attempted to get state before StateManager initialized."
      );
      return null;
    }
    // Note: Does not return the API key, which is session-managed
    return state;
  };

  const updateState = (newState) => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    if (!validateState(newState)) {
      throw new Error("Attempted to set invalid state.");
    }
    state = newState;
  };

  const saveState = () => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    try {
      storage.saveState(state);
      logger.logEvent("debug", "State saved successfully.");
    } catch (e) {
      logger.logEvent("error", "Failed to save state to storage.", e);
      state.lastError = `Failed to save state: ${e.message}`;
    }
  };

  const addTool = (
    toolId,
    mcpDefinition,
    jsImplementation,
    toolMetadata = {}
  ) => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    if (!state.tools) state.tools = {};
    if (state.tools[toolId]) {
      logger.logEvent(
        "warn",
        `Overwriting existing tool definition for ID: ${toolId}`
      );
    }
    if (
      !mcpDefinition ||
      typeof mcpDefinition !== "object" ||
      !mcpDefinition.name
    ) {
      throw new Error(`Invalid MCP definition provided for tool ID: ${toolId}`);
    }
    if (typeof jsImplementation !== "string" || jsImplementation.length === 0) {
      throw new Error(
        `Invalid JS implementation provided for tool ID: ${toolId}`
      );
    }

    state.tools[toolId] = {
      id: toolId,
      mcpDefinition: mcpDefinition,
      jsImplementation: jsImplementation,
      metadata: {
        createdAt: new Date().toISOString(),
        createdBy: "LLM", // Assume LLM for now
        version: toolMetadata.version || "1.0.0",
        description: mcpDefinition.description || "(No description)",
        name: mcpDefinition.name,
        originalRequest: toolMetadata.sourceRequest || "", // Store the original request
        ...toolMetadata,
      },
    };
    state.stats.toolsGenerated = (state.stats.toolsGenerated || 0) + 1;
    logger.logEvent(
      "info",
      `Tool added/updated: ${toolId} (${mcpDefinition.name})`
    );
    saveState();
  };

  const getTool = (toolId) => {
    if (!isInitialized) return null;
    return state.tools?.[toolId] ?? null;
  };

  const listTools = () => {
    if (!isInitialized) return [];
    return Object.values(state.tools || {});
  };

  const deleteTool = (toolId) => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    if (state.tools && state.tools[toolId]) {
      delete state.tools[toolId];
      logger.logEvent("info", `Tool deleted: ${toolId}`);
      saveState();
      return true;
    }
    logger.logEvent("warn", `Attempted to delete non-existent tool: ${toolId}`);
    return false;
  };

  const setApiKeyInSession = (key) => {
     if (!isInitialized) throw new Error("StateManager not initialized.");
     if (typeof key !== "string") return;
     try {
         if (key) {
             sessionStorage.setItem(sessionApiKey, key);
         } else {
             sessionStorage.removeItem(sessionApiKey);
         }
         logger.logEvent("info", `API Key ${key ? "saved" : "cleared"} in session storage.`);
     } catch (e) {
         logger.logEvent("error", `Failed to set API Key in session storage`, e);
         // Optionally notify the user via UIManager if available
     }
 };

 const getApiKeyFromSession = () => {
     if (!isInitialized) throw new Error("StateManager not initialized.");
     try {
         // Check sessionStorage first, then localStorage for backward compatibility if needed (though removed from saving)
         return sessionStorage.getItem(sessionApiKey) || localStorage.getItem("sessionKey") || ""; // Removed direct state access
     } catch (e) {
         logger.logEvent("error", `Failed to get API Key from session storage`, e);
         return "";
     }
 };


  const incrementCycle = () => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    state.stats.cyclesRun = (state.stats.cyclesRun || 0) + 1;
  };

  const incrementApiCall = () => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    state.stats.apiCalls = (state.stats.apiCalls || 0) + 1;
  };

  const incrementErrorCount = () => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    state.stats.errors = (state.stats.errors || 0) + 1;
  };

  const setLastError = (errorMessage) => {
    if (!isInitialized) throw new Error("StateManager not initialized.");
    state.lastError = errorMessage;
  };

  return {
    init,
    getState,
    updateState,
    saveState,
    addTool,
    getTool,
    listTools,
    deleteTool,
    setApiKeyInSession,
    getApiKeyFromSession,
    incrementCycle,
    incrementApiCall,
    incrementErrorCount,
    setLastError,
    isInitialized: () => isInitialized,
    sessionKey: sessionApiKey // Expose session key if needed elsewhere, though perhaps better encapsulated
  };
};

export default StateManagerModule;

--- CATS_END_FILE ---
--- CATS_START_FILE: config.json ---
{
  "appName": "Dreamer Tool Factory (DTF)",
  "version": "1.0.0",
  "storagePrefix": "_dtf_",
  "stateKeyBase": "dtf_state_v",
  "sessionKeyBase": "dtf_session_v",
  "maxLogEntries": 10000,
  "maxArtifactSizeBytes": 4194304,
  "defaultModel": "gemini-1.5-flash-latest",
  "geminiApiBaseUrl": "https://generativelanguage.googleapis.com/v1beta/models/",
  "apiKeyRetryDelayBaseMs": 1500,
  "apiMaxRetries": 2,
  "toolRunnerTimeoutMs": 15000,
  "defaultPromptArtifactId": "prompt.tool-generator.default",
  "storageQuotaBytes": 5242880,
  "storageQuotaWarnThreshold": 0.9
}

--- CATS_END_FILE ---
--- CATS_START_FILE: prompt-tool-generator.txt ---
You are an expert tool designer and JavaScript developer. Your task is to create BOTH a valid MCP (Model Context Protocol) tool definition JSON object AND a functional JavaScript implementation string based on the user's request.

User Request:
"[[USER_REQUEST]]"

Instructions:
1.  **Design the MCP Tool Definition:**
    *   Create a JSON object representing the tool according to MCP schema standards (focus on 'name', 'description', 'inputSchema' with properties, types, descriptions, and required fields).
    *   The tool name should be descriptive, use camelCase or snake_case.
    *   Ensure inputSchema types are standard JSON types ('string', 'number', 'integer', 'boolean', 'array', 'object'). Provide clear descriptions for each parameter. Only use simple types (string, number, integer, boolean) or arrays of these simple types for parameters. Avoid nested objects in the schema properties.
2.  **Implement the JavaScript Function:**
    *   Write a JavaScript string containing an 'async function run(args)' that takes a single argument 'args' (matching the 'properties' defined in your MCP inputSchema).
    *   The function should perform the requested action and return the result. The result should ideally be a JSON-serializable object, often indicating success/failure, e.g., `{ success: true, data: ... }` or `{ success: false, error: '...' }`.
    *   Use standard JavaScript (ES6+). You have access to a restricted 'console' object for logging (console.log, console.warn, console.error). Do NOT attempt to access 'window', 'document', make direct external network calls (like fetch), or use other browser-specific APIs. Keep implementations self-contained and focused on data processing or simple logic based on the inputs.
    *   Handle potential errors gracefully within the function (e.g., using try/catch) and return meaningful error information.
3.  **Output Format:** Respond ONLY with a single valid JSON object containing exactly two keys:
    *   `mcpDefinition`: The JSON object for the MCP tool definition.
    *   `jsImplementation`: The JavaScript code string for the 'async function run(args)'.

Example MCP Definition Structure:
{
  "name": "exampleToolName",
  "description": "A clear description of what the tool does.",
  "inputSchema": {
    "type": "object",
    "properties": {
      "param1": { "type": "string", "description": "Description of param1." },
      "param2": { "type": "number", "description": "Description of param2." }
    },
    "required": ["param1"]
  }
}

Example JS Implementation Structure (String):
"async function run(args) {\n  const { param1, param2 } = args;\n  console.log('Executing tool with:', args);\n  try {\n    const result = String(param1).toUpperCase() + (Number(param2) || 0);\n    return { success: true, data: result };\n  } catch (error) {\n    console.error('Tool execution failed:', error);\n    return { success: false, error: error.message };\n  }\n}"

Ensure the generated JSON is valid and the JavaScript string is correctly escaped if necessary within the final JSON output. Do not include ```json markdown backticks around the final JSON output.

--- CATS_END_FILE ---
--- CATS_START_FILE: ui-style.css ---
:root {
  --bg-color: #2d2d2d;
  --fg-color: #dadada;
  --border-color: #777;
  --accent-color: #811dbf;
  --error-color: #dd3642;
  --warn-color: #ffc410;
  --success-color: #66aa66;
  --font-family: monospace, sans-serif;
  --padding-sm: 0.5rem;
  --padding-md: 1rem;
  --padding-lg: 1.5rem;
  --border-radius: 4px;
}

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: var(--font-family);
  background-color: var(--bg-color);
  color: var(--fg-color);
  line-height: 1.6;
  padding: var(--padding-md);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

#loading-container {
  text-align: center;
  padding-top: 3rem;
}

#boot-log {
  background-color: #111;
  border: 1px solid var(--border-color);
  color: #ccc;
  font-size: 0.85em;
  max-height: 60vh;
  overflow-y: auto;
  padding: var(--padding-sm);
  text-align: left;
  white-space: pre-wrap;
  word-wrap: break-word;
  margin-top: var(--padding-md);
  border-radius: var(--border-radius);
}

#app-root {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  gap: var(--padding-md);
}

.hidden {
  display: none !important;
}

h1,
h2,
h3 {
  margin-bottom: var(--padding-md);
  color: var(--accent-color);
  border-bottom: 1px solid var(--border-color);
  padding-bottom: var(--padding-sm);
}

h1 {
  font-size: 1.5rem;
}
h2 {
  font-size: 1.3rem;
}
h3 {
  font-size: 1.15rem;
}

fieldset {
  border: 1px solid var(--border-color);
  padding: var(--padding-md);
  border-radius: var(--border-radius);
  margin-bottom: var(--padding-md);
}

legend {
  font-weight: bold;
  padding: 0 var(--padding-sm);
  color: var(--fg-color);
}

label {
  display: block;
  margin-bottom: var(--padding-sm);
  font-weight: bold;
}

input[type="text"],
input[type="password"],
input[type="search"],
input[type="number"],
input[type="checkbox"],
textarea,
select {
  width: 100%;
  padding: var(--padding-sm);
  background-color: #4d4d4d;
  color: var(--fg-color);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  font-family: inherit;
  font-size: 1em;
  margin-bottom: var(--padding-md);
}

input[type="checkbox"] {
  width: auto;
  height: 1.2em;
  vertical-align: middle;
  margin-left: var(--padding-sm);
  margin-right: var(--padding-sm);
  margin-bottom: 0.7rem; /* Align better with labels */
}


textarea {
  min-height: 100px;
  resize: vertical;
}

button {
  background-color: var(--accent-color);
  color: white;
  border: none;
  padding: var(--padding-sm) var(--padding-md);
  border-radius: var(--border-radius);
  cursor: pointer;
  font-family: inherit;
  font-size: 1em;
  transition: background-color 0.2s ease;
}

button:hover:not(:disabled) {
  background-color: #a35dc1;
}

button:disabled {
  background-color: #6d6d6d;
  cursor: not-allowed;
}

pre {
  background-color: #111;
  border: 1px solid var(--border-color);
  padding: var(--padding-sm);
  border-radius: var(--border-radius);
  overflow-x: auto;
  font-size: 0.9em;
  margin-bottom: var(--padding-sm);
  max-height: 300px;
  overflow-y: auto;
}

code {
  font-family: var(--font-family);
}

#notifications-container {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 1000;
  width: 300px;
  max-width: 90vw;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.notification {
  padding: var(--padding-sm) var(--padding-md);
  border-radius: var(--border-radius);
  color: #111;
  font-size: 0.9em;
  opacity: 0.95;
  border-left: 5px solid transparent;
  word-wrap: break-word;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.notification.info {
  background-color: #e0f2f7;
  border-left-color: #29b6f6;
}
.notification.warn {
  background-color: #fff3e0;
  border-left-color: var(--warn-color);
}
.notification.error {
  background-color: #ffebee;
  border-left-color: var(--error-color);
}
.notification.success {
  background-color: #e8f5e9;
  border-left-color: var(--success-color);
}

.notification button {
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  font-size: 1.2em;
  line-height: 1;
  padding: 0 0 0 var(--padding-sm);
  opacity: 0.6;
  margin-left: auto;
}

.notification button:hover {
  opacity: 1;
}

.tool-list-settings {
  display: flex;
  align-items: center;
  gap: var(--padding-md);
  margin-bottom: var(--padding-md);
  flex-wrap: wrap;
}

.tool-list-settings label {
  margin-bottom: 0; /* Override default */
  white-space: nowrap;
}

.tool-list-settings input,
.tool-list-settings select {
  margin-bottom: 0; /* Override default */
  width: auto;
  flex-grow: 1;
  max-width: 250px;
}

.tool-list {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: var(--padding-md);
}

.log-entry {
  margin-bottom: 2px;
  line-height: 1.3;
}
.log-error {
  color: var(--error-color);
  font-weight: bold;
}
.log-warn {
  color: var(--warn-color);
}
.log-info {
  color: #ccc;
}
.log-debug {
  color: #888;
}
.log-success {
  color: var(--success-color);
  font-weight: bold;
}

.control-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: var(--padding-sm);
  align-items: center;
}

.api-key-input {
  display: flex;
  align-items: baseline;
  gap: var(--padding-sm);
}

.api-key-input label {
  flex-shrink: 0;
  margin-bottom: 0;
}
.api-key-input input {
  flex-grow: 1;
  margin-bottom: 0;
}
.argument-input-group {
    margin-bottom: var(--padding-sm);
}
.argument-input-group label {
    display: block;
    margin-bottom: 2px;
}
.argument-input-group label span {
    font-size: 0.8em;
    font-weight: normal;
    color: #bbb;
    margin-left: 5px;
}
.argument-input-group input,
.argument-input-group select {
    margin-bottom: 0;
}

--- CATS_END_FILE ---
--- CATS_START_FILE: tool-card.wc.js ---
import Utils from "./utils.js";

const template = document.createElement("template");
template.innerHTML = `
<style>
    :host {
        display: block;
        border: 1px solid var(--border-color, #444);
        border-radius: var(--border-radius, 4px);
        padding: var(--padding-md, 1rem);
        background-color: #2a2a2a;
        container-type: inline-size;
    }
     h3 {
        margin-top: 0;
        margin-bottom: var(--padding-sm, 0.5rem);
        font-size: 1.1em;
        color: var(--accent-color, #811dbf);
        word-break: break-all;
    }
    .description {
        font-size: 0.9em;
        margin-bottom: var(--padding-md, 1rem);
        color: #ccc;
    }
    .metadata span {
        display: block;
        font-size: 0.8em;
        color: #aaa;
        margin-bottom: 2px;
    }
     .metadata strong {
        color: #ccc;
        min-width: 80px;
        display: inline-block;
    }
    details {
        margin-top: var(--padding-md, 1rem);
        border-top: 1px dashed var(--border-color, #444);
        padding-top: var(--padding-sm, 0.5rem);
    }
    summary {
        cursor: pointer;
        font-weight: bold;
        margin-bottom: var(--padding-sm, 0.5rem);
    }
    pre {
        margin-top: var(--padding-sm, 0.5rem);
        white-space: pre-wrap;
        word-wrap: break-word;
        max-height: 250px;
    }
    .actions {
        margin-top: var(--padding-md, 1rem);
        border-top: 1px solid var(--border-color, #444);
        padding-top: var(--padding-md, 1rem);
        display: flex;
        flex-wrap: wrap;
        gap: var(--padding-sm, 0.5rem);
        align-items: center;
    }
    button {
        font-size: 0.9em;
        padding: 0.4rem 0.8rem;
    }
    .actions-group {
        display: flex;
        gap: var(--padding-sm);
    }
    .delete-button {
        background-color: var(--error-color) !important;
        margin-left: auto;
    }
    .delete-button:hover {
        background-color: #a71d2a !important;
    }
    #args-container {
        display: none; /* Hidden by default */
        margin-bottom: var(--padding-md);
        width: 100%;
        border-top: 1px dashed var(--border-color, #444);
        padding-top: var(--padding-md);
    }
    #args-container.open {
        display: block;
    }
    .argument-input-group {
        margin-bottom: var(--padding-sm);
    }
    .argument-input-group label {
        display: block;
        margin-bottom: 2px;
    }
    .argument-input-group label span {
        font-size: 0.8em;
        font-weight: normal;
        color: #bbb;
        margin-left: 5px;
    }
     .argument-input-group input[type="checkbox"] {
        margin-right: 5px;
     }

    @container (max-width: 400px) {
         h3 { font-size: 1em; }
         .description { font-size: 0.85em; }
         .actions { flex-direction: column; align-items: flex-start; }
         .actions-group { margin-bottom: var(--padding-sm); }
         .delete-button { margin-left: 0; }
     }

</style>
<h3 id="name">Tool Name</h3>
<p id="description" class="description">Tool description...</p>
<div class="metadata">
    <span><strong>ID:</strong> <code id="tool-id">tool-id</code></span>
    <span><strong>Created:</strong> <span id="created-at">timestamp</span></span>
    <span><strong>Version:</strong> <span id="version">1.0.0</span></span>
</div>

<div id="args-container" class="args-container">
  <details>
    <summary>Execution Arguments</summary>
    <form id="args-form"></form>
  </details>
</div>

<details>
    <summary>View Definition (MCP)</summary>
    <pre><code id="mcp-definition">{}</code></pre>
</details>
<details>
    <summary>View Implementation (JS)</summary>
    <pre><code id="js-implementation">async function run(args) { }</code></pre>
</details>
<div class="actions">
    <div class="actions-group">
        <button class="edit-button" title="Edit the original request for this tool">Edit</button>
        <button class="execute-button" title="Execute this tool">Execute</button>
    </div>
    <button class="delete-button" title="Delete this tool permanently">Delete</button>
</div>
`;

class ToolCardComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: "open" });
    this.shadowRoot.appendChild(template.content.cloneNode(true));
    this._toolData = null;
    this.argsForm = this.shadowRoot.getElementById("args-form");
    this.argsContainer = this.shadowRoot.getElementById("args-container");
  }

  setToolData(data) {
    if (this.isInvalidToolData(data)) {
      console.error(`Invalid tool data passed to tool-card:`, data);
      this.renderError(data);
      return;
    }
    this._toolData = data;
    this.render();
    this.buildArgsForm();
  }

  isInvalidToolData(data) {
    return (
      !data ||
      !data.id ||
      !data.metadata ||
      !data.mcpDefinition ||
      !data.jsImplementation
    );
  }

  renderError(data) {
    this.shadowRoot.getElementById("name").textContent = "Invalid Tool Data";
    this.shadowRoot.getElementById("description").textContent = "";
    this.shadowRoot.getElementById("tool-id").textContent = data?.id || "N/A";
    this.shadowRoot.getElementById("created-at").textContent = "";
    this.shadowRoot.getElementById("version").textContent = "";
    this.shadowRoot.getElementById("mcp-definition").textContent = "";
    this.shadowRoot.getElementById("js-implementation").textContent = "";
    this.argsContainer.style.display = "none"; // Hide args form on error
  }

  render() {
    if (!this._toolData) return;

    const metadata = this._toolData.metadata;
    this.shadowRoot.getElementById("name").textContent = metadata.name || "(Unnamed Tool)";
    this.shadowRoot.getElementById("description").textContent =
      metadata.description || "(No description provided)";
    this.shadowRoot.getElementById("tool-id").textContent = this._toolData.id;
    this.shadowRoot.getElementById("created-at").textContent =
      metadata.createdAt
        ? new Date(metadata.createdAt).toLocaleString()
        : "N/A";
    this.shadowRoot.getElementById("version").textContent = metadata.version || "N/A";

    try {
      this.shadowRoot.getElementById("mcp-definition").textContent = JSON.stringify(this._toolData.mcpDefinition, null, 2);
    } catch (e) {
      const mcpEl = this.shadowRoot.getElementById("mcp-definition");
      mcpEl.textContent = `Error displaying MCP JSON: ${e.message}\n\n${this._toolData.mcpDefinition}`;
      mcpEl.style.color = "var(--error-color)";
    }

    const escape = Utils?.escapeHtml || ((str) => str);
    this.shadowRoot.getElementById("js-implementation").innerHTML = escape(this._toolData.jsImplementation);
  }

  buildArgsForm() {
    this.argsForm.innerHTML = '';
    const props = this._toolData.mcpDefinition?.inputSchema?.properties;
    const required = new Set(this._toolData.mcpDefinition?.inputSchema?.required || []);

    if (!props || Object.keys(props).length === 0) {
        this.argsContainer.style.display = "none";
        return;
    }
    this.argsContainer.style.display = "block";
    this.argsContainer.classList.remove("open"); // Start closed

    for (const paramName in props) {
        if (!Object.hasOwnProperty.call(props, paramName)) continue;

        const prop = props[paramName];
        const group = document.createElement("div");
        group.classList.add("argument-input-group");

        const label = document.createElement("label");
        label.htmlFor = paramName;
        label.textContent = paramName;
        if (prop.description) {
            const descSpan = document.createElement("span");
            descSpan.textContent = ` (${prop.description})`;
            label.appendChild(descSpan);
        }
        group.appendChild(label);

        let input;
        switch (prop.type) {
            case "number":
            case "integer":
                input = document.createElement("input");
                input.type = "number";
                if (prop.type === "integer") input.step = "1";
                break;
            case "boolean":
                input = document.createElement("input");
                input.type = "checkbox";
                 // Place checkbox before label text for convention
                 label.insertBefore(input, label.firstChild);
                break;
            default: // string
                input = document.createElement("input");
                input.type = "text";
                break;
        }

        input.id = paramName;
        input.name = paramName;
        if (required.has(paramName)) {
            input.setAttribute("required", "");
            label.textContent += " *"; // Indicate required
        }

        if (prop.default !== undefined) {
            if (prop.type === "boolean") {
                input.checked = prop.default;
            } else {
                input.value = prop.default;
            }
        }
        // Don't append checkbox again if inserted into label
        if(prop.type !== 'boolean') {
            group.appendChild(input);
        }

        this.argsForm.appendChild(group);
    }
  }

  collectArgs() {
    const args = {};
    const inputs = this.argsForm.querySelectorAll("input"); // Select all input types
    inputs.forEach((input) => {
      const name = input.name;
      const type = this._toolData.mcpDefinition?.inputSchema?.properties[name]?.type;
      let value;

      if (input.type === "checkbox") {
        value = input.checked;
      } else if (input.type === "number") {
        value = input.valueAsNumber;
        if (isNaN(value)) value = props[input.name]?.default ?? null; // Handle potential NaN
      } else {
        value = input.value;
      }

      if (value !== null && value !== "" ) {
        args[name] = value;
      } else if (input.required) {
        throw new Error(`Missing required argument: ${name}`);
      }
    });
    return args;
  }


  connectedCallback() {
    this.setupActionListeners();
  }

  setupActionListeners() {
    this.setupListener(".delete-button", "click", this._handleDelete);
    this.setupListener(".edit-button", "click", this._handleEdit);
    this.setupListener(".execute-button", "click", this._handleExecute);
     // Toggle args visibility when summary is clicked
    const detailsElement = this.argsContainer.querySelector('details');
    if (detailsElement) {
        detailsElement.addEventListener('toggle', () => {
            this.argsContainer.classList.toggle('open', detailsElement.open);
        });
    }
  }

  setupListener(className, eventType, handler) {
    const button = this.shadowRoot.querySelector(className);
    if (button) {
      button.addEventListener(eventType, handler.bind(this));
    }
  }

  _handleDelete() {
    if (!this._toolData) return;
    this.dispatchCustomEvent("delete-tool", {
      toolId: this._toolData.id,
      toolName: this._toolData.metadata.name,
    });
  }

  _handleEdit() {
    if (!this._toolData || !this._toolData.metadata) return;
    this.dispatchCustomEvent("edit-tool-request", {
      toolId: this._toolData.id,
      originalRequest: this._toolData.metadata.originalRequest
    });
  }

  _handleExecute() {
    if (!this._toolData) return;
    let args;
    const hasArgs = this._toolData.mcpDefinition?.inputSchema?.properties && Object.keys(this._toolData.mcpDefinition.inputSchema.properties).length > 0;

    if (hasArgs && !this.argsContainer.classList.contains('open')) {
        // Open the args section if it has args and isn't open yet
         const detailsElement = this.argsContainer.querySelector('details');
         if (detailsElement) detailsElement.open = true;
         return; // Don't execute yet, let user fill args
    }

    try {
      args = this.collectArgs();
    } catch (e) {
      alert(`Failed to collect arguments: ${e.message}`);
      return;
    }
    this.dispatchCustomEvent("execute-tool", {
      toolId: this._toolData.id,
      toolName: this._toolData.metadata.name,
      args: args,
    });
  }

  dispatchCustomEvent(eventName, detailObj) {
    this.dispatchEvent(
      new CustomEvent(eventName, {
        detail: detailObj,
        bubbles: true,
        composed: true,
      })
    );
  }
}

// Register the component if not already
customElements.get("tool-card") || customElements.define("tool-card", ToolCardComponent);

export default ToolCardComponent;

--- CATS_END_FILE ---
--- CATS_START_FILE: ui-manager.js ---
import Utils from "./utils.js";
import ToolCardComponent from "./tool-card.wc.js"; // Ensure this is imported correctly

const UIManagerModule = (
  config,
  logger,
  Utils,
  storage,
  StateManager,
  CycleLogic
) => {
  if (
    !config ||
    !logger ||
    !Utils ||
    !storage ||
    !StateManager ||
    !CycleLogic
  ) {
    logger?.logEvent("error", "UIManager requires all core modules.");
    return null;
  }

  let uiRefs = {};
  let isInitialized = false;

  const getRefs = () => {
    const ids = [
      "app-version",
      "storage-usage",
      "api-key-input",
      "save-api-key-button",
      "export-state-button",
      "import-state-button",
      "import-file-input",
      "download-log-button",
      "clear-storage-button",
      "status-indicator",
      "tool-request-input",
      "create-tool-button",
      "tool-list-container",
      "notifications-container",
      "main-content",
      "app-root",
      "tool-list-search", // Added
      "tool-list-sort",   // Added
      "tool-library-controls" // Added container for search/sort
    ];
    const refs = {};
    ids.forEach((id) => {
      const camelCase = id.replace(/-(\w)/g, (match, p1) => p1.toUpperCase());
      refs[camelCase] = Utils.$id(id);
    });
    return refs;
  };

  const updateStatus = (message, isActive = false, isError = false) => {
    if (uiRefs.statusIndicator) {
      uiRefs.statusIndicator.textContent = `Status: ${message}`;
      uiRefs.statusIndicator.style.color = isError
        ? "var(--error-color)"
        : isActive
        ? "var(--warn-color)"
        : "#aaa";
      uiRefs.statusIndicator.style.fontWeight =
        isActive || isError ? "bold" : "normal";
    }
  };

  const showNotification = (message, type = "info", duration = 5000) => {
    if (!uiRefs.notificationsContainer) return;
    const notification = document.createElement("div");
    notification.className = `notification ${type}`;
    notification.textContent = message;

    const closeButton = document.createElement("button");
    closeButton.innerHTML = "×";
    closeButton.onclick = () => notification.remove();
    notification.appendChild(closeButton);

    uiRefs.notificationsContainer.appendChild(notification);

    if (duration > 0) {
      setTimeout(() => {
        if (notification.parentElement) {
          notification.remove();
        }
      }, duration);
    }
  };

  const updateStorageUsageDisplay = () => {
    if (uiRefs.storageUsage) {
      const usage = storage.getStorageUsage();
      if (usage.used >= 0) {
        uiRefs.storageUsage.textContent = `${(usage.used / 1024).toFixed(
          1
        )}KB (${usage.percent.toFixed(1)}%)`;
        if (usage.percent > config.storageQuotaWarnThreshold * 100) {
          uiRefs.storageUsage.style.color = "var(--warn-color)";
          uiRefs.storageUsage.style.fontWeight = "bold";
        } else {
          uiRefs.storageUsage.style.color = "inherit";
          uiRefs.storageUsage.style.fontWeight = "normal";
        }
      } else {
        uiRefs.storageUsage.textContent = `Error`;
        uiRefs.storageUsage.style.color = "var(--error-color)";
      }
    }
  };

  const renderToolList = () => {
    if (!uiRefs.toolListContainer) return;
    let tools = StateManager.listTools();
    uiRefs.toolListContainer.innerHTML = "";

    const searchTerm = (uiRefs.toolListSearch?.value || "").toLowerCase();
    const sortBy = uiRefs.toolListSort?.value || "name";

    if (searchTerm) {
      tools = tools.filter((t) => {
        return (t.metadata?.name?.toLowerCase().includes(searchTerm) ||
                t.metadata?.description?.toLowerCase().includes(searchTerm) ||
                t.id?.toLowerCase().includes(searchTerm));
      });
    }

    tools.sort((a, b) => {
      const aVal = sortBy === "date"
        ? a.metadata?.createdAt
        : a.metadata?.name || "";
      const bVal = sortBy === "date"
        ? b.metadata?.createdAt
        : b.metadata?.name || "";

        if (sortBy === 'date') {
            // Sort newest first
            return new Date(bVal || 0) - new Date(aVal || 0);
        } else {
            // Sort alphabetically by name
            return (aVal || "").localeCompare(bVal || "");
        }
    });

    if (tools.length === 0) {
      uiRefs.toolListContainer.innerHTML = `<p>No tools found${searchTerm ? ' matching filter' : ''}.</p>`;
      return;
    }

    tools.forEach((toolData) => {
      const toolCard = document.createElement("tool-card");
      toolCard.setToolData(toolData);
      uiRefs.toolListContainer.appendChild(toolCard);
    });
  };

  const setupEventListeners = () => {
    uiRefs.saveApiKeyButton?.addEventListener("click", () => {
      const key = uiRefs.apiKeyInput?.value.trim() ?? "";
      StateManager.setApiKeyInSession(key);
      showNotification(key ? "API Key saved for session." : "API Key cleared for session.", "info");
    });

    uiRefs.createToolButton?.addEventListener("click", async () => {
      const request = uiRefs.toolRequestInput?.value.trim() ?? "";
      if (!request) {
        showNotification("Please enter a description for the tool.", "warn");
        return;
      }
      const apiKey = StateManager.getApiKeyFromSession();
      if (!apiKey) {
        showNotification("Please set your Gemini API Key first.", "warn");
        return;
      }

      uiRefs.createToolButton.disabled = true;
      uiRefs.createToolButton.textContent = "Generating...";
      updateStatus("Generating tool...", true);

      const progressCallback = (type, data) => {
        logger.logEvent("debug", `Generation Progress - Type: ${type}`, data);
        if (type === "status") {
          updateStatus(data.message, data.active, data.isError);
        } else if (type === "error") {
          showNotification(`Generation Error: ${data.message}`, "error");
        } else if (type === 'success') {
          showNotification(
            `Tool "${data.tool?.metadata?.name}" generated successfully!`,
            "success"
          );
          renderToolList();
          if (uiRefs.toolRequestInput) uiRefs.toolRequestInput.value = "";
        } else if (type === "final") {
          uiRefs.createToolButton.disabled = false;
          uiRefs.createToolButton.textContent = "Generate Tool";
          updateStorageUsageDisplay();
        }
      };

      await CycleLogic.generateTool(request, progressCallback);
    });

    uiRefs.exportStateButton?.addEventListener("click", () => {
      try {
        const stateToExport = StateManager.getState();
        if (!stateToExport) {
          showNotification("Cannot export: State not available.", "warn");
          return;
        }
        const dataStr = JSON.stringify(stateToExport, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `dreamer-state_${
          new Date().toISOString().split("T")[0]
        }.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showNotification("State exported.", "info");
      } catch (e) {
        logger.logEvent("error", "State export failed", e);
        showNotification(`State export failed: ${e.message}`, "error");
      }
    });

    uiRefs.importStateButton?.addEventListener("click", () => {
      uiRefs.importFileInput?.click();
    });

    uiRefs.importFileInput?.addEventListener("change", (event) => {
      const file = event.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          if (!e.target?.result)
            throw new Error("File content is empty or unreadable.");
          const importedState = JSON.parse(e.target.result);

          if (
            importedState &&
            typeof importedState === "object" &&
            importedState.version
          ) {
            if (importedState.version !== config.version) {
              showNotification(
                `Import failed: Version mismatch (File: ${importedState.version}, App: ${config.version})`,
                "error"
              );
            } else {
               // Attempt to get API key from old state format if necessary (should be session now)
              const importedApiKey = importedState.apiKey || "";

              // Update the main state (excluding the api key which is now session-managed)
              const stateToUpdate = { ...importedState };
              delete stateToUpdate.apiKey; // Remove apiKey before updating state

              StateManager.updateState(stateToUpdate);
              StateManager.saveState();

              // Set the API key in session storage
              StateManager.setApiKeyInSession(importedApiKey);
              if (uiRefs.apiKeyInput) uiRefs.apiKeyInput.value = importedApiKey; // Update UI field

              renderToolList();
              updateStorageUsageDisplay();
              showNotification("State imported successfully.", "success");
            }
          } else {
            throw new Error("Invalid state file format.");
          }
        } catch (err) {
          logger.logEvent("error", "State import failed", err);
          showNotification(`Import failed: ${err.message}`, "error");
        } finally {
          if (uiRefs.importFileInput) uiRefs.importFileInput.value = "";
        }
      };
      reader.onerror = (e) => {
        logger.logEvent("error", "File reading error during import", e);
        showNotification("Failed to read the selected file.", "error");
        if (uiRefs.importFileInput) uiRefs.importFileInput.value = "";
      };
      reader.readAsText(file);
    });

    uiRefs.downloadLogButton?.addEventListener("click", () => {
      try {
        const logData = logger.getLogBuffer();
        const blob = new Blob([logData], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `dreamer-log_${new Date()
          .toISOString()
          .replace(/[:.]/g, "-")}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (e) {
        logger.logEvent("error", "Log download failed", e);
        showNotification(`Log download failed: ${e.message}`, "error");
      }
    });

    uiRefs.clearStorageButton?.addEventListener("click", () => {
      if (
        confirm(
          "WARNING: This will delete ALL Dreamer data (state and generated tools) from your browser. Are you sure?"
        )
      ) {
        try {
          const count = storage.clearAllReploidData();
          showNotification(
            `Cleared ${count} items from storage. Reloading...`,
            "warn",
            3000
          );
          setTimeout(() => window.location.reload(), 1500);
        } catch (e) {
          logger.logEvent("error", "Failed to clear storage", e);
          showNotification(`Failed to clear storage: ${e.message}`, "error");
        }
      }
    });

    // Listener for search input
     uiRefs.toolListSearch?.addEventListener("input", () => {
         renderToolList();
     });
     // Listener for sort dropdown
     uiRefs.toolListSort?.addEventListener("change", () => {
         renderToolList();
     });

     // Listener for edit tool request events bubbling up from tool cards
     uiRefs.appRoot?.addEventListener("edit-tool-request", (event) => {
        const { toolId, originalRequest } = event.detail;
        if (uiRefs.toolRequestInput) {
            logger.logEvent("info", `Editing request for tool ${toolId}`);
            uiRefs.toolRequestInput.value = originalRequest || "";
            uiRefs.toolRequestInput.focus();
            uiRefs.toolRequestInput.scrollIntoView({ behavior: "smooth", block: "center"});

            // Temporarily change button text
            if(uiRefs.createToolButton){
                uiRefs.createToolButton.textContent = "Regenerate Tool";
                setTimeout(() => {
                     if (uiRefs.createToolButton) { // Check if still exists
                        uiRefs.createToolButton.textContent = "Generate Tool";
                     }
                }, 5000); // Reset after 5 seconds
            }
        }
     });

     // Central listener for tool execution events
     uiRefs.appRoot?.addEventListener("execute-tool", async (event) => {
        const { toolId, toolName, args } = event.detail;
        const tool = StateManager.getTool(toolId);
        if (tool && ToolRunner) {
            updateStatus(`Executing ${toolName}...`, true);
            try {
                const result = await ToolRunner.runJsImplementation(
                    tool.jsImplementation,
                    args
                );
                showNotification(
                    `Tool ${toolName} executed. Result: ${JSON.stringify(result)}`,
                    "info",
                    8000
                );
                updateStatus("Idle");
            } catch (e) {
                showNotification(
                    `Tool ${toolName} execution failed: ${e.message}`,
                    "error"
                );
                updateStatus(`Execution failed`, false, true);
            }
        } else {
            showNotification(
                `Could not find tool or runner for ${toolName}.`,
                "error"
            );
            logger.logEvent(
                "error",
                `Execute failed: Tool data or runner missing for ${toolId}`
            );
        }
    });

    // Central listener for tool deletion events
    uiRefs.appRoot?.addEventListener("delete-tool", (event) => {
        const { toolId, toolName } = event.detail;
        if (confirm(`Are you sure you want to delete the tool "${toolName}" (${toolId})? This cannot be undone.`)) {
            try {
                storage.deleteArtifact(toolId, "mcp.json");
                storage.deleteArtifact(toolId, "impl.js");

                if (StateManager.deleteTool(toolId)) {
                    showNotification(`Tool "${toolName}" deleted.`, "success");
                    renderToolList();
                    updateStorageUsageDisplay();
                } else {
                    showNotification(`Failed to delete tool "${toolName}" from state.`, "error");
                }
            } catch (e) {
                logger.logEvent("error", `Error deleting tool ${toolId} artifacts or state.`, e);
                showNotification(`Error deleting tool: ${e.message}`, "error");
            }
        }
    });
  };


  const init = async () => {
    if (isInitialized) return;
    logger.logEvent("info", "Initializing UIManager...");

    // Ensure tool-card WC is registered
    if (!customElements.get("tool-card")) {
      customElements.define("tool-card", ToolCardComponent);
    }

    try {
      const response = await fetch("ui-body.html");
      if (!response.ok)
        throw new Error(`Failed to fetch ui-body.html: ${response.status}`);
      const uiHtml = await response.text();

      const appRootContainer = Utils.$id("app-root");
      if (appRootContainer) {
        appRootContainer.innerHTML = uiHtml;
        uiRefs = getRefs(); // Re-fetch refs after loading body
      } else {
        throw new Error(
          "App root container (#app-root) not found in index.html"
        );
      }
    } catch (e) {
      logger.logEvent("error", "Failed to load main UI body", e);
      document.body.innerHTML = `<div style='color:red'><h1>UI Load Error</h1><p>${e.message}</p></div>`;
      return;
    }

    if (uiRefs.apiKeyInput) {
        uiRefs.apiKeyInput.value = StateManager.getApiKeyFromSession() || "";
    }
    if (uiRefs.appVersion) {
      uiRefs.appVersion.textContent = config.version;
    }

    updateStorageUsageDisplay();
    renderToolList(); // Initial render
    setupEventListeners();
    updateStatus("Initialized");

    isInitialized = true;
    logger.logEvent("info", "UIManager initialized.");
  };

  return {
    init,
    showNotification,
    updateStatus,
    renderToolList,
    updateStorageUsageDisplay,
  };
};

export default UIManagerModule;

--- CATS_END_FILE ---
--- CATS_START_FILE: cycle-logic.js ---
const CycleLogicModule = (
  config,
  logger,
  Utils,
  storage,
  StateManager,
  ApiClient,
  MCPConverter,
  ToolRunner
) => {
  if (
    !config ||
    !logger ||
    !Utils ||
    !storage ||
    !StateManager ||
    !ApiClient ||
    !MCPConverter ||
    !ToolRunner
  ) {
    logger?.logEvent("error", "CycleLogic requires all core modules.");
    return null;
  }

  let _isRunning = false;
  let isLogicInitialized = false;
  let _currentPromptArtifactId = config.defaultPromptArtifactId;

  const init = () => {
    if (isLogicInitialized) {
      logger.logEvent("warn", "CycleLogic init called multiple times.");
      return;
    }
    logger.logEvent("info", "Initializing CycleLogic...");
    isLogicInitialized = true;
    logger.logEvent("info", "CycleLogic initialized.");
  };

  const isRunning = () => _isRunning;

  const _assembleGeneratorPrompt = (toolRequest) => {
    // In a real scenario, you might fetch this template content,
    // but for simplicity now, it's hardcoded (matching prompt-tool-generator.txt)
    const promptTemplate = `
You are an expert tool designer and JavaScript developer. Your task is to create BOTH a valid MCP (Model Context Protocol) tool definition JSON object AND a functional JavaScript implementation string based on the user's request.

User Request:
"[[USER_REQUEST]]"

Instructions:
1.  **Design the MCP Tool Definition:**
    *   Create a JSON object representing the tool according to MCP schema standards (focus on 'name', 'description', 'inputSchema' with properties, types, descriptions, and required fields).
    *   The tool name should be descriptive, use camelCase or snake_case.
    *   Ensure inputSchema types are standard JSON types ('string', 'number', 'integer', 'boolean', 'array', 'object'). Provide clear descriptions for each parameter. Only use simple types (string, number, integer, boolean) or arrays of these simple types for parameters. Avoid nested objects in the schema properties.
2.  **Implement the JavaScript Function:**
    *   Write a JavaScript string containing an 'async function run(args)' that takes a single argument 'args' (matching the 'properties' defined in your MCP inputSchema).
    *   The function should perform the requested action and return the result. The result should ideally be a JSON-serializable object, often indicating success/failure, e.g., \`{ success: true, data: ... }\` or \`{ success: false, error: '...' }\`.
    *   Use standard JavaScript (ES6+). You have access to a restricted 'console' object for logging (console.log, console.warn, console.error). Do NOT attempt to access 'window', 'document', make direct external network calls (like fetch), or use other browser-specific APIs. Keep implementations self-contained and focused on data processing or simple logic based on the inputs.
    *   Handle potential errors gracefully within the function (e.g., using try/catch) and return meaningful error information.
3.  **Output Format:** Respond ONLY with a single valid JSON object containing exactly two keys:
    *   \`mcpDefinition\`: The JSON object for the MCP tool definition.
    *   \`jsImplementation\`: The JavaScript code string for the 'async function run(args)'.

Example MCP Definition Structure:
{
  "name": "exampleToolName",
  "description": "A clear description of what the tool does.",
  "inputSchema": {
    "type": "object",
    "properties": {
      "param1": { "type": "string", "description": "Description of param1." },
      "param2": { "type": "number", "description": "Description of param2." }
    },
    "required": ["param1"]
  }
}

Example JS Implementation Structure (String):
"async function run(args) {\\n  const { param1, param2 } = args;\\n  console.log('Executing tool with:', args);\\n  try {\\n    const result = String(param1).toUpperCase() + (Number(param2) || 0);\\n    return { success: true, data: result };\\n  } catch (error) {\\n    console.error('Tool execution failed:', error);\\n    return { success: false, error: error.message };\\n  }\\n}"

Ensure the generated JSON is valid and the JavaScript string is correctly escaped if necessary within the final JSON output. Do not include \`\`\`json markdown backticks around the final JSON output.
        `;
    const finalPrompt = promptTemplate.replace('[[USER_REQUEST]]', toolRequest);
    logger.logEvent(
      "debug",
      "Assembled tool generator prompt for request:",
      toolRequest
    );
    return finalPrompt;
  };

  const generateTool = async (
    toolRequest,
    progressCallback = (type, data) => {}
  ) => {
    if (_isRunning) {
      logger.logEvent(
        "warn",
        "Tool generation request ignored: Already running."
      );
      progressCallback("error", {
        message: "Tool generation already in progress.",
      });
      return null;
    }
    if (
      !toolRequest ||
      typeof toolRequest !== "string" ||
      toolRequest.trim().length === 0
    ) {
      logger.logEvent("error", "Invalid tool request provided.");
      progressCallback("error", { message: "Tool request cannot be empty." });
      return null;
    }

    const apiKey = StateManager.getApiKeyFromSession();
    if (!apiKey) {
      logger.logEvent("error", "Cannot generate tool: API Key not set.");
      progressCallback("error", { message: "API Key is required." });
      return null;
    }

    _isRunning = true;
    StateManager.incrementCycle();
    progressCallback("status", {
      message: "Starting tool generation cycle...",
      active: true,
    });
    let generatedToolData = null;

    try {
      const prompt = _assembleGeneratorPrompt(toolRequest);
      const modelName = config.defaultModel;

      StateManager.incrementApiCall();
      const apiResult = await ApiClient.callApiWithRetry(
        prompt,
        modelName,
        apiKey,
        [], // No function declarations needed for this call
        { temperature: 0.3 }, // Adjust generation config if needed
        progressCallback
      );
      StateManager.setLastError(null);

      if (apiResult.type !== "text" || !apiResult.data) {
        throw new Error(
          `API did not return expected text content. Type: ${apiResult.type}, FinishReason: ${apiResult.finishReason}`
        );
      }

      progressCallback("status", {
        message: "Parsing LLM response...",
        active: true,
      });
      const rawJsonResponse = apiResult.data;
      const sanitizedJson = ApiClient.sanitizeLlmJsonResponse(rawJsonResponse);

      if (!sanitizedJson) {
        logger.logEvent(
          "error",
          "Failed to sanitize or extract valid JSON from LLM response.",
          { rawResponse: rawJsonResponse }
        );
        throw new Error(
          "LLM response did not contain valid JSON after sanitization."
        );
      }

      const parsedResponse = JSON.parse(sanitizedJson);

      if (
        !parsedResponse.mcpDefinition ||
        typeof parsedResponse.mcpDefinition !== "object" ||
        !parsedResponse.mcpDefinition.name
      ) {
        throw new Error(
          "LLM response JSON is missing a valid 'mcpDefinition' object with a 'name'."
        );
      }
      if (
        !parsedResponse.jsImplementation ||
        typeof parsedResponse.jsImplementation !== "string"
      ) {
        throw new Error(
          "LLM response JSON is missing a valid 'jsImplementation' string."
        );
      }

      const mcpDef = parsedResponse.mcpDefinition;
      const jsImpl = parsedResponse.jsImplementation;
      // Ensure name uniqueness or handle collision - using UUID for now
      const toolId = `${mcpDef.name}-${Utils.generateUUID().substring(0, 8)}`;

      logger.logEvent(
        "info",
        `Successfully generated tool definition and implementation for: ${mcpDef.name} (ID: ${toolId})`
      );
      progressCallback("status", {
        message: `Generated ${mcpDef.name}. Saving...`,
        active: true,
      });

      try {
        const mcpJsonString = JSON.stringify(mcpDef, null, 2);
        storage.setArtifactContent(toolId, "mcp.json", mcpJsonString);
        logger.logEvent(
          "debug",
          `Saved MCP definition artifact: ${storage.getArtifactKey(
            toolId,
            "mcp.json"
          )}`
        );
      } catch (e) {
        logger.logEvent(
          "error",
          `Failed to save MCP definition artifact for ${toolId}`,
          e
        );
        StateManager.incrementErrorCount();
        StateManager.setLastError(`Failed to save MCP artifact: ${e.message}`);
        // Continue saving JS and state if possible
      }

      try {
        storage.setArtifactContent(toolId, "impl.js", jsImpl);
        logger.logEvent(
          "debug",
          `Saved JS implementation artifact: ${storage.getArtifactKey(
            toolId,
            "impl.js"
          )}`
        );
      } catch (e) {
        logger.logEvent(
          "error",
          `Failed to save JS implementation artifact for ${toolId}`,
          e
        );
        StateManager.incrementErrorCount();
        StateManager.setLastError(`Failed to save JS artifact: ${e.message}`);
         // Continue saving state if possible
      }

      // Add to state, including the original request in metadata
      StateManager.addTool(toolId, mcpDef, jsImpl, {
        sourceRequest: toolRequest, // Pass original request here
      });

      generatedToolData = StateManager.getTool(toolId);

      progressCallback("status", {
        message: "Tool generation complete.",
        active: false,
      });
      progressCallback("success", { tool: generatedToolData });

    } catch (error) {
      logger.logEvent("error", "Tool generation cycle failed.", error);
      StateManager.incrementErrorCount();
      StateManager.setLastError(error.message);
      progressCallback("status", {
        message: `Error: ${error.message}`,
        active: false,
        isError: true,
      });
      progressCallback("error", { message: error.message });
      generatedToolData = null;
    } finally {
      _isRunning = false;
      progressCallback("final", {});
    }
    return generatedToolData;
  };

  const abortGeneration = () => {
    if (_isRunning) {
      logger.logEvent("info", "Attempting to abort tool generation.");
      ApiClient.abortCurrentCall("User abort request");
      _isRunning = false; // Ensure state is reset even if abort signal is slow
    } else {
      logger.logEvent("info", "Abort request ignored: No generation running.");
    }
  };

  return {
    init,
    isRunning,
    generateTool,
    abortGeneration,
  };
};

export default CycleLogicModule;

--- CATS_END_FILE ---
--- CATS_START_FILE: storage.js ---
const StorageModule = (config, logger) => {
  if (!config || !logger) {
    console.error("StorageModule requires config and logger.");
    return null;
  }

  const LS_PREFIX = config.storagePrefix;
  const STATE_KEY_BASE = config.stateKeyBase;
  const MAX_ARTIFACT_SIZE_BYTES = config.maxArtifactSizeBytes;
  const VERSION_MAJOR = String(config.version).split(".")[0];
  const stateKey = STATE_KEY_BASE + VERSION_MAJOR;
  const QUOTA_BYTES = config.storageQuotaBytes;
  const QUOTA_WARN_THRESHOLD = config.storageQuotaWarnThreshold;

  const getStorageUsage = () => {
    let totalBytes = 0;
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith(LS_PREFIX) || key === stateKey)) {
          const value = localStorage.getItem(key);
          totalBytes += (value?.length ?? 0) * 2; // Estimate bytes (UTF-16)
        }
      }
      const percent = QUOTA_BYTES > 0 ? (totalBytes / QUOTA_BYTES) * 100 : 0;
      return { used: totalBytes, quota: QUOTA_BYTES, percent: percent };
    } catch (e) {
      logger.logEvent("error", "Failed to calculate storage usage", e);
      return { used: -1, quota: QUOTA_BYTES, percent: -1 };
    }
  };

  const checkQuotaAndLog = (key, value) => {
    const usage = getStorageUsage();
    const estimatedNewSize = (value?.length ?? 0) * 2;
    const currentItemSize = (localStorage.getItem(key)?.length ?? 0) * 2;
    const estimatedUsageAfter = usage.used - currentItemSize + estimatedNewSize;

    if (
      usage.used >= 0 &&
      QUOTA_BYTES > 0 &&
      (estimatedUsageAfter / QUOTA_BYTES) > QUOTA_WARN_THRESHOLD
    ) {
      logger.logEvent(
        "warn",
        `LocalStorage usage high (${(
          (estimatedUsageAfter / QUOTA_BYTES) *
          100
        ).toFixed(1)}%) after setting key: ${key}`
      );
    }
    if (usage.used >= 0 && MAX_ARTIFACT_SIZE_BYTES > 0 && estimatedUsageAfter > QUOTA_BYTES) {
        const errMng = `Estimated usage ${((estimatedUsageAfter / QUOTA_BYTES) * 100).toFixed(1)}% exceeds quota.`;
      logger.logEvent(
        "error",
        `LocalStorage Quota Exceeded estimation for key: ${key}`,
        errMng
      );
      // We will let the setItem fail naturally, but we logged the warning/error
      // Returning false here is less useful as the actual setItem might still succeed briefly
      // return false;
    }
    return true; // Indicate check passed (doesn't guarantee setItem success)
  };


  const _get = (key) => {
    try {
      return localStorage.getItem(key);
    } catch (e) {
      logger.logEvent("error", `LocalStorage GET Error: ${key}`, e);
      return null;
    }
  };

  const _set = (key, value) => {
    if (typeof value !== "string") {
      logger.logEvent(
        "error",
        `Attempted to store non-string value for key: ${key}`,
        { type: typeof value }
      );
      throw new Error(`Invalid value type for localStorage: ${typeof value}`);
    }
    if (value.length * 2 > MAX_ARTIFACT_SIZE_BYTES) {
        const msg = `Value exceeds size limit (${value.length * 2} > ${MAX_ARTIFACT_SIZE_BYTES} bytes) for key: ${key}`;
        logger.logEvent("error", msg);
        throw new Error(msg);
    }

    checkQuotaAndLog(key, value); // Log warnings/errors but don't prevent the attempt

    try {
        localStorage.setItem(key, value);
        return true;
    } catch (e) {
        let errorMessage = `LocalStorage SET Error: ${key}`;
        if (
            e.name === "QuotaExceededError" ||
            (e.code && (e.code === 22 || e.code === 1014)) // DOMException codes for quota exceeded in older browsers
        ) {
            const usage = getStorageUsage();
            errorMessage = `LocalStorage Quota Exceeded for key: ${key}. Usage: ${(
                usage.used / 1024 / 1024
            ).toFixed(2)}MB / ${(QUOTA_BYTES / 1024 / 1024).toFixed(2)}MB.`;
            logger.logEvent("error", errorMessage, e);
            throw new Error(errorMessage); // Throw a specific error for quota
        } else {
            // Other potential errors (security, etc.)
            logger.logEvent("error", errorMessage, e);
            throw e; // Re-throw the original error
        }
    }
};


  const _remove = (key) => {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (e) {
      logger.logEvent("error", `LocalStorage REMOVE Error: ${key}`, e);
      return false;
    }
  };

  const getArtifactKey = (artifactId, version = "latest") => {
    // Using simple concatenation, ensuring parts are valid strings
    if (
        !artifactId ||
        typeof artifactId !== "string" ||
        typeof version !== "string"
    ) {
        throw new Error(
            `Invalid arguments for getArtifactKey: ID=${artifactId}, Version=${version}`
        );
    }
    // Basic sanitization: replace potentially problematic chars like ':' or '/'
    const cleanId = artifactId.replace(/[:/]/g, '_');
    const cleanVersion = version.replace(/[:/]/g, '_');
    return `${LS_PREFIX}artifact:${cleanId}:${cleanVersion}`;
  };


  const getArtifactContent = (artifactId, version = "latest") => {
    return _get(getArtifactKey(artifactId, version));
  };

  const setArtifactContent = (artifactId, version = "latest", content) => {
     // Important: Use the same key generation logic as getArtifactContent
     const key = getArtifactKey(artifactId, version.endsWith('.js') || version.endsWith('.json') ? version : `${version}.impl.js`); // Adjust based on how version is used
     if(version === "mcp.json" || version === "impl.js") {
         key = getArtifactKey(artifactId, version);
     } else {
         // Fallback or default if only ID and content are passed
         key = getArtifactKey(artifactId, "latest");
     }

     return _set(key, content);
  };


  const deleteArtifact = (artifactId, version = "latest") => {
    // Allow deleting specific versions like "mcp.json" or "impl.js" directly
    const key = getArtifactKey(artifactId, version);
    return _remove(key);
  };

  const listArtifacts = () => {
    const artifacts = [];
    const prefix = `${LS_PREFIX}artifact:`;
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key?.startsWith(prefix)) {
          const parts = key.substring(prefix.length).split(":");
          if (parts.length >= 2) { // Expecting ID:version at least
            const id = parts[0];
            const version = parts.slice(1).join(':'); // Rejoin if version had ':'
            artifacts.push({ id: id, version: version, key: key });
          } else {
            logger.logEvent("warn", `Found malformed artifact key: ${key}`);
          }
        }
      }
    } catch (e) {
      logger.logEvent("error", "Failed to list artifacts from localStorage", e);
    }
    return artifacts;
  };


  const getState = () => {
    const json = _get(stateKey);
    if (!json) return null;
    try {
      return JSON.parse(json);
    } catch (e) {
      logger.logEvent(
        "error",
        `Failed to parse state from localStorage: ${e.message}. Removing invalid state.`
      );
      _remove(stateKey);
      return null;
    }
  };

  const saveState = (stateObj) => {
    if (!stateObj || typeof stateObj !== "object") {
      throw new Error("Invalid state object provided to saveState.");
    }
    try {
      const stateString = JSON.stringify(stateObj);
      return _set(stateKey, stateString);
    } catch (e) {
      logger.logEvent("error", "Failed to save state", e);
      // Re-throw specific QuotaExceededError if caught by _set
      if (e.message.includes("Quota Exceeded")) {
           throw e;
      }
      throw new Error(`Failed to save state: ${e.message}`);
    }
  };


  const removeState = () => {
    return _remove(stateKey);
  };

  // Session state functions removed as API key is handled directly by StateManager now.

  const clearAllReploidData = () => {
    logger.logEvent("warn", "Initiating storage clear for Dreamer data.");
    let keysToRemove = [];
    let removedCount = 0;
    try {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith(LS_PREFIX) || key === stateKey || key === "sessionKey" /* old session key */)) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach((key) => {
        if (_remove(key)) {
          removedCount++;
        }
      });
      logger.logEvent(
        "info",
        `Removed ${removedCount} keys from localStorage.`
      );

      try {
        sessionStorage.clear(); // Clear session storage too
        logger.logEvent("info", "Cleared SessionStorage.");
      } catch (e) {
        logger.logEvent("warn", "Failed to clear SessionStorage.", e);
      }
    } catch (e) {
      logger.logEvent("error", `Error during clearAllReploidData`, e);
    }
    return removedCount;
  };

  return {
    LS_PREFIX,
    getArtifactKey,
    getArtifactContent,
    setArtifactContent,
    deleteArtifact,
    listArtifacts,
    getState,
    saveState,
    removeState,
    // No session state methods exported
    clearAllReploidData,
    getStorageUsage,
  };
};

export default StorageModule;

--- CATS_END_FILE ---