<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UTP - Unified Topology Processor</title>
  <meta name="description" content="Visualise TPU-style torus networks in 2D and on a 3D torus with live traffic and compute simulations.">
  <link rel="stylesheet" href="../simulatte-core.css">
  <style>
    :root {
      --accent-magenta: var(--accent-primary);
      --accent-green: var(--accent-secondary);
      --accent-cyan: var(--accent-tertiary);
    }

    body {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      background: var(--bg-dark);
      color: var(--text-primary);
      padding: 20px;
      overflow-x: hidden;
    }

    .container {
      max-width: 1800px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 20px;
      padding: 20px;
      background: var(--bg-medium);
      border: 1px solid var(--border);
      border-radius: 8px;
    }

    h1 {
      font-size: 2rem;
      font-weight: bold;
      margin-bottom: 8px;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .mode-selector {
      margin-bottom: 15px;
    }

    .mode-selector h3 {
      color: var(--accent-cyan);
      margin-bottom: 10px;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .mode-buttons {
      display: flex;
      flex-wrap: wrap;
      width: 100%;
      gap: 8px;
    }

    .mode-btn {
      flex: 1;
      min-width: 140px;
      font-weight: 600;
      font-size: 0.85rem;
    }

    .info-box {
      background: var(--bg-light);
      border-left: 3px solid var(--accent-cyan);
      padding: 12px;
      margin-bottom: 15px;
      border-radius: 4px;
    }

    .info-box h4 {
      color: var(--accent-cyan);
      font-size: 0.8rem;
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    .info-box p {
      color: var(--text-secondary);
      font-size: 0.75rem;
      line-height: 1.5;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .dual-viz-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }

    .visualization-panel {
      display: flex;
      flex-direction: column;
    }

    .visualization-panel h2 {
      color: var(--accent-green);
      margin-bottom: 10px;
      font-size: 1rem;
      text-align: center;
    }

    .viz-description {
      color: var(--text-secondary);
      font-size: 0.7rem;
      margin-bottom: 12px;
      text-align: center;
      line-height: 1.4;
    }

    canvas {
      display: block;
      width: 100%;
      height: 450px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #050505;
    }

    #torus-canvas {
      cursor: grab;
    }

    #torus-canvas:active {
      cursor: grabbing;
    }

    #grid-canvas {
      cursor: pointer;
    }

    .metrics-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .metric-group h3 {
      color: var(--accent-orange);
      margin-bottom: 10px;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 0.8rem;
    }

    .metric-label {
      color: var(--text-secondary);
    }

    .metric-value {
      color: var(--accent-green);
      font-weight: bold;
      font-family: 'SF Mono', monospace;
    }

    .metric-value.warning {
      color: var(--accent-orange);
    }

    .metric-value.critical {
      color: var(--accent-red);
    }

    .controls h3 {
      color: var(--accent-magenta);
      margin-bottom: 12px;
      font-size: 0.9rem;
      text-transform: uppercase;
    }

    .control-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 12px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
    }

    label {
      color: var(--text-secondary);
      margin-bottom: 5px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      background: var(--bg-light);
      border-radius: 3px;
      outline: none;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: var(--accent-magenta);
      border-radius: 50%;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: var(--accent-magenta);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .value-display {
      color: var(--accent-green);
      font-weight: bold;
      margin-left: 4px;
      font-family: 'SF Mono', monospace;
    }

    button {
      background: var(--accent-magenta);
      color: var(--text-primary);
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'SF Mono', monospace;
    }

    button:hover {
      background: var(--accent-magenta-dim);
    }

    button:active {
      background: var(--accent-magenta-dim);
      opacity: 0.85;
    }

    @media (max-width: 1400px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
      .dual-viz-container {
        grid-template-columns: 1fr;
      }
      canvas {
        height: 500px;
      }
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      .control-row {
        grid-template-columns: 1fr;
      }

      canvas {
        height: 350px;
      }

      .mode-btn {
        min-width: 100px;
        font-size: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="loading-screen" style="position: fixed; inset: 0; background: var(--bg-dark); display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 20px; z-index: 9999;">
      <div style="font-size: 1.5rem; color: var(--accent-cyan);">Initializing TPU Topology...</div>
      <div style="width: 50px; height: 50px; border: 3px solid rgba(0,255,255,0.2); border-top-color: var(--accent-cyan); border-radius: 50%; animation: spin-utp 1s linear infinite;"></div>
    </div>
    <style>
      @keyframes spin-utp { to { transform: rotate(360deg); } }
    </style>
    <header>
      <a href="/" style="color: var(--accent-cyan); text-decoration: none; font-size: 0.85rem; display: inline-block; margin-bottom: 8px;">← Back to Gallery</a>
      <h1>UTP - Unified Topology Processor</h1>
      <p class="subtitle">Dual 2D grid and rotatable 3D torus views of TPU networks with configurable twist offsets</p>
    </header>


    <div class="mode-selector panel">
      <h3>⎈ Simulation Mode</h3>
      <div class="mode-buttons toggle-group">
        <button class="mode-btn toggle-button" data-sim="gameoflife">Game of Life</button>
        <button class="mode-btn toggle-button active" data-sim="bandwidth">Bandwidth Traffic &amp; Heat</button>
      </div>
    </div>

    <div class="info-box">
      <h4>☙ About This Simulation</h4>
      <p id="mode-description"></p>
    </div>

    <div class="main-grid">
      <div class="dual-viz-container">
        <div class="visualization-panel panel">
          <h2>2D Torus Grid</h2>
          <p class="viz-description">Cardinal neighbors with wrap-around edges. Fill color shows accumulated heat; neon edges mark busy links.</p>
          <canvas id="grid-canvas"></canvas>
        </div>
        <div class="visualization-panel panel">
          <h2>3D Torus Surface</h2>
          <p class="viz-description">Same lattice projected onto a torus. Drag to rotate. Warm tones indicate hotter TPU dies.</p>
          <canvas id="torus-canvas"></canvas>
        </div>
      </div>

      <div class="metrics-panel">
        <div class="metric-group card">
          <h3>☌ Network Metrics</h3>
          <div class="metric-row">
            <span class="metric-label">Topology:</span>
            <span class="metric-value" id="metric-topology">Torus 8×8</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Twist Offset:</span>
            <span class="metric-value" id="metric-twist">0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Total Nodes:</span>
            <span class="metric-value" id="metric-nodes">64</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Neighbors/Node:</span>
            <span class="metric-value" id="metric-degree">4</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Active / Total BW:</span>
            <span class="metric-value" id="metric-bandwidth">0.0 / 0.0 Tbps</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Avg Latency:</span>
            <span class="metric-value" id="metric-latency">0.0 hops</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Link Utilization:</span>
            <span class="metric-value" id="metric-utilization">0%</span>
          </div>
        </div>

        <div class="metric-group card">
          <h3>♛ TPU Metrics</h3>
          <div class="metric-row">
            <span class="metric-label">Active Nodes:</span>
            <span class="metric-value" id="metric-active">0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Total FLOPS:</span>
            <span class="metric-value" id="metric-flops">0.0 PFLOP/s</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Power Draw:</span>
            <span class="metric-value" id="metric-power">0.0 kW</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Avg Temperature:</span>
            <span class="metric-value" id="metric-temp">25°C</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Energy Efficiency:</span>
            <span class="metric-value" id="metric-efficiency">0 GFLOPS/W</span>
          </div>
        </div>

        <div class="metric-group card">
          <h3>☰ Simulation Stats</h3>
          <div class="metric-row">
            <span class="metric-label">Generation:</span>
            <span class="metric-value" id="metric-generation">0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Activity:</span>
            <span class="metric-value" id="metric-activity">0.0%</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">FPS:</span>
            <span class="metric-value" id="metric-fps">60</span>
          </div>
        </div>
      </div>
    </div>

    <div class="controls panel">
      <h3>☈️ Controls</h3>
      <div class="control-row">
        <div class="control-group">
          <label>Grid Size: <span class="value-display" id="gridSizeValue">8</span></label>
          <input type="range" id="gridSize" min="4" max="16" value="8" step="2">
        </div>
        <div class="control-group">
          <label>Twist Offset: <span class="value-display" id="twistValue">0</span> columns</label>
          <input type="range" id="twist" min="0" max="7" value="0">
        </div>
        <div class="control-group">
          <label>Update Speed: <span class="value-display" id="speedValue">5</span> fps</label>
          <input type="range" id="speed" min="1" max="30" value="5">
        </div>
      </div>
      <div class="control-row">
        <div class="control-group">
          <label>Traffic Rate: <span class="value-display" id="trafficValue">10</span> packets/sec</label>
          <input type="range" id="traffic" min="0" max="120" value="10" step="5">
        </div>
        <div class="control-group">
          <label>Chip TFLOPS: <span class="value-display" id="tflopsValue">275</span> TFLOP/s</label>
          <input type="range" id="tflops" min="50" max="500" value="275" step="25">
        </div>
        <div class="control-group">
          <label>Chip Power: <span class="value-display" id="powerValue">175</span> W</label>
          <input type="range" id="power" min="50" max="400" value="175" step="25">
        </div>
      </div>
      <div class="control-row">
        <button class="btn btn-primary" id="randomize">⚄ Randomize</button>
        <button class="btn btn-outline" id="clear">✗ Clear All</button>
        <button class="btn btn-secondary" id="toggleAuto">☊ Start Auto-Update</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      'use strict';

      const TWO_PI = Math.PI * 2;
      const SIM = { LIFE: 'gameoflife', BANDWIDTH: 'bandwidth' };
      const VIEWS = { GRID: 'grid', TORUS: 'torus' };

      const gridCanvas = document.getElementById('grid-canvas');
      const gridCtx = gridCanvas.getContext('2d', { alpha: false });
      const torusCanvas = document.getElementById('torus-canvas');
      const torusCtx = torusCanvas.getContext('2d', { alpha: false });

      const simButtons = document.querySelectorAll('[data-sim]');
      const modeDescriptionEl = document.getElementById('mode-description');

      const gridSizeSlider = document.getElementById('gridSize');
      const twistSlider = document.getElementById('twist');
      const speedSlider = document.getElementById('speed');
      const trafficSlider = document.getElementById('traffic');
      const tflopsSlider = document.getElementById('tflops');
      const powerSlider = document.getElementById('power');
      const randomizeBtn = document.getElementById('randomize');
      const clearBtn = document.getElementById('clear');
      const toggleAutoBtn = document.getElementById('toggleAuto');

      const metricEls = {
        topology: document.getElementById('metric-topology'),
        twist: document.getElementById('metric-twist'),
        nodes: document.getElementById('metric-nodes'),
        degree: document.getElementById('metric-degree'),
        bandwidth: document.getElementById('metric-bandwidth'),
        latency: document.getElementById('metric-latency'),
        utilization: document.getElementById('metric-utilization'),
        active: document.getElementById('metric-active'),
        flops: document.getElementById('metric-flops'),
        power: document.getElementById('metric-power'),
        temp: document.getElementById('metric-temp'),
        efficiency: document.getElementById('metric-efficiency'),
        generation: document.getElementById('metric-generation'),
        activity: document.getElementById('metric-activity'),
        fps: document.getElementById('metric-fps'),
      };

      const state = {
        simulationMode: SIM.BANDWIDTH,
        view: VIEWS.GRID,
        gridSize: 8,
        twist: 0,
        grid: [],
        heat: [],
        edgeLoad: new Map(),
        maxEdgeLoad: 1,
        autoUpdate: false,
        generation: 0,
        packets: [],
        packetAccumulator: 0,
        chipTFLOPS: 275,
        chipPower: 175,
        trafficRate: 10,
        needsRenderGrid: true,
        needsRenderTorus: true,
        needsRender: true,
        rotationX: -0.5,
        rotationY: 0.6,
        isDragging: false,
        lastMouseX: 0,
        lastMouseY: 0,
        lastFrameTime: performance.now(),
        fpsSample: performance.now(),
        lastFps: 60,
        birthRule: [3],
        survivalRule: [2, 3],
        linkBandwidthGbps: 19.2,
      };

      function createGrid(size, fill = 0) {
        return Array.from({ length: size }, () => Array(size).fill(fill));
      }

      function mod(n, size) {
        return ((n % size) + size) % size;
      }

      function wrapMove(x, y, dx, dy) {
        const size = state.gridSize;
        let nx = x + dx;
        let ny = y + dy;
        const twist = state.twist % size;

        if (nx < 0) {
          nx = size - 1;
          ny = mod(ny - twist, size);
        } else if (nx >= size) {
          nx = 0;
          ny = mod(ny + twist, size);
        }

        if (ny < 0) {
          ny = size - 1;
          nx = mod(nx - twist, size);
        } else if (ny >= size) {
          ny = 0;
          nx = mod(nx + twist, size);
        }

        return [nx, ny];
      }

      function ensureHeatGrid() {
        if (!state.heat || state.heat.length !== state.gridSize) {
          state.heat = createGrid(state.gridSize, 0);
        }
      }

      const makeEdgeKey = (x1, y1, x2, y2) => {
        if (x1 < x2 || (x1 === x2 && y1 <= y2)) {
          return `${x1},${y1}-${x2},${y2}`;
        }
        return `${x2},${y2}-${x1},${y1}`;
      };

      const getEdgeLoad = (x1, y1, x2, y2) => {
        if (!state.edgeLoad) return 0;
        return state.edgeLoad.get(makeEdgeKey(x1, y1, x2, y2)) || 0;
      };

      function seedLifePattern() {
        const size = state.gridSize;
        if (size < 5) {
          for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
              state.grid[y][x] = Math.random() > 0.65 ? 1 : 0;
            }
          }
          return;
        }

        const mid = Math.floor(size / 2);
        const glider = [
          [1, 0],
          [2, 1],
          [0, 2],
          [1, 2],
          [2, 2],
        ];
        const blinker = [
          [-1, 2],
          [0, 2],
          [1, 2],
        ];

        const anchorX = Math.max(1, mid - 2);
        const anchorY = Math.max(1, mid - 2);
        glider.forEach(([dx, dy]) => {
          const x = mod(anchorX + dx, size);
          const y = mod(anchorY + dy, size);
          state.grid[y][x] = 1;
        });

        blinker.forEach(([dx, dy]) => {
          const x = mod(mid + dx, size);
          const y = mod(mid + dy, size);
          state.grid[y][x] = 1;
        });
      }

      function updateHeatMap(occupancy) {
        ensureHeatGrid();
        const size = state.gridSize;
        const nextHeat = createGrid(size, 0);

        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const activeLoad = occupancy[y][x];
            const currentHeat = state.heat[y][x];
            const neighbors = getNeighbors(x, y);
            let neighborAccum = 0;
            neighbors.forEach(([nx, ny]) => {
              neighborAccum += state.heat[ny][nx];
            });
            const neighborAvg = neighborAccum / neighbors.length;
            let heat = currentHeat * 0.82 + neighborAvg * 0.12;
            if (activeLoad > 0) {
              heat += Math.min(25, 6 * activeLoad);
            } else {
              heat *= 0.96;
            }
            nextHeat[y][x] = Math.min(100, heat);
          }
        }

        state.heat = nextHeat;
      }

      function seedBandwidthState() {
        const size = state.gridSize;
        ensureHeatGrid();
        state.grid = createGrid(size, 0);
        state.packets = [];
        state.edgeLoad = new Map();
        state.maxEdgeLoad = 1;
        const hotspots = Math.max(3, Math.round(size * size * 0.12));
        const used = new Set();

        const addPacket = (x, y) => {
          let destX = (x + Math.floor(Math.random() * size / 2) + 1) % size;
          let destY = (y + Math.floor(Math.random() * size / 2) + 1) % size;
          if (destX === x && destY === y) {
            destX = (destX + 1) % size;
          }
          state.packets.push({
            x,
            y,
            destX,
            destY,
            hops: 0,
            maxHops: size * size * 2,
          });
        };

        for (let i = 0; i < hotspots; i++) {
          let x = 0;
          let y = 0;
          let key = '';
          do {
            x = Math.floor(Math.random() * size);
            y = Math.floor(Math.random() * size);
            key = `${x},${y}`;
          } while (used.has(key));
          used.add(key);
          state.grid[y][x] = 1 + Math.floor(Math.random() * 2);
          state.heat[y][x] = 45 + Math.random() * 15;
          addPacket(x, y);
        }

        for (let i = 0; i < hotspots; i++) {
          const x = Math.floor(Math.random() * size);
          const y = Math.floor(Math.random() * size);
          addPacket(x, y);
        }

        // Smooth initial heat map
        updateHeatMap(state.grid);
        updateHeatMap(state.grid);

        state.packetAccumulator = 0;
      }

      function seedInitialState() {
        if (state.simulationMode === SIM.BANDWIDTH) {
          seedBandwidthState();
        } else {
          seedLifePattern();
          state.heat = createGrid(state.gridSize, 0);
          state.edgeLoad = new Map();
          state.maxEdgeLoad = 1;
        }
      }

      function getNeighbors(x, y) {
        return [
          wrapMove(x, y, 1, 0),
          wrapMove(x, y, -1, 0),
          wrapMove(x, y, 0, 1),
          wrapMove(x, y, 0, -1),
        ];
      }

      function initGrid() {
        state.grid = createGrid(state.gridSize, 0);
        state.heat = createGrid(state.gridSize, 0);
        state.packets = [];
        state.packetAccumulator = 0;
        state.generation = 0;
        seedInitialState();
        updateMetrics();
        state.needsRender = true;
      }

      function updateGameOfLife() {
        const size = state.gridSize;
        const next = createGrid(size, 0);
        state.edgeLoad = new Map();
        state.maxEdgeLoad = 1;
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const alive = state.grid[y][x] > 0 ? 1 : 0;
            const neighbors = getNeighbors(x, y).reduce((sum, [nx, ny]) => sum + (state.grid[ny][nx] > 0 ? 1 : 0), 0);
            next[y][x] = alive
              ? (state.survivalRule.includes(neighbors) ? 1 : 0)
              : (state.birthRule.includes(neighbors) ? 1 : 0);
          }
        }
        state.grid = next;
        state.generation++;
        updateMetrics();
        state.needsRender = true;
      }

      function spawnTrafficPackets(deltaSeconds) {
        state.packetAccumulator += state.trafficRate * deltaSeconds;
        const target = Math.floor(state.packetAccumulator);
        state.packetAccumulator -= target;
        for (let i = 0; i < target; i++) {
          const size = state.gridSize;
          let srcX = Math.floor(Math.random() * size);
          let srcY = Math.floor(Math.random() * size);
          let dstX = Math.floor(Math.random() * size);
          let dstY = Math.floor(Math.random() * size);
          if (srcX === dstX && srcY === dstY) {
            dstX = (dstX + 1) % size;
          }
          state.packets.push({
            x: srcX,
            y: srcY,
            destX: dstX,
            destY: dstY,
            hops: 0,
            maxHops: size * size * 2,
          });
        }
      }

      function computeNextHop(packet) {
        if (packet.x === packet.destX && packet.y === packet.destY) return null;
        const size = state.gridSize;
        const startKey = `${packet.x},${packet.y}`;
        const destKey = `${packet.destX},${packet.destY}`;
        const queue = [[packet.x, packet.y]];
        const visited = new Set([startKey]);
        const prev = new Map();
        let found = false;

        while (queue.length && !found) {
          const [cx, cy] = queue.shift();
          for (const [nx, ny] of getNeighbors(cx, cy)) {
            const key = `${nx},${ny}`;
            if (visited.has(key)) continue;
            visited.add(key);
            prev.set(key, `${cx},${cy}`);
            if (key === destKey) {
              found = true;
              break;
            }
            queue.push([nx, ny]);
          }
        }

        if (!visited.has(destKey)) return null;
        let stepKey = destKey;
        let parent = prev.get(stepKey);
        while (parent && parent !== startKey) {
          stepKey = parent;
          parent = prev.get(stepKey);
        }
        const [nx, ny] = stepKey.split(',').map(Number);
        return [nx, ny];
      }

      function updateBandwidthSimulation(deltaSeconds) {
        const size = state.gridSize;
        spawnTrafficPackets(deltaSeconds);
        const nextPackets = [];
        const occupancy = createGrid(size, 0);
        state.edgeLoad = new Map();
        let maxEdgeLoad = 1;

        for (const packet of state.packets) {
          occupancy[packet.y][packet.x] += 1;
          if (packet.x === packet.destX && packet.y === packet.destY) {
            continue;
          }
          const prevX = packet.x;
          const prevY = packet.y;
          const nextHop = computeNextHop(packet);
          if (!nextHop) continue;
          packet.x = nextHop[0];
          packet.y = nextHop[1];
          packet.hops++;
          if (packet.hops <= packet.maxHops) {
            nextPackets.push(packet);
            occupancy[packet.y][packet.x] += 1;
            const key = makeEdgeKey(prevX, prevY, packet.x, packet.y);
            const updated = (state.edgeLoad.get(key) || 0) + 1;
            state.edgeLoad.set(key, updated);
            if (updated > maxEdgeLoad) maxEdgeLoad = updated;
          }
        }

        state.packets = nextPackets;
        state.grid = occupancy;
        state.maxEdgeLoad = Math.max(1, maxEdgeLoad);
        updateHeatMap(state.grid);
        state.generation++;
        updateMetrics();
        state.needsRender = true;
      }

      function updateMetrics() {
        const size = state.gridSize;
        const totalNodes = size * size;
        let activeNodes = 0;
        let totalHeat = 0;

        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const value = state.grid[y][x];
            const heatValue = (state.heat && state.heat[y]) ? state.heat[y][x] : 0;
            if (state.simulationMode === SIM.BANDWIDTH) {
              if (value > 0 || heatValue > 6) activeNodes++;
              totalHeat += heatValue;
            } else if (value > 0) {
              activeNodes++;
            }
          }
        }

        const degree = 4;
        // Average Manhattan distance in 2D torus is approximately 2/3 of grid size
        const avgLatency = (size * 0.67).toFixed(1);
        const totalCapacityTbps = totalNodes * degree * state.linkBandwidthGbps / 2000;
        let activeBandwidthTbps = 0;
        if (state.simulationMode === SIM.BANDWIDTH && state.edgeLoad) {
          let traversals = 0;
          state.edgeLoad.forEach((value) => {
            traversals += value;
          });
          activeBandwidthTbps = (traversals * state.linkBandwidthGbps) / 1000;
        }
        const utilization = (activeNodes / totalNodes) * 100;

        const totalFlops = activeNodes * state.chipTFLOPS;
        const totalPower = activeNodes * state.chipPower;
        const avgTemp = state.simulationMode === SIM.BANDWIDTH
          ? 25 + (totalHeat / totalNodes) * 0.35
          : 25 + (activeNodes / totalNodes) * 45;
        const efficiency = totalPower > 0 ? (totalFlops * 1000 / totalPower) : 0;

        metricEls.topology.textContent = `Torus ${size}×${size}`;
        metricEls.twist.textContent = state.twist;
        metricEls.nodes.textContent = totalNodes;
        metricEls.degree.textContent = degree;
        if (state.simulationMode === SIM.BANDWIDTH) {
          metricEls.bandwidth.textContent = `${activeBandwidthTbps.toFixed(2)} / ${totalCapacityTbps.toFixed(1)} Tbps`;
        } else {
          metricEls.bandwidth.textContent = `0.0 / ${totalCapacityTbps.toFixed(1)} Tbps`;
        }
        metricEls.latency.textContent = `${avgLatency} hops`;
        metricEls.utilization.textContent = `${utilization.toFixed(1)}%`;
        metricEls.active.textContent = activeNodes;
        metricEls.flops.textContent = `${(totalFlops / 1000).toFixed(2)} PFLOP/s`;
        metricEls.power.textContent = `${(totalPower / 1000).toFixed(2)} kW`;
        metricEls.temp.textContent = `${Math.round(avgTemp)}°C`;
        metricEls.efficiency.textContent = `${Math.round(efficiency)} GFLOPS/W`;
        metricEls.generation.textContent = state.generation;
        metricEls.activity.textContent = `${((activeNodes / totalNodes) * 100).toFixed(1)}%`;

        metricEls.utilization.className = 'metric-value';
        if (utilization > 70) metricEls.utilization.classList.add('critical');
        else if (utilization > 40) metricEls.utilization.classList.add('warning');

        metricEls.temp.className = 'metric-value';
        if (avgTemp > 80) metricEls.temp.classList.add('critical');
        else if (avgTemp > 60) metricEls.temp.classList.add('warning');
      }

      function updateModeDescription() {
        const descriptions = {
          [SIM.LIFE]: '<strong>Game of Life:</strong> classic Conway dynamics on a toroidal grid. Wrap-around edges keep patterns alive while twists shear the neighborhoods.',
          [SIM.BANDWIDTH]: '<strong>Bandwidth Traffic &amp; Heat:</strong> dimension-order routing with wrap links. Node color shows accumulated die heat while strokes track active TPUs carrying packets.'
        };
        modeDescriptionEl.innerHTML = descriptions[state.simulationMode];
      }

      function updateViewText() {
        // Dual view - no longer needed but keeping for compatibility
        torusCanvas.style.cursor = state.isDragging ? 'grabbing' : 'grab';
      }

      function getGridLayout() {
        const rect = gridCanvas.getBoundingClientRect();
        const logicalWidth = rect.width;
        const logicalHeight = rect.height;
        const size = state.gridSize;
        const margin = 1.4;
        const cellSize = Math.min(logicalWidth, logicalHeight) / (size + margin);
        const gridWidth = cellSize * size;
        const gridHeight = cellSize * size;
        const offsetX = (logicalWidth - gridWidth) / 2;
        const offsetY = (logicalHeight - gridHeight) / 2;
        return { cellSize, offsetX, offsetY };
      }

      function renderGridView() {
        const size = state.gridSize;
        const { cellSize, offsetX, offsetY } = getGridLayout();
        const logicalRect = gridCanvas.getBoundingClientRect();
        gridCtx.fillStyle = '#050505';
        gridCtx.fillRect(0, 0, logicalRect.width, logicalRect.height);

        // Draw all edges including wrap-around connections
        gridCtx.lineWidth = 1.5;
        const gridWidth = cellSize * size;
        const gridHeight = cellSize * size;
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const cx = offsetX + x * cellSize + cellSize / 2;
            const cy = offsetY + y * cellSize + cellSize / 2;

            const neighbors = [
              { dir: [1, 0], next: wrapMove(x, y, 1, 0) },
              { dir: [0, 1], next: wrapMove(x, y, 0, 1) },
              { dir: [-1, 0], next: wrapMove(x, y, -1, 0) },
              { dir: [0, -1], next: wrapMove(x, y, 0, -1) }
            ];

            neighbors.forEach(({ dir, next }) => {
              const [nx, ny] = next;
              const tcx = offsetX + nx * cellSize + cellSize / 2;
              const tcy = offsetY + ny * cellSize + cellSize / 2;
              const rawX = x + dir[0];
              const rawY = y + dir[1];
              const isWrap = rawX < 0 || rawX >= size || rawY < 0 || rawY >= size;
              const load = getEdgeLoad(x, y, nx, ny);
              const intensity = state.maxEdgeLoad > 0 ? Math.min(1, load / state.maxEdgeLoad) : 0;
              const hasLoad = intensity > 0.02;
              const baseColor = isWrap ? (state.twist > 0 ? '#4a5c88' : '#3a4c78') : '#1f1f1f';
              const strokeColor = hasLoad
                ? `rgba(255, 0, 255, ${0.25 + 0.55 * intensity})`
                : baseColor;
              const baseWidth = isWrap ? 1.15 : 0.85;
              const lineWidth = hasLoad ? baseWidth + 1.35 * intensity : baseWidth;

              if (dir[0] === 1 || dir[1] === 1) {
                gridCtx.strokeStyle = strokeColor;
                gridCtx.lineWidth = lineWidth;
                gridCtx.beginPath();
                gridCtx.moveTo(cx, cy);
                if (isWrap) {
                  if (dir[0] !== 0) {
                    const viaTop = y < size / 2;
                    const controlY = viaTop ? offsetY - cellSize * 1.2 : offsetY + gridHeight + cellSize * 1.2;
                    const offsetXOuter = cellSize * 1.6;
                    const ctrl1X = cx + (dir[0] > 0 ? offsetXOuter : -offsetXOuter);
                    const ctrl2X = tcx + (dir[0] > 0 ? offsetXOuter : -offsetXOuter);
                    gridCtx.bezierCurveTo(ctrl1X, controlY, ctrl2X, controlY, tcx, tcy);
                  } else {
                    const viaRight = x < size / 2;
                    const controlX = viaRight ? offsetX - cellSize * 1.2 : offsetX + gridWidth + cellSize * 1.2;
                    const offsetYOuter = cellSize * 1.6;
                    const ctrl1Y = cy + (dir[1] > 0 ? offsetYOuter : -offsetYOuter);
                    const ctrl2Y = tcy + (dir[1] > 0 ? offsetYOuter : -offsetYOuter);
                    gridCtx.bezierCurveTo(controlX, ctrl1Y, controlX, ctrl2Y, tcx, tcy);
                  }
                } else {
                  gridCtx.strokeStyle = '#1f1f1f';
                  gridCtx.lineTo(tcx, tcy);
                }
                gridCtx.stroke();
              }
            });
          }
        }
        gridCtx.lineWidth = 1;

        // Draw nodes on top
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const value = state.grid[y][x];
            const cx = offsetX + x * cellSize + cellSize / 2;
            const cy = offsetY + y * cellSize + cellSize / 2;
            const radius = Math.max(3, cellSize * 0.18);
            gridCtx.beginPath();
            const heatValue = (state.heat && state.heat[y]) ? state.heat[y][x] : 0;
            const heat = Math.min(1, heatValue / 100);
            const active = value > 0 || (state.simulationMode === SIM.BANDWIDTH && heatValue > 6);
            if (state.simulationMode === SIM.BANDWIDTH) {
              const r = Math.floor(30 + heat * 210);
              const g = Math.floor(50 + heat * 110);
              const b = Math.floor(70 - heat * 40);
              gridCtx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.92)`;
              gridCtx.strokeStyle = active ? '#a8fba8' : '#2a2a2a';
              gridCtx.lineWidth = active ? 2 : 1.4;
            } else if (value > 0) {
              gridCtx.fillStyle = '#66bb66';
              gridCtx.strokeStyle = '#a8fba8';
              gridCtx.lineWidth = 2;
            } else {
              gridCtx.fillStyle = '#0c0c0c';
              gridCtx.strokeStyle = '#2a2a2a';
              gridCtx.lineWidth = 1.6;
            }
            gridCtx.arc(cx, cy, radius, 0, TWO_PI);
            gridCtx.fill();
            gridCtx.stroke();
          }
        }
      }

      function renderTorusView() {
        const rect = torusCanvas.getBoundingClientRect();
        const logicalWidth = rect.width;
        const logicalHeight = rect.height;
        const size = state.gridSize;
        const centerX = logicalWidth / 2;
        const centerY = logicalHeight / 2;
        const base = Math.min(logicalWidth, logicalHeight);
        const majorRadius = base * 0.32;
        const minorRadius = base * 0.16;
        const twistFactor = size > 0 ? state.twist / size : 0;

        torusCtx.fillStyle = '#050505';
        torusCtx.fillRect(0, 0, logicalWidth, logicalHeight);

        const cosX = Math.cos(state.rotationX);
        const sinX = Math.sin(state.rotationX);
        const cosY = Math.cos(state.rotationY);
        const sinY = Math.sin(state.rotationY);

        const pointMap = new Map();
        const points = [];

        const projectAngles = (theta, phi) => {
          const u = theta + twistFactor * phi;
          const v = phi;

          const cosV = Math.cos(v);
          const sinV = Math.sin(v);
          const cosU = Math.cos(u);
          const sinU = Math.sin(u);

          const px = (majorRadius + minorRadius * cosV) * cosU;
          const py = (majorRadius + minorRadius * cosV) * sinU;
          const pz = minorRadius * sinV;

          const ry = py * cosX - pz * sinX;
          const rz = py * sinX + pz * cosX;
          const rx = px * cosY + rz * sinY;
          const rz2 = -px * sinY + rz * cosY;

          const perspective = 450 / (450 + rz2 + 120);
          return {
            screenX: centerX + rx * perspective,
            screenY: centerY + ry * perspective,
            depth: rz2,
            scale: perspective,
          };
        };

        const drawTorusMesh = () => {
          const ringSteps = 72;
          const tubeSteps = 36;
          const frontColorMajor = 'rgba(90, 110, 185, 0.38)';
          const backColorMajor = 'rgba(40, 50, 80, 0.14)';
          const frontColorMinor = 'rgba(80, 105, 175, 0.32)';
          const backColorMinor = 'rgba(35, 45, 70, 0.12)';

          torusCtx.save();
          torusCtx.lineWidth = 0.7;

          for (let j = 0; j < tubeSteps; j++) {
            const phi = (j / tubeSteps) * TWO_PI;
            let prev = projectAngles(0, phi);
            for (let i = 1; i <= ringSteps; i++) {
              const theta = (i / ringSteps) * TWO_PI;
              const current = projectAngles(theta, phi);
              const front = (prev.depth + current.depth) * 0.5 > 0;
              torusCtx.strokeStyle = front ? frontColorMajor : backColorMajor;
              torusCtx.beginPath();
              torusCtx.moveTo(prev.screenX, prev.screenY);
              torusCtx.lineTo(current.screenX, current.screenY);
              torusCtx.stroke();
              prev = current;
            }
          }

          for (let i = 0; i < ringSteps; i++) {
            const theta = (i / ringSteps) * TWO_PI;
            let prev = projectAngles(theta, 0);
            for (let j = 1; j <= tubeSteps; j++) {
              const phi = (j / tubeSteps) * TWO_PI;
              const current = projectAngles(theta, phi);
              const front = (prev.depth + current.depth) * 0.5 > 0;
              torusCtx.strokeStyle = front ? frontColorMinor : backColorMinor;
              torusCtx.beginPath();
              torusCtx.moveTo(prev.screenX, prev.screenY);
              torusCtx.lineTo(current.screenX, current.screenY);
              torusCtx.stroke();
              prev = current;
            }
          }

          torusCtx.restore();
        };

        drawTorusMesh();

        // Generate points on torus surface
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const theta = (x / size) * TWO_PI;
            const phi = (y / size) * TWO_PI;
            const projected = projectAngles(theta, phi);
            const point = {
              x,
              y,
              value: state.grid[y][x],
              heat: state.heat && state.heat[y] ? state.heat[y][x] : 0,
              screenX: projected.screenX,
              screenY: projected.screenY,
              depth: projected.depth,
              scale: projected.scale,
            };
            points.push(point);
            pointMap.set(`${x},${y}`, point);
          }
        }

        // Generate ALL edge connections (fully connected torus mesh)
        const connections = [];
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const hereKey = `${x},${y}`;

            // Get all 4 neighbors to show full mesh with direction metadata
            const neighbors = [
              { dir: [1, 0], next: wrapMove(x, y, 1, 0) },
              { dir: [0, 1], next: wrapMove(x, y, 0, 1) },
              { dir: [-1, 0], next: wrapMove(x, y, -1, 0) },
              { dir: [0, -1], next: wrapMove(x, y, 0, -1) },
            ];

            neighbors.forEach(({ dir, next }) => {
              const [nx, ny] = next;
              const neighborKey = `${nx},${ny}`;
              if (hereKey < neighborKey) {
                connections.push([hereKey, neighborKey, x, y, nx, ny, dir[0], dir[1]]);
              }
            });
          }
        }

        // Draw all connections

        const shortestAngle = (from, to) => {
          let diff = to - from;
          if (diff > Math.PI) diff -= TWO_PI;
          else if (diff < -Math.PI) diff += TWO_PI;
          return diff;
        };

        for (const [, , x, y, nx, ny, dx, dy] of connections) {
          const rawX = x + dx;
          const rawY = y + dy;
          const isWrap = rawX < 0 || rawX >= size || rawY < 0 || rawY >= size;
          const load = getEdgeLoad(x, y, nx, ny);
          const intensity = state.maxEdgeLoad > 0 ? Math.min(1, load / state.maxEdgeLoad) : 0;
          const hasLoad = intensity > 0.02;
          const baseFront = isWrap ? '#3a4c88' : '#202030';
          const baseBack = isWrap ? '#262f55' : '#171722';
          const frontColor = hasLoad
            ? `rgba(255, 0, 255, ${0.2 + 0.55 * intensity})`
            : baseFront;
          const backColor = hasLoad
            ? `rgba(190, 0, 255, ${0.12 + 0.35 * intensity})`
            : baseBack;
          const baseWidth = isWrap ? 2.6 : 2.0;
          const segmentWidth = hasLoad ? baseWidth + 1.45 * intensity : baseWidth;

          const theta0 = (x / size) * TWO_PI;
          const phi0 = (y / size) * TWO_PI;
          const theta1 = (nx / size) * TWO_PI;
          const phi1 = (ny / size) * TWO_PI;

          const dTheta = shortestAngle(theta0, theta1);
          const dPhi = shortestAngle(phi0, phi1);

          const segments = isWrap ? 28 : 16;
          let prev = projectAngles(theta0, phi0);

          for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            const theta = theta0 + dTheta * t;
            const phi = phi0 + dPhi * t;
            const current = projectAngles(theta, phi);
            const front = (prev.depth + current.depth) * 0.5 > 0;
            torusCtx.strokeStyle = front ? frontColor : backColor;
            torusCtx.lineWidth = segmentWidth;
            torusCtx.beginPath();
            torusCtx.moveTo(prev.screenX, prev.screenY);
            torusCtx.lineTo(current.screenX, current.screenY);
            torusCtx.stroke();
            prev = current;
          }
        }

        // Draw nodes on top sorted by depth
        points.sort((p1, p2) => p1.depth - p2.depth);
        for (const point of points) {
          const radius = Math.max(3, 6 * point.scale);
          torusCtx.beginPath();
          const heatValue = point.heat || 0;
          const heat = Math.min(1, heatValue / 100);
          const active = point.value > 0 || (state.simulationMode === SIM.BANDWIDTH && heatValue > 6);
          if (state.simulationMode === SIM.BANDWIDTH) {
            const r = Math.floor(35 + heat * 205);
            const g = Math.floor(60 + heat * 110);
            const b = Math.floor(75 - heat * 45);
            torusCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.7 + heat * 0.25})`;
            torusCtx.strokeStyle = active ? '#c9ffca' : '#2a2a30';
            torusCtx.lineWidth = active ? 1.4 : 1;
          } else if (point.value > 0) {
            torusCtx.fillStyle = '#66bb66';
            torusCtx.strokeStyle = '#c9ffca';
            torusCtx.lineWidth = 1.4;
          } else {
            torusCtx.fillStyle = '#0f0f10';
            torusCtx.strokeStyle = '#2a2a30';
            torusCtx.lineWidth = 1;
          }
          torusCtx.arc(point.screenX, point.screenY, radius, 0, TWO_PI);
          torusCtx.fill();
          torusCtx.stroke();
        }
      }

      function renderFrame() {
        // Render both views since they're displayed side-by-side
        if (state.needsRenderGrid) {
          renderGridView();
          state.needsRenderGrid = false;
        }
        if (state.needsRenderTorus) {
          renderTorusView();
          state.needsRenderTorus = false;
        }
        state.needsRender = false;
      }

      function animate(now) {
        const deltaMs = now - state.lastFrameTime;
        const deltaSeconds = deltaMs / 1000;
        const fpsTarget = parseInt(speedSlider.value, 10) || 5;
        const interval = 1000 / fpsTarget;

        if (state.autoUpdate && deltaMs >= interval) {
          if (state.simulationMode === SIM.LIFE) updateGameOfLife();
          else updateBandwidthSimulation(deltaSeconds);
          state.lastFrameTime = now;
          state.needsRenderGrid = true;
          state.needsRenderTorus = true;
        }

        if (now - state.fpsSample >= 250) {
          state.lastFps = Math.round(1000 / Math.max(1, deltaMs));
          metricEls.fps.textContent = state.lastFps;
          state.fpsSample = now;
        }

        renderFrame();
        requestAnimationFrame(animate);
      }

      function handleGridPointer(evt) {
        const rect = gridCanvas.getBoundingClientRect();
        const scaleX = gridCanvas.width / rect.width;
        const scaleY = gridCanvas.height / rect.height;
        const mouseX = (evt.clientX - rect.left) * scaleX;
        const mouseY = (evt.clientY - rect.top) * scaleY;
        const { cellSize, offsetX, offsetY } = getGridLayout();
        const x = Math.floor((mouseX - offsetX) / cellSize);
        const y = Math.floor((mouseY - offsetY) / cellSize);
        if (x < 0 || y < 0 || x >= state.gridSize || y >= state.gridSize) return;

        if (state.simulationMode === SIM.BANDWIDTH) {
          state.grid[y][x] = state.grid[y][x] > 0 ? 0 : 1;
          ensureHeatGrid();
          if (state.grid[y][x] > 0) {
            state.heat[y][x] = Math.min(100, state.heat[y][x] + 25);
          }
          updateHeatMap(state.grid);
        } else {
          state.grid[y][x] = state.grid[y][x] > 0 ? 0 : 1;
        }
        updateMetrics();
        state.needsRenderGrid = true;
        state.needsRenderTorus = true;
      }

      function setActiveButton(buttons, attribute, value) {
        buttons.forEach(btn => {
          if (btn.getAttribute(attribute) === value) btn.classList.add('active');
          else btn.classList.remove('active');
        });
      }

      function updateTwistControlRange() {
        const maxTwist = Math.max(0, state.gridSize - 1);
        twistSlider.max = String(maxTwist);
        if (state.twist > maxTwist) state.twist = maxTwist;
        twistSlider.value = state.twist;
        document.getElementById('twistValue').textContent = state.twist;
      }

      function bindControls() {
        simButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const mode = btn.getAttribute('data-sim');
            if (mode === state.simulationMode) return;
            state.simulationMode = mode;
            setActiveButton(simButtons, 'data-sim', state.simulationMode);
            updateModeDescription();
            initGrid();
            state.needsRenderGrid = true;
            state.needsRenderTorus = true;
          });
        });

        gridSizeSlider.addEventListener('input', (e) => {
          state.gridSize = parseInt(e.target.value, 10) || 8;
          document.getElementById('gridSizeValue').textContent = state.gridSize;
          updateTwistControlRange();
          initGrid();
        });

        twistSlider.addEventListener('input', (e) => {
          state.twist = parseInt(e.target.value, 10) || 0;
          document.getElementById('twistValue').textContent = state.twist;
          updateMetrics();
          state.needsRenderGrid = true;
          state.needsRenderTorus = true;
        });

        speedSlider.addEventListener('input', (e) => {
          document.getElementById('speedValue').textContent = e.target.value;
        });

        trafficSlider.addEventListener('input', (e) => {
          state.trafficRate = parseInt(e.target.value, 10) || 0;
          document.getElementById('trafficValue').textContent = state.trafficRate;
        });

        tflopsSlider.addEventListener('input', (e) => {
          state.chipTFLOPS = parseInt(e.target.value, 10) || state.chipTFLOPS;
          document.getElementById('tflopsValue').textContent = state.chipTFLOPS;
          updateMetrics();
        });

        powerSlider.addEventListener('input', (e) => {
          state.chipPower = parseInt(e.target.value, 10) || state.chipPower;
          document.getElementById('powerValue').textContent = state.chipPower;
          updateMetrics();
        });

        randomizeBtn.addEventListener('click', () => {
          const size = state.gridSize;
          if (state.simulationMode === SIM.BANDWIDTH) {
            seedBandwidthState();
          } else {
            state.grid = createGrid(size, 0);
            for (let y = 0; y < size; y++) {
              for (let x = 0; x < size; x++) {
                state.grid[y][x] = Math.random() > 0.7 ? 1 : 0;
              }
            }
            state.heat = createGrid(size, 0);
            state.packets = [];
            state.edgeLoad = new Map();
            state.maxEdgeLoad = 1;
          }
          state.generation = 0;
          updateMetrics();
          state.needsRenderGrid = true;
          state.needsRenderTorus = true;
        });

        clearBtn.addEventListener('click', () => {
          initGrid();
          state.needsRenderGrid = true;
          state.needsRenderTorus = true;
        });

        toggleAutoBtn.addEventListener('click', () => {
          state.autoUpdate = !state.autoUpdate;
          toggleAutoBtn.textContent = state.autoUpdate ? '☋ Stop Auto-Update' : '☊ Start Auto-Update';
        });

        gridCanvas.addEventListener('mousedown', (evt) => {
          handleGridPointer(evt);
        });

        torusCanvas.addEventListener('mousedown', (evt) => {
          state.isDragging = true;
          state.lastMouseX = evt.clientX;
          state.lastMouseY = evt.clientY;
          updateViewText();
        });

        torusCanvas.addEventListener('mousemove', (evt) => {
          if (state.isDragging) {
            const deltaX = evt.clientX - state.lastMouseX;
            const deltaY = evt.clientY - state.lastMouseY;
            state.rotationY += deltaX * 0.01;
            state.rotationX += deltaY * 0.01;
            state.lastMouseX = evt.clientX;
            state.lastMouseY = evt.clientY;
            state.needsRenderTorus = true;
          }
        });

        const stopDragging = () => {
          if (state.isDragging) {
            state.isDragging = false;
            updateViewText();
          }
        };

        torusCanvas.addEventListener('mouseup', stopDragging);
        torusCanvas.addEventListener('mouseleave', stopDragging);
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;

        const gridRect = gridCanvas.getBoundingClientRect();
        gridCanvas.width = Math.round(gridRect.width * dpr);
        gridCanvas.height = Math.round(gridRect.height * dpr);
        gridCtx.resetTransform();
        gridCtx.scale(dpr, dpr);
        gridCtx.imageSmoothingEnabled = true;
        gridCtx.imageSmoothingQuality = 'high';

        const torusRect = torusCanvas.getBoundingClientRect();
        torusCanvas.width = Math.round(torusRect.width * dpr);
        torusCanvas.height = Math.round(torusRect.height * dpr);
        torusCtx.resetTransform();
        torusCtx.scale(dpr, dpr);
        torusCtx.imageSmoothingEnabled = true;
        torusCtx.imageSmoothingQuality = 'high';

        state.needsRenderGrid = true;
        state.needsRenderTorus = true;
      }

      function init() {
        bindControls();
        setActiveButton(simButtons, 'data-sim', state.simulationMode);
        resizeCanvas();
        updateTwistControlRange();
        initGrid();
        updateModeDescription();
        updateViewText();
        renderFrame();
        state.lastFrameTime = performance.now();
        state.fpsSample = performance.now();
        requestAnimationFrame(animate);
      }

      window.addEventListener('resize', () => {
        resizeCanvas();
      });

      init();
    })();
  </script>
</body>
</html>
