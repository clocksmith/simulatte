<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Double Pendulum Simulator (RK4 + Visuals)</title>
    <style>
      :root {
        --bg-color: #ffffff;
        --card-bg-color: #f8f8f8;
        --text-color-dark: #1a1a1a;
        --text-color-light: #e5e5e5;
        --border-color: #444;
        --border-light-color: #ddd;
        --accent-crimson: #dc143c;
        --accent-pink: #ff1493;
        --accent-purple: #8a2be2;
        --accent-cyan: #008b8b;
        --accent-grey: #555;
        --accent-light-grey: #ccc;
        --font-main: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        background-color: var(--bg-color);
        color: var(--text-color-light);
        font-family: var(--font-main);
        margin: 0;
        padding: 25px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 25px;
        min-height: 100vh;
      }

      h1 {
        color: var(--text-color-dark);
        font-weight: 300;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 10px;
        width: 90%;
        max-width: 1200px;
        text-align: center;
        margin-bottom: 10px;
      }

      .main-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
        width: 100%;
        max-width: 1200px;
        align-items: stretch;
      }

      .card {
        background-color: var(--card-bg-color);
        color: var(--text-color-dark);
        border-radius: 4px;
        padding: 20px;
        border: 1px solid #eee;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      }

      .card h2 {
        margin-top: 0;
        color: var(--text-color-dark);
        border-bottom: 2px solid var(--border-light-color);
        padding-bottom: 12px;
        margin-bottom: 20px;
        font-weight: 600;
      }

      #pendulum-canvas {
        display: block;
        background-color: #fff;
        border: 1px solid var(--border-light-color);
        cursor: grab;
        border-radius: 4px;
        width: 100%;
        aspect-ratio: 4 / 3;
      }
      #pendulum-canvas:active {
        cursor: grabbing;
      }

      #visuals-container {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        align-items: stretch;
      }

      .visual-item {
        background-color: #f0f0f0;
        padding: 15px;
        border-radius: 6px;
        border: 1px solid var(--border-light-color);
        flex-grow: 1;
        flex-basis: 200px;
        display: flex;
        flex-direction: column;
      }
      .visual-item.chart-item {
        flex-basis: 400px;
        min-height: 180px;
      }

      .visual-item h3 {
        margin: 0 0 12px 0;
        font-size: 1.05em;
        color: var(--text-color-dark);
        font-weight: 600;
        flex-shrink: 0;
      }
      .visual-item p {
        margin: 5px 0;
        font-size: 0.95em;
        color: var(--accent-grey);
      }
      .visual-item small {
        font-size: 0.8em;
        color: var(--accent-grey);
        display: block;
        margin-top: 8px;
      }

      .position-visual {
        display: flex;
        justify-content: space-around;
        align-items: center;
        height: 70px;
        margin-bottom: 10px;
        flex-grow: 1;
      }

      .pos-circle {
        width: 60px;
        height: 60px;
        border: 2px solid var(--accent-light-grey);
        border-radius: 50%;
        position: relative;
        background-color: #fff;
      }

      .pos-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        transition: transform 0.05s linear;
      }
      #pos-dot-1 {
        background-color: var(--accent-crimson);
      }
      #pos-dot-2 {
        background-color: var(--accent-purple);
      }

      .data-display span {
        font-weight: bold;
        font-size: 1.1em;
        min-width: 70px;
        display: inline-block;
        text-align: right;
        color: var(--accent-cyan);
        font-family: "Consolas", "Monaco", monospace;
      }

      #history-chart-canvas {
        display: block;
        width: 100%;
        height: 156px;
        background-color: #fdfdfd;
        border: 1px solid var(--border-light-color);
        border-radius: 4px;
        margin-top: auto;
      }

      #controls-container fieldset {
        border: 1px solid var(--border-light-color);
        border-radius: 6px;
        margin-bottom: 20px;
        padding: 15px 20px;
        background-color: #fafafa;
      }
      #controls-container legend {
        font-weight: 600;
        color: var(--text-color-dark);
        padding: 0 8px;
        font-size: 1.1em;
      }

      .control-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
        gap: 15px;
        align-items: center;
      }

      .control-grid-force {
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 12px;
      }

      .control-item {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .control-item label {
        font-size: 0.9em;
        color: #333;
        font-weight: 500;
      }
      .control-item input[type="number"],
      .control-item input[type="checkbox"],
      .control-item select {
        padding: 9px 12px;
        border: 1px solid var(--accent-light-grey);
        border-radius: 4px;
        font-size: 0.95em;
        width: 100%;
      }
      .control-item input[type="range"] {
        width: 100%;
        cursor: pointer;
      }
      .control-item output {
        font-size: 0.9em;
        font-weight: bold;
        color: var(--accent-cyan);
      }

      .control-item input[type="checkbox"] {
        width: auto;
        height: auto;
        margin-right: 5px;
        align-self: flex-start;
        margin-top: 5px;
      }
      .control-item.checkbox-item {
        flex-direction: row;
        align-items: center;
      }

      button {
        padding: 10px 18px;
        border: none;
        border-radius: 5px;
        font-size: 1em;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.1s ease;
        color: white;
      }
      button:hover {
        opacity: 0.9;
      }
      button:active {
        transform: scale(0.97);
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      button.start {
        background-color: var(--accent-cyan);
      }
      button.stop {
        background-color: var(--accent-pink);
      }
      button.reset {
        background-color: var(--accent-grey);
      }
      button.download {
        background-color: var(--accent-purple);
      }

      .button-group {
        display: flex;
        gap: 12px;
        margin-top: 5px;
        flex-wrap: wrap;
      }
      #data-recording-status {
        margin-top: 10px;
        font-style: italic;
        color: var(--accent-grey);
        font-size: 0.9em;
        min-height: 1.2em;
      }
    </style>
  </head>
  <body>
    <h1>Double Pendulum Simulator (RK4 + Visuals)</h1>

    <div class="main-container">
      <div class="card" id="visuals-card">
        <h2>Visualizations</h2>
        <div id="visuals-container">
          <div class="visual-item">
            <h3>Node Angle</h3>
            <div class="position-visual">
              <div class="pos-circle" title="Theta 1 Angle (Rel. Vertical)">
                <div id="pos-dot-1" class="pos-dot"></div>
              </div>
              <div class="pos-circle" title="Theta 2 Angle (Rel. Vertical)">
                <div id="pos-dot-2" class="pos-dot"></div>
              </div>
            </div>
          </div>
          <div class="visual-item data-display">
            <h3>Angular Velocities</h3>
            <p>ω₁: <span id="omega1-display">0.00</span> rad/s</p>
            <p>ω₂: <span id="omega2-display">0.00</span> rad/s</p>
          </div>
          <div class="visual-item data-display">
            <h3>Energy & Chaos</h3>
            <p>E: <span id="energy-display">0.00</span> J</p>
            <p>ΔE: <span id="chaos-display">0.00</span> %</p>
            <small>Chaos: Energy StDev %</small>
          </div>
          <div class="visual-item chart-item">
            <h3>History</h3>
            <canvas id="history-chart-canvas"></canvas>
          </div>
        </div>
      </div>

      <div class="card" id="simulation-card">
        <canvas id="pendulum-canvas" width="600" height="450"></canvas>
      </div>

      <div class="card" id="controls-card">
        <h2>Controls & Parameters</h2>
        <div id="controls-container">
          <fieldset>
            <legend>Simulation Control</legend>
            <div class="button-group">
              <button id="start-button" class="start">Start</button>
              <button id="stop-button" class="stop">Stop</button>
              <button id="reset-button" class="reset">Reset</button>
            </div>
          </fieldset>

          <fieldset>
            <legend>Initial State & Parameters</legend>
            <div class="control-grid">
              <div class="control-item">
                <label for="theta1-input">Theta 1 (deg)</label>
                <input type="number" id="theta1-input" value="120" step="1" />
              </div>
              <div class="control-item">
                <label for="theta2-input">Theta 2 (deg)</label>
                <input type="number" id="theta2-input" value="-30" step="1" />
              </div>
              <div class="control-item">
                <label for="length1-input">Length 1 (m)</label>
                <input
                  type="number"
                  id="length1-input"
                  value="1.0"
                  step="0.1"
                  min="0.1"
                />
              </div>
              <div class="control-item">
                <label for="length2-input">Length 2 (m)</label>
                <input
                  type="number"
                  id="length2-input"
                  value="1.0"
                  step="0.1"
                  min="0.1"
                />
              </div>
              <div class="control-item">
                <label for="mass1-input">Mass 1 (kg)</label>
                <input
                  type="number"
                  id="mass1-input"
                  value="1.0"
                  step="0.1"
                  min="0.1"
                />
              </div>
              <div class="control-item">
                <label for="mass2-input">Mass 2 (kg)</label>
                <input
                  type="number"
                  id="mass2-input"
                  value="1.0"
                  step="0.1"
                  min="0.1"
                />
              </div>
              <div class="control-item">
                <label for="gravity-input">Gravity (m/s²)</label>
                <input
                  type="number"
                  id="gravity-input"
                  value="9.81"
                  step="0.1"
                  min="0"
                />
              </div>
              <div class="control-item">
                <label for="damping1-input">Damping 1</label>
                <input
                  type="number"
                  id="damping1-input"
                  value="0"
                  step="0.005"
                  min="0"
                  max="1"
                />
              </div>
              <div class="control-item">
                <label for="damping2-input">Damping 2</label>
                <input
                  type="number"
                  id="damping2-input"
                  value="0"
                  step="0.005"
                  min="0"
                  max="1"
                />
              </div>
              <div class="control-item">
                <label for="trace1-length-input">Trace 1 Length</label>
                <input
                  type="number"
                  id="trace1-length-input"
                  value="600"
                  step="50"
                  min="0"
                />
              </div>
              <div class="control-item">
                <label for="trace2-length-input">Trace 2 Length</label>
                <input
                  type="number"
                  id="trace2-length-input"
                  value="600"
                  step="50"
                  min="0"
                />
              </div>
            </div>
          </fieldset>

          <fieldset>
            <legend>Scene Forces (Optional)</legend>
            <div class="control-grid control-grid-force">
              <div class="control-item">
                <label for="dir-force-mag-input">Wind Mag (N)</label>
                <input
                  type="number"
                  id="dir-force-mag-input"
                  value="0"
                  step="0.1"
                  min="0"
                />
              </div>
              <div class="control-item">
                <label for="dir-force-angle-input">Wind Angle (deg)</label>
                <input
                  type="number"
                  id="dir-force-angle-input"
                  value="0"
                  step="5"
                />
              </div>
              <div class="control-item">
                <label for="charge1-input">Charge 1 (q)</label>
                <input type="number" id="charge1-input" value="0" step="0.1" />
              </div>
              <div class="control-item">
                <label for="charge2-input">Charge 2 (q)</label>
                <input type="number" id="charge2-input" value="0" step="0.1" />
              </div>
              <div class="control-item">
                <label for="mag-field-input">Mag Field (Bz)</label>
                <input
                  type="number"
                  id="mag-field-input"
                  value="0"
                  step="0.1"
                />
              </div>
            </div>
            <small
              >Applies uniform wind force and/or Lorentz force
              (simplified).</small
            >
          </fieldset>

          <fieldset>
            <legend>Data Recording</legend>
            <div class="button-group">
              <button id="download-data-button" class="download">
                Download Recorded Data (CSV)
              </button>
            </div>
            <div id="data-recording-status">
              Recording status will appear here.
            </div>
          </fieldset>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("pendulum-canvas");
      const ctx = canvas.getContext("2d");
      const historyChartCanvas = document.getElementById(
        "history-chart-canvas"
      );
      const chartCtx = historyChartCanvas.getContext("2d");

      const startButton = document.getElementById("start-button");
      const stopButton = document.getElementById("stop-button");
      const resetButton = document.getElementById("reset-button");
      const theta1Input = document.getElementById("theta1-input");
      const theta2Input = document.getElementById("theta2-input");
      const length1Input = document.getElementById("length1-input");
      const length2Input = document.getElementById("length2-input");
      const gravityInput = document.getElementById("gravity-input");
      const mass1Input = document.getElementById("mass1-input");
      const mass2Input = document.getElementById("mass2-input");
      const damping1Input = document.getElementById("damping1-input");
      const damping2Input = document.getElementById("damping2-input");
      const trace1LengthInput = document.getElementById("trace1-length-input");
      const trace2LengthInput = document.getElementById("trace2-length-input");
      const dirForceMagInput = document.getElementById("dir-force-mag-input");
      const dirForceAngleInput = document.getElementById(
        "dir-force-angle-input"
      );
      const charge1Input = document.getElementById("charge1-input");
      const charge2Input = document.getElementById("charge2-input");
      const magFieldInput = document.getElementById("mag-field-input");
      const downloadDataButton = document.getElementById(
        "download-data-button"
      );
      const dataRecordingStatus = document.getElementById(
        "data-recording-status"
      );

      const omega1Display = document.getElementById("omega1-display");
      const omega2Display = document.getElementById("omega2-display");
      const energyDisplay = document.getElementById("energy-display");
      const chaosDisplay = document.getElementById("chaos-display");
      const posDot1 = document.getElementById("pos-dot-1");
      const posDot2 = document.getElementById("pos-dot-2");

      let gravity = 9.81;
      let length1 = 1.0;
      let length2 = 1.0;
      let mass1 = 1.0;
      let mass2 = 1.0;
      let damping1 = 0;
      let damping2 = 0;
      let trace1MaxLength = 600;
      let trace2MaxLength = 600;
      let dirForceMag = 0;
      let dirForceAngleRad = 0;
      let charge1 = 0;
      let charge2 = 0;
      let magFieldBz = 0;

      let theta1 = (120 * Math.PI) / 180;
      let theta2 = (-30 * Math.PI) / 180;
      let omega1 = 0;
      let omega2 = 0;

      let time = 0;
      const timeStep = 1 / 120;
      let pixelsPerMeter = 100;
      let isRunning = false;
      let animationFrameId = null;
      let isDraggingM1 = false;
      let isDraggingM2 = false;
      let originX, originY;

      let trace1 = [];
      let trace2 = [];
      let chaosEnergyHistory = [];
      const CHAOS_HISTORY_LENGTH = 120;
      let colorBob1, colorBob2, colorTrace1, colorTrace2, colorRod, colorPivot;
      let colorEnergy,
        colorChaos,
        colorOmega1,
        colorOmega2,
        colorChartBg,
        colorChartGrid;
      const HISTORY_LENGTH = 200;
      let omega1History = [];
      let omega2History = [];
      let energyPlotHistory = [];

      let recordedData = [];
      const MAX_RECORDING_TIME = 600;
      const LOCAL_STORAGE_KEY = "pendulumRecordedData";

      function getCssVariable(varName) {
        return getComputedStyle(document.documentElement)
          .getPropertyValue(varName)
          .trim();
      }

      function loadColors() {
        colorBob1 = getCssVariable("--accent-crimson");
        colorBob2 = getCssVariable("--accent-purple");
        colorTrace1 = `${colorBob1}99`;
        colorTrace2 = `${colorBob2}99`;
        colorRod = getCssVariable("--accent-grey");
        colorPivot = getCssVariable("--text-color-dark");
        colorEnergy = getCssVariable("--accent-cyan");
        colorChaos = getCssVariable("--accent-pink");
        colorOmega1 = colorBob1;
        colorOmega2 = colorBob2;
        colorChartBg = "#fdfdfd";
        colorChartGrid = getCssVariable("--accent-light-grey");

        omega1Display.style.color = colorOmega1;
        omega2Display.style.color = colorOmega2;
        energyDisplay.style.color = colorEnergy;
        chaosDisplay.style.color = colorChaos;
      }

      function calculateAccelerations(
        currentTheta1,
        currentTheta2,
        currentOmega1,
        currentOmega2
      ) {
        const s1 = Math.sin(currentTheta1);
        const c1 = Math.cos(currentTheta1);
        const s2 = Math.sin(currentTheta2);
        const c2 = Math.cos(currentTheta2);
        const deltaTheta = currentTheta1 - currentTheta2; // Difference in angles
        const sinDeltaTheta = Math.sin(deltaTheta);
        const cosDeltaTheta = Math.cos(deltaTheta);

        const m1PlusM2 = mass1 + mass2;
        const epsilon = 1e-9;

        // Denominator term common in both acceleration equations (part of the effective inertia matrix)
        // Derived from the Lagrangian: L = T - V = 1/2 m1 v1^2 + 1/2 m2 v2^2 - (m1 g y1 + m2 g y2)
        // The kinetic energy T involves terms quadratic in omega1, omega2, with coefficients forming the mass matrix M.
        // The Euler-Lagrange equations d/dt(dL/d(omega_i)) - dL/d(theta_i) = Q_i lead to M * [alpha1, alpha2]^T = F(theta, omega) + Torque_external
        // This denominator arises from the determinant or inversion of the mass matrix M.
        const commonDenominatorTerm =
          2 * mass1 + mass2 - mass2 * Math.cos(2 * deltaTheta);

        // --- Calculate Angular Acceleration for Theta1 (angularAccel1) ---
        // This equation comes from the first Euler-Lagrange equation for theta1.
        // It represents (Inertia Matrix Inverse * Force/Torque Vector)_1
        let num1 = -gravity * (2 * mass1 + mass2) * s1; // Term from dV/d(theta1): Gravitational torque on m1 & effect of m2's weight on joint 1.
        num1 -= mass2 * gravity * Math.sin(currentTheta1 - 2 * currentTheta2); // Another gravitational term from dV/d(theta1) involving m2.
        // Terms involving omega^2 come from d/dt(dL/d(omega1)) and dL/d(theta1) (Coriolis/centrifugal forces).
        num1 -=
          2 *
          sinDeltaTheta *
          mass2 *
          (currentOmega2 * currentOmega2 * length2 +
            currentOmega1 * currentOmega1 * length1 * cosDeltaTheta);

        let den1 = length1 * commonDenominatorTerm;
        let angularAccel1 = Math.abs(den1) > epsilon ? num1 / den1 : 0;

        // --- Calculate Angular Acceleration for Theta2 (angularAccel2) ---
        // This equation comes from the second Euler-Lagrange equation for theta2.
        // It represents (Inertia Matrix Inverse * Force/Torque Vector)_2
        let num2 = 2 * sinDeltaTheta;
        // Terms involving omega^2 (Coriolis/centrifugal) and gravity (from dV/d(theta2)).
        num2 *=
          currentOmega1 * currentOmega1 * length1 * m1PlusM2 +
          gravity * m1PlusM2 * c1 +
          currentOmega2 * currentOmega2 * length2 * mass2 * cosDeltaTheta;

        let den2 = length2 * commonDenominatorTerm;
        let angularAccel2 = Math.abs(den2) > epsilon ? num2 / den2 : 0;

        let torque1Ext = 0;
        let torque2Ext = 0;

        if (dirForceMag > epsilon) {
          const forceWindX = dirForceMag * Math.cos(dirForceAngleRad);
          const forceWindY = dirForceMag * Math.sin(dirForceAngleRad);
          const x1Pos = length1 * s1;
          const y1Pos = length1 * c1;
          const x2PosRel = length2 * s2;
          const y2PosRel = length2 * c2;
          torque1Ext += x1Pos * forceWindY - y1Pos * forceWindX;
          torque1Ext +=
            (x1Pos + x2PosRel) * forceWindY - (y1Pos + y2PosRel) * forceWindX;
          torque2Ext += x2PosRel * forceWindY - y2PosRel * forceWindX;
        }

        if (
          Math.abs(magFieldBz) > epsilon &&
          (Math.abs(charge1) > epsilon || Math.abs(charge2) > epsilon)
        ) {
          const vx1 = length1 * c1 * currentOmega1;
          const vy1 = length1 * s1 * currentOmega1;
          const vx2 = vx1 + length2 * c2 * currentOmega2;
          const vy2 = vy1 + length2 * s2 * currentOmega2;
          const force1MagX = charge1 * vy1 * magFieldBz;
          const force1MagY = -charge1 * vx1 * magFieldBz;
          const force2MagX = charge2 * vy2 * magFieldBz;
          const force2MagY = -charge2 * vx2 * magFieldBz;
          const x1Pos = length1 * s1;
          const y1Pos = length1 * c1;
          const x2PosRel = length2 * s2;
          const y2PosRel = length2 * c2;
          torque1Ext += x1Pos * force1MagY - y1Pos * force1MagX;
          torque1Ext +=
            (x1Pos + x2PosRel) * force2MagY - (y1Pos + y2PosRel) * force2MagX;
          torque2Ext += x2PosRel * force2MagY - y2PosRel * force2MagX;
        }

        if (Math.abs(torque1Ext) > epsilon || Math.abs(torque2Ext) > epsilon) {
          const M11 = (mass1 + mass2) * length1 * length1;
          const M12 = mass2 * length1 * length2 * cosDeltaTheta;
          const M21 = M12;
          const M22 = mass2 * length2 * length2;
          const detM = M11 * M22 - M12 * M21;

          if (Math.abs(detM) > epsilon) {
            const invM11 = M22 / detM;
            const invM12 = -M12 / detM;
            const invM21 = -M21 / detM;
            const invM22 = M11 / detM;
            angularAccel1 += invM11 * torque1Ext + invM12 * torque2Ext;
            angularAccel2 += invM21 * torque1Ext + invM22 * torque2Ext;
          }
        }

        // --- Apply Damping ---
        // Added as a non-conservative force (generalized force Q_i = -damping_i * omega_i)
        angularAccel1 -= damping1 * currentOmega1;
        angularAccel2 -= damping2 * currentOmega2;

        return { angularAccel1, angularAccel2 };
      }

      function getDerivatives(state) {
        const [th1, th2, om1, om2] = state;
        const { angularAccel1, angularAccel2 } = calculateAccelerations(
          th1,
          th2,
          om1,
          om2
        );
        return [om1, om2, angularAccel1, angularAccel2];
      }

      function rk4Step(currentState, dt) {
        const k1 = getDerivatives(currentState);
        const k2State = currentState.map((val, i) => val + 0.5 * dt * k1[i]);
        const k2 = getDerivatives(k2State);
        const k3State = currentState.map((val, i) => val + 0.5 * dt * k2[i]);
        const k3 = getDerivatives(k3State);
        const k4State = currentState.map((val, i) => val + dt * k3[i]);
        const k4 = getDerivatives(k4State);

        const newState = currentState.map(
          (val, i) => val + (dt / 6.0) * (k1[i] + 2 * k2[i] + 2 * k3[i] + k4[i])
        );
        return newState;
      }

      function updatePhysics() {
        const currentState = [theta1, theta2, omega1, omega2];
        const newState = rk4Step(currentState, timeStep);

        [theta1, theta2, omega1, omega2] = newState;

        time += timeStep;

        if (time <= MAX_RECORDING_TIME) {
          const s1 = Math.sin(theta1);
          const c1 = Math.cos(theta1);
          const s2 = Math.sin(theta2);
          const c2 = Math.cos(theta2);
          const x1m = length1 * s1;
          const y1m = length1 * c1;
          const x2m = x1m + length2 * s2;
          const y2m = y1m + length2 * c2;

          recordedData.push({
            time: time,
            theta1,
            theta2,
            omega1,
            omega2,
            x1: x1m,
            y1: y1m,
            x2: x2m,
            y2: y2m,
          });
          if (recordedData.length === 1 || recordedData.length % 100 === 0) {
            // Update status less frequently
            if (time > MAX_RECORDING_TIME - timeStep) {
              dataRecordingStatus.textContent = `Recording complete (${MAX_RECORDING_TIME}s). Data saved.`;
            } else {
              const progress = (time / MAX_RECORDING_TIME) * 100;
              dataRecordingStatus.textContent = `Recording... ${time.toFixed(
                1
              )}s / ${MAX_RECORDING_TIME}s (${progress.toFixed(0)}%)`;
            }
          }
        }

        updateHistory();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawMagneticField();

        const l1Px = length1 * pixelsPerMeter;
        const l2Px = length2 * pixelsPerMeter;

        const s1 = Math.sin(theta1);
        const c1 = Math.cos(theta1);
        const s2 = Math.sin(theta2);
        const c2 = Math.cos(theta2);

        const x1Rel = l1Px * s1;
        const y1Rel = l1Px * c1;
        const x2Rel = x1Rel + l2Px * s2;
        const y2Rel = y1Rel + l2Px * c2;

        const x1 = originX + x1Rel;
        const y1 = originY + y1Rel;
        const x2 = originX + x2Rel;
        const y2 = originY + y2Rel;

        if (isRunning || isDraggingM1 || isDraggingM2) {
          trace1.push({ x: x1, y: y1 });
          trace2.push({ x: x2, y: y2 });
          if (trace1.length > trace1MaxLength) trace1.shift();
          if (trace2.length > trace2MaxLength) trace2.shift();
        }

        drawTrace(trace1, colorTrace1);
        drawTrace(trace2, colorTrace2);
        drawRod(originX, originY, x1, y1);
        drawRod(x1, y1, x2, y2);
        drawPivot(originX, originY);
        drawBob(x1, y1, mass1, colorBob1);
        drawBob(x2, y2, mass2, colorBob2);

        drawDampingForces(x1, y1, x2, y2);

        updateVisualsPanel();
        drawHistoryChart();
      }

      function drawMagneticField() {
        const fieldStrength = Math.abs(magFieldBz);
        if (fieldStrength < 0.01) return;

        const symbol = magFieldBz > 0 ? "+" : "-";
        const color =
          magFieldBz > 0 ? "rgba(0, 0, 255, 0.1)" : "rgba(255, 0, 0, 0.1)";
        const densityFactor = Math.min(5, fieldStrength) * 50; // Adjust density based on strength
        const numSymbols = Math.floor(
          (canvas.width * canvas.height) / (10000 / (densityFactor * 0.1 + 1))
        ); // Less dense for low strength

        ctx.font = "12px Arial";
        ctx.fillStyle = color;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        for (let i = 0; i < numSymbols; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          ctx.fillText(symbol, x, y);
        }
      }

      function drawDampingForces(x1, y1, x2, y2) {
        const epsilon = 0.01;
        // Calculate velocities
        const vx1 = length1 * Math.cos(theta1) * omega1; // dx/dt = d(L1*sin(t1))/dt
        const vy1 = length1 * Math.sin(theta1) * omega1; // dy/dt = d(L1*cos(t1))/dt (y points down)
        const vx2 = vx1 + length2 * Math.cos(theta2) * omega2;
        const vy2 = vy1 + length2 * Math.sin(theta2) * omega2;

        // Draw damping arrow for bob 1
        const speed1 = Math.hypot(vx1, vy1);
        if (damping1 > epsilon && speed1 > epsilon) {
          const forceMag1 = damping1 * speed1;
          const scale = Math.min(30, 5 + forceMag1 * 10); // Arrow length scales with force, capped
          const angle1 = Math.atan2(vy1, vx1); // Angle of velocity
          drawArrow(
            x1,
            y1,
            angle1 + Math.PI,
            scale,
            `rgba(100, 100, 100, ${Math.min(0.8, 0.1 + forceMag1 * 0.5)})`
          ); // Opposite direction
        }

        // Draw damping arrow for bob 2
        const speed2 = Math.hypot(vx2, vy2);
        if (damping2 > epsilon && speed2 > epsilon) {
          const forceMag2 = damping2 * speed2;
          const scale = Math.min(30, 5 + forceMag2 * 10);
          const angle2 = Math.atan2(vy2, vx2);
          drawArrow(
            x2,
            y2,
            angle2 + Math.PI,
            scale,
            `rgba(100, 100, 100, ${Math.min(0.8, 0.1 + forceMag2 * 0.5)})`
          );
        }
      }

      function drawArrow(x, y, angleRad, length, color) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angleRad);
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-length, 0);
        ctx.stroke();
        // Arrowhead
        ctx.beginPath();
        ctx.moveTo(-length, 0);
        ctx.lineTo(-length + 6, -3);
        ctx.lineTo(-length + 6, 3);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawTrace(trace, color) {
        if (trace.length < 2) return;
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(trace[0].x, trace[0].y);
        for (let i = 1; i < trace.length; i++)
          ctx.lineTo(trace[i].x, trace[i].y);
        ctx.stroke();
      }

      function drawRod(xStart, yStart, xEnd, yEnd) {
        ctx.strokeStyle = colorRod;
        ctx.lineWidth = 4;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(xStart, yStart);
        ctx.lineTo(xEnd, yEnd);
        ctx.stroke();
      }

      function drawPivot(x, y) {
        ctx.fillStyle = colorPivot;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fill();
      }

      function drawBob(x, y, m, color) {
        const radius = 6 + Math.sqrt(Math.max(0.1, m)) * 5;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      function updateHistory() {
        if (!isRunning && !isDraggingM1 && !isDraggingM2) return;

        const currentEnergy = calculateTotalEnergy();
        chaosEnergyHistory.push(currentEnergy);
        if (chaosEnergyHistory.length > CHAOS_HISTORY_LENGTH)
          chaosEnergyHistory.shift();

        omega1History.push(omega1);
        omega2History.push(omega2);
        energyPlotHistory.push(currentEnergy);

        if (omega1History.length > HISTORY_LENGTH) omega1History.shift();
        if (omega2History.length > HISTORY_LENGTH) omega2History.shift();
        if (energyPlotHistory.length > HISTORY_LENGTH)
          energyPlotHistory.shift();
      }

      function calculateTotalEnergy() {
        const c1 = Math.cos(theta1);
        const c2 = Math.cos(theta2);
        const cosDeltaTheta = Math.cos(theta1 - theta2);
        const ke1 = 0.5 * mass1 * length1 ** 2 * omega1 ** 2;
        const ke2 =
          0.5 *
          mass2 *
          (length1 ** 2 * omega1 ** 2 +
            length2 ** 2 * omega2 ** 2 +
            2 * length1 * length2 * omega1 * omega2 * cosDeltaTheta);
        const kineticEnergy = ke1 + ke2;
        const pe1 = -mass1 * gravity * length1 * c1;
        const pe2 = -mass2 * gravity * (length1 * c1 + length2 * c2);
        const potentialEnergy = pe1 + pe2;
        return kineticEnergy + potentialEnergy;
      }

      function calculateChaosMetric() {
        if (
          chaosEnergyHistory.length < CHAOS_HISTORY_LENGTH / 2 ||
          isDraggingM1 ||
          isDraggingM2
        ) {
          return 0; // Not enough data or system disturbed
        }

        const recentHistory = chaosEnergyHistory.slice(-CHAOS_HISTORY_LENGTH); // Use full history if available
        const n = recentHistory.length;
        if (n < 2) return 0;

        const meanEnergy = recentHistory.reduce((sum, e) => sum + e, 0) / n;
        const variance =
          recentHistory.reduce((sum, e) => sum + (e - meanEnergy) ** 2, 0) / n;
        const stDev = Math.sqrt(variance);

        // Return stdev as percentage of mean energy magnitude, avoid division by zero
        return Math.abs(meanEnergy) > 1e-6
          ? (stDev / Math.abs(meanEnergy)) * 100
          : 0;
      }

      function updateVisualsPanel() {
        const circleRadius = 30;
        const dotRadius = 5;
        const angleVizRadius = circleRadius - dotRadius;

        const angle1X = Math.sin(theta1);
        const angle1Y = Math.cos(theta1);
        posDot1.style.transform = `translate(calc(-50% + ${
          angle1X * angleVizRadius
        }px), calc(-50% + ${angle1Y * angleVizRadius}px))`;

        const angle2X = Math.sin(theta2);
        const angle2Y = Math.cos(theta2);
        posDot2.style.transform = `translate(calc(-50% + ${
          angle2X * angleVizRadius
        }px), calc(-50% + ${angle2Y * angleVizRadius}px))`;

        omega1Display.textContent = omega1.toFixed(2);
        omega2Display.textContent = omega2.toFixed(2);

        const totalEnergy = calculateTotalEnergy();
        energyDisplay.textContent = totalEnergy.toFixed(2);

        const chaosValue = calculateChaosMetric();
        chaosDisplay.textContent =
          isDraggingM1 || isDraggingM2 ? "N/A" : chaosValue.toFixed(2);
      }

      function drawHistoryChart() {
        const w = historyChartCanvas.width;
        const h = historyChartCanvas.height;
        chartCtx.fillStyle = colorChartBg;
        chartCtx.fillRect(0, 0, w, h);

        chartCtx.strokeStyle = colorChartGrid;
        chartCtx.lineWidth = 0.5;
        chartCtx.beginPath();
        chartCtx.moveTo(0, h / 3);
        chartCtx.lineTo(w, h / 3);
        chartCtx.moveTo(0, (2 * h) / 3);
        chartCtx.lineTo(w, (2 * h) / 3);

        const maxOmegaAbs = Math.max(
          1,
          ...omega1History.map(Math.abs),
          ...omega2History.map(Math.abs)
        );
        const energyVals = energyPlotHistory.filter((e) => isFinite(e));
        const minEnergy = energyVals.length > 0 ? Math.min(...energyVals) : -1; // Adjust default min/max
        const maxEnergy = energyVals.length > 0 ? Math.max(...energyVals) : 1;
        const energyRange = Math.max(1e-6, maxEnergy - minEnergy);

        const scaleOmega = h / 2 / (maxOmegaAbs + 1e-6);
        const scaleEnergy = h / (energyRange + 1e-6);

        plotHistory(
          energyPlotHistory,
          colorEnergy,
          scaleEnergy,
          h - maxEnergy * scaleEnergy,
          0.8
        );
        plotHistory(omega1History, colorOmega1, scaleOmega, h / 2, 1.5);
        plotHistory(omega2History, colorOmega2, scaleOmega, h / 2, 1.5);
      }

      function plotHistory(history, color, yScale, yOffset, lineWidth = 1.5) {
        if (history.length < 2) return;
        const w = historyChartCanvas.width;
        const stepX = w / (HISTORY_LENGTH - 1);

        chartCtx.strokeStyle = color;
        chartCtx.lineWidth = lineWidth;
        chartCtx.beginPath();
        let firstValidIndex = history.findIndex((val) =>
          isFinite(val * yScale)
        );
        if (firstValidIndex === -1) return;

        chartCtx.moveTo(
          firstValidIndex * stepX,
          yOffset - history[firstValidIndex] * yScale
        );

        for (let i = firstValidIndex + 1; i < history.length; i++) {
          let yVal = history[i] * yScale;
          if (isFinite(yVal)) {
            chartCtx.lineTo(i * stepX, yOffset - yVal);
          } else {
            chartCtx.stroke();
            let nextValidIndex = history.findIndex(
              (val, idx) => idx > i && isFinite(val * yScale)
            );
            if (nextValidIndex !== -1) {
              chartCtx.beginPath();
              chartCtx.moveTo(
                nextValidIndex * stepX,
                yOffset - history[nextValidIndex] * yScale
              );
              i = nextValidIndex;
            } else {
              break;
            }
          }
        }
        chartCtx.stroke();
      }

      function gameLoop() {
        if (isRunning) {
          updatePhysics();
        }
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
      }

      function startSimulation() {
        if (!isRunning) {
          isRunning = true;
          startButton.disabled = true;
          stopButton.disabled = false;
          if (!animationFrameId) {
            if (Math.abs(time) < 1e-6) {
              recordedData = [];
              chaosEnergyHistory = []; // Also clear chaos history on fresh start
              dataRecordingStatus.textContent = "Recording started...";
            } else if (time > MAX_RECORDING_TIME) {
              dataRecordingStatus.textContent =
                "Max recording time reached. Restart to record again.";
            } else {
              dataRecordingStatus.textContent = `Resuming recording... ${time.toFixed(
                1
              )}s / ${MAX_RECORDING_TIME}s`;
            }
            gameLoop();
          }
        }
      }

      function stopSimulation() {
        if (isRunning) {
          isRunning = false;
          startButton.disabled = false;
          stopButton.disabled = true;
          saveRecordedData();
          if (time <= MAX_RECORDING_TIME) {
            dataRecordingStatus.textContent = `Recording paused at ${time.toFixed(
              1
            )}s. Data saved.`;
          } else {
            dataRecordingStatus.textContent = `Recording complete. Data saved.`;
          }
        }
      }

      function resetSimulation() {
        stopSimulation();

        theta1 = (parseFloat(theta1Input.value) * Math.PI) / 180;
        theta2 = (parseFloat(theta2Input.value) * Math.PI) / 180;
        length1 = Math.max(0.1, parseFloat(length1Input.value));
        length2 = Math.max(0.1, parseFloat(length2Input.value));
        gravity = Math.max(0, parseFloat(gravityInput.value));
        mass1 = Math.max(0.1, parseFloat(mass1Input.value));
        mass2 = Math.max(0.1, parseFloat(mass2Input.value));
        damping1 = Math.max(0, parseFloat(damping1Input.value));
        damping2 = Math.max(0, parseFloat(damping2Input.value));
        trace1MaxLength = Math.max(0, parseInt(trace1LengthInput.value, 10));
        trace2MaxLength = Math.max(0, parseInt(trace2LengthInput.value, 10));
        dirForceMag = Math.max(0, parseFloat(dirForceMagInput.value));
        dirForceAngleRad =
          (parseFloat(dirForceAngleInput.value) * Math.PI) / 180;
        charge1 = parseFloat(charge1Input.value);
        charge2 = parseFloat(charge2Input.value);
        magFieldBz = parseFloat(magFieldInput.value);

        omega1 = 0;
        omega2 = 0;
        time = 0;
        trace1 = [];
        trace2 = [];
        chaosEnergyHistory = [];
        omega1History = [];
        omega2History = [];
        energyPlotHistory = [];
        recordedData = [];

        startButton.disabled = false;
        stopButton.disabled = true;
        dataRecordingStatus.textContent =
          "Ready to record (max 600s). Press Start.";

        resizeCanvas();
        draw();

        omega1Display.textContent = "0.00";
        omega2Display.textContent = "0.00";
        energyDisplay.textContent = calculateTotalEnergy().toFixed(2);
        chaosDisplay.textContent = "0.00";
        posDot1.style.transform = `translate(-50%, -50%)`;
        posDot2.style.transform = `translate(-50%, -50%)`;
      }

      function getMousePos(canvasEl, evt) {
        const rect = canvasEl.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
      }

      function handleMouseDown(e) {
        if (isRunning) return;

        const mousePos = getMousePos(canvas, e);
        const l1Px = length1 * pixelsPerMeter;
        const l2Px = length2 * pixelsPerMeter;
        const s1 = Math.sin(theta1);
        const c1 = Math.cos(theta1);
        const s2 = Math.sin(theta2);
        const c2 = Math.cos(theta2);
        const x1 = originX + l1Px * s1;
        const y1 = originY + l1Px * c1;
        const x2 = originX + l1Px * s1 + l2Px * s2;
        const y2 = originY + l1Px * c1 + l2Px * c2;

        const grabRadius1 = 6 + Math.sqrt(mass1) * 5 + 15;
        const grabRadius2 = 6 + Math.sqrt(mass2) * 5 + 15;

        const distToM2 = Math.hypot(mousePos.x - x2, mousePos.y - y2);
        const distToM1 = Math.hypot(mousePos.x - x1, mousePos.y - y1);

        if (distToM2 < grabRadius2) {
          isDraggingM2 = true;
          isDraggingM1 = false;
          canvas.style.cursor = "grabbing";
          chaosEnergyHistory = [];
          omega1History = [];
          omega2History = [];
          energyPlotHistory = [];
        } else if (distToM1 < grabRadius1) {
          isDraggingM1 = true;
          isDraggingM2 = false;
          canvas.style.cursor = "grabbing";
          chaosEnergyHistory = [];
          omega1History = [];
          omega2History = [];
          energyPlotHistory = [];
        }
      }

      function handleMouseMove(e) {
        if (!isDraggingM1 && !isDraggingM2) return;
        if (isRunning) {
          isDraggingM1 = false;
          isDraggingM2 = false;
          canvas.style.cursor = "grab";
          return;
        }

        const mousePos = getMousePos(canvas, e);

        if (isDraggingM1) {
          const dx = mousePos.x - originX;
          const dy = mousePos.y - originY;
          theta1 = Math.atan2(dx, dy);
          omega1 = 0;
          omega2 = 0;
        } else if (isDraggingM2) {
          const l1Px = length1 * pixelsPerMeter;
          const x1 = originX + l1Px * Math.sin(theta1);
          const y1 = originY + l1Px * Math.cos(theta1);
          const dx = mousePos.x - x1;
          const dy = mousePos.y - y1;
          theta2 = Math.atan2(dx, dy);
          omega1 = 0;
          omega2 = 0;
        }
        draw();
      }

      function handleMouseUpOrLeave() {
        if (isDraggingM1 || isDraggingM2) {
          isDraggingM1 = false;
          isDraggingM2 = false;
          canvas.style.cursor = "grab";
          theta1Input.value = ((theta1 * 180) / Math.PI).toFixed(1);
          theta2Input.value = ((theta2 * 180) / Math.PI).toFixed(1);
          omega1 = 0;
          omega2 = 0;
          time = 0;
          recordedData = [];
          chaosEnergyHistory = []; // Clear history after drag
          dataRecordingStatus.textContent =
            "Ready to record (max 600s). Press Start.";
          startButton.disabled = false;
          stopButton.disabled = true;
          draw();
        }
      }

      function saveRecordedData() {
        if (recordedData && recordedData.length > 0) {
          try {
            localStorage.setItem(
              LOCAL_STORAGE_KEY,
              JSON.stringify(recordedData)
            );
          } catch (e) {
            console.error("Error saving data to local storage:", e);
            dataRecordingStatus.textContent =
              "Error saving data. Storage might be full.";
          }
        } else {
          localStorage.removeItem(LOCAL_STORAGE_KEY);
        }
      }

      function downloadStoredData() {
        stopSimulation();

        let dataString;
        try {
          dataString = localStorage.getItem(LOCAL_STORAGE_KEY);
          if (!dataString) {
            dataRecordingStatus.textContent =
              "No recorded data found in storage.";
            alert("No recorded data found in local storage.");
            return;
          }
        } catch (e) {
          console.error("Error retrieving data from local storage:", e);
          dataRecordingStatus.textContent =
            "Error retrieving data from storage.";
          alert("Error retrieving data from local storage.");
          return;
        }

        let dataArray;
        try {
          dataArray = JSON.parse(dataString);
          if (!Array.isArray(dataArray) || dataArray.length === 0) {
            dataRecordingStatus.textContent =
              "Stored data is invalid or empty.";
            alert("Stored data is invalid or empty.");
            return;
          }
        } catch (e) {
          console.error("Error parsing stored data:", e);
          dataRecordingStatus.textContent = "Error parsing stored data.";
          alert("Error parsing stored data.");
          return;
        }

        dataRecordingStatus.textContent = `Preparing ${dataArray.length} data points for download...`;

        const header = Object.keys(dataArray[0]).join(",");
        const csvRows = dataArray.map((row) =>
          Object.values(row)
            .map((value) =>
              typeof value === "number" ? value.toFixed(8) : value
            )
            .join(",")
        );
        const csvContent = [header, ...csvRows].join("\n");

        try {
          const blob = new Blob([csvContent], {
            type: "text/csv;charset=utf-8;",
          });
          const link = document.createElement("a");
          const url = URL.createObjectURL(blob);
          link.setAttribute("href", url);
          const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
          link.setAttribute(
            "download",
            `pendulum_recorded_data_${timestamp}.csv`
          );
          link.style.visibility = "hidden";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          dataRecordingStatus.textContent = `Downloaded ${dataArray.length} data points.`;
        } catch (error) {
          console.error("Download failed:", error);
          dataRecordingStatus.textContent =
            "Error: Failed to generate or download file.";
          alert("Error generating download file.");
        }
      }

      function resizeCanvas() {
        const container = canvas.parentElement;
        if (!container) return;
        const computedStyle = getComputedStyle(container);
        const availableWidth =
          container.clientWidth -
          parseFloat(computedStyle.paddingLeft) -
          parseFloat(computedStyle.paddingRight);
        const aspectRatio = 4 / 3;
        const height = availableWidth / aspectRatio;

        canvas.width = availableWidth;
        canvas.height = height;

        const chartContainer = historyChartCanvas.parentElement;
        if (chartContainer) {
          historyChartCanvas.width =
            chartContainer.clientWidth -
            parseFloat(getComputedStyle(chartContainer).paddingLeft) -
            parseFloat(getComputedStyle(chartContainer).paddingRight);
          historyChartCanvas.height = 156;
        }

        const maxExtent = length1 + length2;
        const paddingFactor = 1.2;
        const scaleX = canvas.width / (maxExtent * 2 * paddingFactor);
        const scaleY = (canvas.height * 0.8) / (maxExtent * 2 * paddingFactor);

        pixelsPerMeter = Math.max(20, Math.min(scaleX, scaleY));
        if (maxExtent < 1e-6) pixelsPerMeter = 50;

        originX = canvas.width / 2;
        originY = canvas.height * 0.4;

        if (!isRunning && !isDraggingM1 && !isDraggingM2) draw();
      }

      function initialize() {
        loadColors();
        resetButton.addEventListener("click", resetSimulation);
        startButton.addEventListener("click", startSimulation);
        stopButton.addEventListener("click", stopSimulation);
        downloadDataButton.addEventListener("click", downloadStoredData);

        [
          theta1Input,
          theta2Input,
          length1Input,
          length2Input,
          gravityInput,
          mass1Input,
          mass2Input,
          damping1Input,
          damping2Input,
          trace1LengthInput,
          trace2LengthInput,
          dirForceMagInput,
          dirForceAngleInput,
          charge1Input,
          charge2Input,
          magFieldInput,
        ].forEach((input) => {
          input.addEventListener("change", () => {
            if (!isRunning) resetSimulation();
          });
        });

        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseup", handleMouseUpOrLeave);
        canvas.addEventListener("mouseleave", handleMouseUpOrLeave);

        window.addEventListener("resize", resizeCanvas);

        resetSimulation();
        stopSimulation();
        gameLoop();
      }

      document.addEventListener("DOMContentLoaded", initialize);
    </script>
  </body>
</html>
