<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SIMULATTE // Generative Experiments</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      color: #a0aec0;
      font-family: 'Courier New', monospace;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      overflow: hidden;
      cursor: none;
      transition: opacity 0.5s ease;
    }

    body.fade-out {
      opacity: 0;
    }

    #particleCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    .container {
      max-width: 800px;
      width: 100%;
      position: relative;
      z-index: 1;
    }

    #cursor {
      position: fixed;
      width: 20px;
      height: 20px;
      border: 2px solid #00ffff;
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
      transform-origin: center;
    }

    #cursor.morphed {
      border-radius: 4px;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
    }

    #cursor.click {
      border-color: #ffd700;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
    }

    h1 {
      font-size: clamp(2rem, 8vw, 4rem);
      background: linear-gradient(135deg, #00ffff, #ffd700);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 0.5rem;
      letter-spacing: 2px;
    }

    .tagline {
      color: #5f6c7b;
      font-size: 0.9rem;
      margin-bottom: 3rem;
      font-style: italic;
    }

    .exhibits {
      list-style: none;
      margin-bottom: 4rem;
    }

    .exhibit {
      margin-bottom: 1.5rem;
      padding-left: 1rem;
    }

    .exhibit a {
      color: #fff;
      text-decoration: none;
      display: block;
      font-size: 1.1rem;
      cursor: none;
      position: relative;
      padding: 0.5rem 0;
      transition: color 0.2s ease;
    }

    .exhibit a:hover {
      color: #00ffff;
    }

    .exhibit a:hover .exhibit-number {
      color: #ffd700;
    }

    .exhibit-number {
      color: #00ffff;
      font-size: 0.85rem;
      margin-right: 0.5rem;
    }

    .exhibit-name {
      font-weight: bold;
      margin-right: 0.5rem;
    }

    .exhibit-desc {
      color: #718096;
      font-size: 0.85rem;
      margin-top: 0.25rem;
      display: block;
      padding-left: 2.5rem;
    }

    .artist-statement {
      border-top: 1px solid #2d3748;
      padding-top: 2rem;
      color: #5f6c7b;
      font-size: 0.85rem;
      line-height: 1.6;
    }

    .artist-statement a {
      color: #00ffff;
      text-decoration: none;
    }

    .artist-statement a:hover {
      text-decoration: underline;
    }

    @media (max-width: 640px) {
      .exhibit-desc {
        padding-left: 0;
        margin-top: 0.5rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="particleCanvas"></canvas>
  <div id="cursor"></div>
  <div class="container">
    <h1>SIMULATTE</h1>
    <p style="font-size: 0.9rem; color: #718096; margin-top: 0.5rem; margin-bottom: 2rem;">
      a gallery of generative systems
    </p>

    <ul class="exhibits">
      <li class="exhibit">
        <a href="/psc">
          <span class="exhibit-number">01.</span>
          <span class="exhibit-name">Personality Shapes</span>
          <span class="exhibit-desc">Psychological states mapped to deformable geometry through parametric noise</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/spd">
          <span class="exhibit-number">02.</span>
          <span class="exhibit-name">Chaotic Pendulum</span>
          <span class="exhibit-desc">Double pendulum ballet demonstrating sensitive dependence on initial conditions</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/zqs">
          <span class="exhibit-number">03.</span>
          <span class="exhibit-name">Wave Collapse</span>
          <span class="exhibit-desc">Quantum probability distributions evolving through potential barriers</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/pss">
          <span class="exhibit-number">04.</span>
          <span class="exhibit-name">Particle Swarm</span>
          <span class="exhibit-desc">Emergent behavior from simple rules governing autonomous agents</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/utp">
          <span class="exhibit-number">05.</span>
          <span class="exhibit-name">Torus Network</span>
          <span class="exhibit-desc">3D processor topology with heat distribution and bandwidth traffic flows</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/cbg">
          <span class="exhibit-number">06.</span>
          <span class="exhibit-name">Urban Simulation</span>
          <span class="exhibit-desc">Isometric park management exploring human behavior and seasonal rhythms</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/aeh">
          <span class="exhibit-number">07.</span>
          <span class="exhibit-name">Poker Equity</span>
          <span class="exhibit-desc">Monte Carlo probability heatmaps revealing hidden strategic landscapes</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/sfs">
          <span class="exhibit-number">08.</span>
          <span class="exhibit-name">Strategic Flip</span>
          <span class="exhibit-desc">Three competing strategies converging through millions of simulated hands</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/cts">
          <span class="exhibit-number">09.</span>
          <span class="exhibit-name">Cap Table</span>
          <span class="exhibit-desc">Founder dilution trajectories visualized through transparent ledger mathematics</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/ftd">
          <span class="exhibit-number">10.</span>
          <span class="exhibit-name">Tool Designer</span>
          <span class="exhibit-desc">Meta-framework for dynamically generating executable tools via LLM API</span>
        </a>
      </li>
    </ul>

    <div class="artist-statement">
      <p>
        An <strong>n-gram and anagram collective</strong> created for mages who like games.
        Each piece explores rule-based generative systems where complexity emerges from mathematical simplicity.
      </p>
      <p style="margin-top: 1rem;">
        Built by <a href="https://github.com/clocksmith" target="_blank">@clocksmith</a>
      </p>
    </div>
  </div>

  <script>
    // Canvas setup
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');
    const cursor = document.getElementById('cursor');

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    // Mouse tracking
    let mouseX = width / 2;
    let mouseY = height / 2;
    let targetMouseX = width / 2;
    let targetMouseY = height / 2;
    let mouseVelocityX = 0;
    let mouseVelocityY = 0;
    let mouseSpeed = 0;
    let webOpacity = 0.04;
    let targetWebOpacity = 0.04;
    let isMouseDown = false;
    let time = 0;

    const trail = [];
    const maxTrailLength = 15;

    // Bouncy web points with spring physics
    const webPoints = [
      { x: 0, y: 0, vx: 0, vy: 0 },           // top-left
      { x: width, y: 0, vx: 0, vy: 0 },       // top-right
      { x: width, y: height, vx: 0, vy: 0 },  // bottom-right
      { x: 0, y: height, vx: 0, vy: 0 },      // bottom-left
      { x: width / 2, y: 0, vx: 0, vy: 0 },   // top-center
      { x: width / 2, y: height, vx: 0, vy: 0 } // bottom-center
    ];

    const webPointsOriginal = webPoints.map(p => ({ x: p.x, y: p.y }));

    // Click ripple effects (anywhere on page)
    const activeRipples = [];
    const exhibits = document.querySelectorAll('.exhibit a');

    // Intercept exhibit link clicks for fade transition
    exhibits.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const href = link.getAttribute('href');

        // Get the bounds of the clicked exhibit row
        const rect = link.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // Calculate max radius to fit within box bounds
        const maxDiagonal = Math.sqrt(rect.width * rect.width + rect.height * rect.height) / 2;

        // Create contained ripple effect
        for (let i = 0; i < 2; i++) {
          setTimeout(() => {
            activeRipples.push({
              x: centerX,
              y: centerY,
              radius: 0,
              maxRadius: maxDiagonal * 0.8 + i * 20, // Smaller, more contained
              life: 1,
              bounds: {
                left: rect.left,
                top: rect.top,
                width: rect.width,
                height: rect.height
              }
            });
          }, i * 80);
        }

        // Fade out and navigate after ripple animation
        setTimeout(() => {
          document.body.classList.add('fade-out');
        }, 200);

        setTimeout(() => {
          window.location.href = href;
        }, 700);
      });
    });

    // Regular clicks (not on links) still create ripples
    document.addEventListener('click', (e) => {
      // Only if not clicking on an exhibit link (those are handled above)
      if (!e.target.closest('.exhibit a')) {
        for (let i = 0; i < 2; i++) {
          setTimeout(() => {
            activeRipples.push({
              x: e.clientX,
              y: e.clientY,
              radius: 0,
              maxRadius: 120 + i * 40,
              life: 1
            });
          }, i * 80);
        }
      }
    });

    document.addEventListener('mousemove', (e) => {
      // Track mouse velocity for opacity changes
      const prevMouseX = targetMouseX;
      const prevMouseY = targetMouseY;

      targetMouseX = e.clientX;
      targetMouseY = e.clientY;

      mouseVelocityX = targetMouseX - prevMouseX;
      mouseVelocityY = targetMouseY - prevMouseY;
      mouseSpeed = Math.sqrt(mouseVelocityX * mouseVelocityX + mouseVelocityY * mouseVelocityY);

      // Increase opacity when mouse moves
      targetWebOpacity = Math.min(0.15, 0.04 + mouseSpeed * 0.003);

      // Add to trail with wave offset
      const waveOffset = Math.sin(time * 0.1) * 3;
      trail.push({
        x: targetMouseX + waveOffset,
        y: targetMouseY + Math.cos(time * 0.1) * 3,
        life: 1
      });
      if (trail.length > maxTrailLength) {
        trail.shift();
      }
    });

    // Custom cursor with morphing (smooth lerping)
    let currentHoveredExhibit = null;
    let cursorX = width / 2;
    let cursorY = height / 2;
    let cursorWidth = 20;
    let cursorHeight = 20;
    let targetCursorX = width / 2;
    let targetCursorY = height / 2;
    let targetCursorWidth = 20;
    let targetCursorHeight = 20;

    document.addEventListener('mousemove', (e) => {
      // Check if hovering over an exhibit
      const hoveredExhibit = Array.from(exhibits).find(link => {
        const rect = link.getBoundingClientRect();
        return e.clientX >= rect.left && e.clientX <= rect.right &&
               e.clientY >= rect.top && e.clientY <= rect.bottom;
      });

      if (hoveredExhibit !== currentHoveredExhibit) {
        currentHoveredExhibit = hoveredExhibit;

        if (hoveredExhibit) {
          cursor.classList.add('morphed');
        } else {
          cursor.classList.remove('morphed');
        }
      }

      // Update target position and size
      if (currentHoveredExhibit) {
        const rect = currentHoveredExhibit.getBoundingClientRect();
        targetCursorX = rect.left;
        targetCursorY = rect.top;
        targetCursorWidth = rect.width;
        targetCursorHeight = rect.height;
      } else {
        targetCursorX = e.clientX - 10;
        targetCursorY = e.clientY - 10;
        targetCursorWidth = 20;
        targetCursorHeight = 20;
      }
    });

    // Smooth cursor animation loop
    function updateCursor() {
      // Minimal smoothing - just 1 frame delay for motion visibility
      const lerpSpeed = 0.95;

      // Lerp position and size
      cursorX += (targetCursorX - cursorX) * lerpSpeed;
      cursorY += (targetCursorY - cursorY) * lerpSpeed;
      cursorWidth += (targetCursorWidth - cursorWidth) * lerpSpeed;
      cursorHeight += (targetCursorHeight - cursorHeight) * lerpSpeed;

      // Apply to DOM
      cursor.style.left = cursorX + 'px';
      cursor.style.top = cursorY + 'px';
      cursor.style.width = cursorWidth + 'px';
      cursor.style.height = cursorHeight + 'px';

      requestAnimationFrame(updateCursor);
    }
    updateCursor();

    document.addEventListener('mousedown', () => {
      isMouseDown = true;
      cursor.classList.add('click');
    });

    document.addEventListener('mouseup', () => {
      isMouseDown = false;
      cursor.classList.remove('click');
    });

    function animate() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, width, height);

      time += 0.016;

      // Smooth mouse movement
      mouseX += (targetMouseX - mouseX) * 0.15;
      mouseY += (targetMouseY - mouseY) * 0.15;

      // Smooth opacity transition
      webOpacity += (targetWebOpacity - webOpacity) * 0.05;
      // Fade back to base when mouse stops
      targetWebOpacity += (0.04 - targetWebOpacity) * 0.02;

      // Update bouncy web points with spring physics
      const springStrength = 0.015;
      const damping = 0.85;

      webPoints.forEach((point, i) => {
        const original = webPointsOriginal[i];

        // Calculate vector from mouse to point
        const dx = point.x - mouseX;
        const dy = point.y - mouseY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Push point away from mouse (inverse square falloff)
        if (dist < 300) {
          const force = (300 - dist) / 300;
          point.vx += (dx / dist) * force * 2;
          point.vy += (dy / dist) * force * 2;
        }

        // Spring back to original position
        point.vx += (original.x - point.x) * springStrength;
        point.vy += (original.y - point.y) * springStrength;

        // Apply damping
        point.vx *= damping;
        point.vy *= damping;

        // Update position
        point.x += point.vx;
        point.y += point.vy;
      });

      // Draw bouncy radial web with smooth opacity
      ctx.strokeStyle = `rgba(0, 255, 255, ${webOpacity})`;
      ctx.lineWidth = 0.6;

      webPoints.forEach(point => {
        ctx.beginPath();
        ctx.moveTo(mouseX, mouseY);
        ctx.lineTo(point.x, point.y);
        ctx.stroke();
      });

      // Draw sinusoidal mouse trail with wave distortion
      for (let i = 0; i < trail.length - 1; i++) {
        const point = trail[i];
        const nextPoint = trail[i + 1];

        point.life -= 0.06;
        const opacity = point.life * 0.4;
        const radius = 2 + Math.sin(i * 0.3 + time * 3) * 1;

        if (radius > 0 && opacity > 0) {
          ctx.beginPath();
          ctx.arc(point.x, point.y, Math.abs(radius), 0, Math.PI * 2);
          ctx.fillStyle = `rgba(0, 255, 255, ${opacity})`;
          ctx.fill();

          // Connect trail with lines
          if (nextPoint) {
            ctx.beginPath();
            ctx.moveTo(point.x, point.y);
            ctx.lineTo(nextPoint.x, nextPoint.y);
            ctx.strokeStyle = `rgba(0, 255, 255, ${opacity * 0.3})`;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }
      }

      // Clean up dead trail points
      while (trail.length > 0 && trail[0].life <= 0) {
        trail.shift();
      }

      // Draw click ripple explosions (smooth blue waves with radial fade)
      activeRipples.forEach((ripple, index) => {
        ripple.radius += 5;
        ripple.life -= 0.018;

        if (ripple.life > 0 && ripple.radius < ripple.maxRadius) {
          // Radial fade: stronger near edge, weaker at center
          const progress = ripple.radius / ripple.maxRadius;
          const radialFade = Math.sin(progress * Math.PI); // Peaks at middle, fades at edges
          const opacity = ripple.life * 0.5 * radialFade;

          // Clip to bounds if ripple has bounds (exhibit clicks)
          if (ripple.bounds) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(ripple.bounds.left, ripple.bounds.top, ripple.bounds.width, ripple.bounds.height);
            ctx.clip();
          }

          // Smoother sinusoidal wave distortion
          const segments = 80;
          ctx.beginPath();
          for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const wave = Math.sin(angle * 5 + time * 3) * 3 * ripple.life;
            const r = ripple.radius + wave;
            const x = ripple.x + Math.cos(angle) * r;
            const y = ripple.y + Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
          ctx.lineWidth = 1.5;
          ctx.stroke();

          if (ripple.bounds) {
            ctx.restore();
          }
        } else {
          activeRipples.splice(index, 1);
        }
      });

      requestAnimationFrame(animate);
    }

    animate();

    // Fade in on page load
    window.addEventListener('load', () => {
      document.body.style.opacity = '0';
      requestAnimationFrame(() => {
        document.body.style.transition = 'opacity 0.5s ease';
        document.body.style.opacity = '1';
      });
    });

    // Also fade in on back button / page show
    window.addEventListener('pageshow', (e) => {
      if (e.persisted) {
        // Page was restored from cache (back button)
        document.body.classList.remove('fade-out');
        document.body.style.opacity = '1';

        // Reset cursor state to prevent lag
        currentHoveredExhibit = null;
        cursor.classList.remove('morphed');
        targetCursorWidth = 20;
        targetCursorHeight = 20;
        cursorWidth = 20;
        cursorHeight = 20;
      }
    });

    // Reset cursor when page becomes visible (tab switching)
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        // Snap cursor to current target immediately to prevent lag
        cursorX = targetCursorX;
        cursorY = targetCursorY;
        cursorWidth = targetCursorWidth;
        cursorHeight = targetCursorHeight;
      }
    });
  </script>
</body>
</html>
