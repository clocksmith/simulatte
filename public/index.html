<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SIMULATTE // Generative Experiments</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@200;300;400;500&family=DM+Sans:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="simulatte-core.css">

  <style>
    /* 2. Page-Specific Overrides */
    body {
      min-height: 100vh;
      padding: 2rem;
      cursor: none;
      position: relative;
      overflow-x: hidden;
      font-family: 'DM Sans', system-ui, -apple-system, sans-serif;
    }

    #particleCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }

    /* Restore native cursor for touch devices */
    @media (hover: none), (pointer: coarse) {
      body {
        cursor: auto;
      }
      #cursor {
        display: none;
      }
      .exhibit a {
        cursor: pointer;
      }
    }

    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(
        circle at 50% 50%,
        rgba(0, 100, 150, 0.08) 0%,
        rgba(50, 0, 100, 0.06) 25%,
        rgba(0, 50, 80, 0.04) 50%,
        transparent 70%
      );
      opacity: 0;
      transition: opacity 0.6s ease;
      pointer-events: none;
      z-index: 1;
      animation: meshGradientFlow 20s ease-in-out infinite;
    }

    body.mouse-active::before {
      opacity: 1;
    }

    @keyframes meshGradientFlow {
      0%, 100% {
        transform: translate(0, 0) rotate(0deg) scale(1);
      }
      25% {
        transform: translate(5%, -5%) rotate(90deg) scale(1.1);
      }
      50% {
        transform: translate(-3%, 8%) rotate(180deg) scale(0.95);
      }
      75% {
        transform: translate(7%, 3%) rotate(270deg) scale(1.05);
      }
    }

    body.fade-out {
      opacity: 0;
      transition: opacity 0.6s ease-out;
    }

    .container {
      max-width: 1200px;
      width: 100%;
      position: relative;
      z-index: 10;
      margin: 0 auto;
    }

    /* Typography Overrides */
    h1 {
      font-family: 'Outfit', system-ui, sans-serif;
      font-size: clamp(3rem, 10vw, 5.5rem);
      font-weight: 200;
      letter-spacing: 0.2em;
      color: #c8c8c8;
      margin-bottom: 0.5rem;
      text-align: center;
      text-transform: uppercase;
    }

    .tagline {
      font-family: 'DM Sans', system-ui, sans-serif;
      color: var(--text-secondary);
      font-size: 1rem;
      margin-bottom: 3rem;
      font-style: italic;
      text-align: center;
      letter-spacing: 0.05em;
    }

    .exhibit-name {
      font-family: 'Outfit', system-ui, sans-serif;
      font-weight: 400;
    }

    .exhibits {
      list-style: none;
      margin-bottom: 6rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(min(100%, 320px), 1fr));
      gap: 1.5rem;
    }

    .exhibit {
      padding-left: 0;
    }

    .exhibit a {
      color: #fff;
      text-decoration: none;
      display: flex;
      flex-direction: column;
      font-size: clamp(0.9rem, 1.8vw, 1rem);
      cursor: none;
      position: relative;
      padding: clamp(1rem, 2.5vw, 1.25rem);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      background:
        radial-gradient(
          circle at center,
          rgba(255, 255, 255, 0.003) 0%,
          rgba(255, 255, 255, 0.001) 50%,
          rgba(255, 255, 255, 0) 100%
        );
      backdrop-filter: blur(0.5px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 8px;
      overflow: hidden;
      box-shadow:
        inset 0 0 20px rgba(255, 255, 255, 0.005),
        0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .exhibit a::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 150%;
      height: 150%;
      background:
        radial-gradient(
          ellipse at var(--mouse-x, 50%) var(--mouse-y, 50%),
          rgba(0, 255, 255, 0.08) 0%,
          rgba(100, 200, 255, 0.04) 20%,
          rgba(255, 100, 200, 0.02) 40%,
          transparent 70%
        );
      opacity: 0;
      transition: opacity 0.4s ease;
      pointer-events: none;
      transform: translate(-50%, -50%);
      mix-blend-mode: screen;
      filter: blur(20px);
      z-index: -1;
    }

    .exhibit a::after {
      content: '';
      position: absolute;
      inset: 0;
      background:
        linear-gradient(
          var(--ray-angle, 45deg),
          transparent 0%,
          rgba(0, 255, 255, 0.03) 30%,
          rgba(100, 200, 255, 0.04) 50%,
          rgba(255, 100, 200, 0.02) 70%,
          transparent 100%
        );
      opacity: 0;
      transition: opacity 0.5s ease, background 0.3s ease;
      pointer-events: none;
      mix-blend-mode: screen;
      z-index: -1;
    }

    .exhibit a:hover::before,
    .exhibit a:focus::before {
      opacity: 1;
      animation: rayPulse 3s ease-in-out infinite;
    }

    .exhibit a:hover::after,
    .exhibit a:focus::after {
      opacity: 1;
    }

    @keyframes rayPulse {
      0%, 100% {
        opacity: 0.6;
        filter: blur(20px);
      }
      50% {
        opacity: 1;
        filter: blur(15px);
      }
    }

    .exhibit a:hover,
    .exhibit a:focus {
      color: #00ffff;
      background: rgba(0, 255, 255, 0.02);
      border-color: rgba(0, 255, 255, 0.2);
      backdrop-filter: blur(2px);
      outline: none;
    }

    .exhibit a:hover .exhibit-number,
    .exhibit a:focus .exhibit-number {
      color: #ffd700;
    }

    .exhibit a:focus-visible {
      outline: 2px solid #00ffff;
      outline-offset: 2px;
    }

    .exhibit-number {
      color: #00ffff;
      font-size: clamp(0.7rem, 1.3vw, 0.75rem);
      margin-right: 0.5rem;
      transition: color 0.3s ease;
    }

    .exhibit-name {
      font-weight: bold;
      margin-right: 0.5rem;
      line-height: 1.4;
    }

    .exhibit-desc {
      color: #718096;
      font-size: clamp(0.7rem, 1.3vw, 0.75rem);
      margin-top: clamp(0.35rem, 0.8vw, 0.5rem);
      display: block;
      padding-left: 0;
      margin-left: 0;
      line-height: 1.5;
      transition: color 0.3s ease;
    }

    .artist-statement {
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      padding-top: 3rem;
      margin-top: 3rem;
      color: #5f6c7b;
      font-size: clamp(0.8rem, 1.5vw, 0.85rem);
      line-height: 1.8;
    }

    /* Artist Statement */
    .artist-statement {
      border-top: 1px solid var(--border-light);
      padding-top: 2rem;
      color: var(--text-secondary);
      font-size: 0.8rem;
    }
    .artist-statement a { color: var(--accent-secondary); cursor: none; } /* Green */

    /* Custom Cursor */
    #cursor {
      position: fixed; top: 0; left: 0;
      width: 20px; height: 20px;
      border: 1.5px solid var(--accent-tertiary);
      border-radius: 50%;
      pointer-events: none; z-index: 9999;
      transform-origin: center center;
      mix-blend-mode: difference;
    }
    #cursor.click { transform: scale(0.9); }

    @media (max-width: 768px) {
      .exhibit-desc {
        padding-left: 0;
        margin-left: 0;
        margin-top: 0.5rem;
      }
    }
  </style>
</head>
<body>

  <canvas id="particleCanvas"></canvas>
  <div id="cursor" aria-hidden="true"></div>
  <div class="container">
    <h1>Simulatte</h1>
    <p class="tagline">
      a gallery of generative systems
    </p>

    <ul class="exhibits">
      <li class="exhibit">
        <a href="/psc">
          <span class="exhibit-number">PSC</span>
          <span class="exhibit-name">Personality Shapes</span>
          <span class="exhibit-desc">Psychological states as deformable geometry</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/spd">
          <span class="exhibit-number">SPD</span>
          <span class="exhibit-name">Chaotic Pendulum</span>
          <span class="exhibit-desc">Sensitivity to initial conditions</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/zqs">
          <span class="exhibit-number">ZQS</span>
          <span class="exhibit-name">Wave Collapse</span>
          <span class="exhibit-desc">Quantum tunneling through barriers</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/pss">
          <span class="exhibit-number">PSS</span>
          <span class="exhibit-name">Particle Swarm</span>
          <span class="exhibit-desc">Emergent behavior from simple rules</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/utp">
          <span class="exhibit-number">UTP</span>
          <span class="exhibit-name">Torus Network</span>
          <span class="exhibit-desc">3D processor heat and bandwidth flows</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/cbg">
          <span class="exhibit-number">CBG</span>
          <span class="exhibit-name">Urban Simulation</span>
          <span class="exhibit-desc">Park management and seasonal rhythms</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/aeh">
          <span class="exhibit-number">AEH</span>
          <span class="exhibit-name">Poker Equity</span>
          <span class="exhibit-desc">Monte Carlo strategic landscapes</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/sfs">
          <span class="exhibit-number">SFS</span>
          <span class="exhibit-name">Strategic Flip</span>
          <span class="exhibit-desc">Strategy convergence simulation</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/cts">
          <span class="exhibit-number">CTS</span>
          <span class="exhibit-name">Cap Table</span>
          <span class="exhibit-desc">Founder dilution trajectories</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/ftd">
          <span class="exhibit-number">FTD</span>
          <span class="exhibit-name">Tool Designer</span>
          <span class="exhibit-desc">Dynamic tool generation via LLM</span>
        </a>
      </li>

      <li class="exhibit">
        <a href="/abc">
          <span class="exhibit-number">ABC</span>
          <span class="exhibit-name">Alphabet Smash</span>
          <span class="exhibit-desc">Toddler-friendly letters with voice recognition</span>
        </a>
      </li>
    </ul>
  </div>

  <script>
    // Animation constants
    const CONFIG = {
      cursor: {
        size: 20,
        lerpSpeed: 0.95
      },
      web: {
        baseOpacity: 0.4,
        maxOpacity: 0.7,
        opacityVelocityFactor: 0.006,
        opacityLerpSpeed: 0.05,
        mouseInfluenceRadius: 300,
        lineWidth: 2
      },
      spring: {
        strength: 0.03,
        damping: 0.88,
        breathAmplitude: 3
      },
      mouse: {
        lerpSpeed: 0.3
      },
      ripple: {
        expandSpeed: 33,
        decayRate: 0.042,
        segments: 120,
        baseOpacity: 0.8
      },
      glow: {
        innerRadius: 3,
        middleRadius: 6,
        outerRadius: 10
      },
      transition: {
        fadeDelay: 200,
        navigateDelay: 700
      }
    };

    // Canvas setup
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');
    const cursor = document.getElementById('cursor');
    const links = document.querySelectorAll('a');

    let width = window.innerWidth;
    let height = window.innerHeight;
    let mouse = { x: -100, y: -100 };
    let trail = [];
    let ripples = [];
    let time = 0;

    // Bouncy web points with spring physics - initialize with actual dimensions
    const webPoints = [
      { x: 0, y: 0, vx: 0, vy: 0 },           // top-left
      { x: width, y: 0, vx: 0, vy: 0 },       // top-right
      { x: width, y: height, vx: 0, vy: 0 },  // bottom-right
      { x: 0, y: height, vx: 0, vy: 0 }       // bottom-left
    ];

    const webPointsOriginal = [
      { x: 0, y: 0 },
      { x: width, y: 0 },
      { x: width, y: height },
      { x: 0, y: height }
    ];

    const resize = () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;

      // Update web points for new dimensions
      webPointsOriginal[0] = { x: 0, y: 0 };
      webPointsOriginal[1] = { x: width, y: 0 };
      webPointsOriginal[2] = { x: width, y: height };
      webPointsOriginal[3] = { x: 0, y: height };

      webPoints[0].x = 0; webPoints[0].y = 0;
      webPoints[1].x = width; webPoints[1].y = 0;
      webPoints[2].x = width; webPoints[2].y = height;
      webPoints[3].x = 0; webPoints[3].y = height;
    };
    window.addEventListener('resize', resize);
    resize();

    document.addEventListener('mousemove', e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      trail.push({ x: mouse.x, y: mouse.y, age: 0 });
      cursor.style.left = `${mouse.x}px`;
      cursor.style.top = `${mouse.y}px`;
    });

    // Mouse tracking
    let mouseX = width / 2;
    let mouseY = height / 2;
    let targetMouseX = width / 2;
    let targetMouseY = height / 2;
    let mouseVelocityX = 0;
    let mouseVelocityY = 0;
    let mouseSpeed = 0;
    let webOpacity = CONFIG.web.baseOpacity;
    let targetWebOpacity = CONFIG.web.baseOpacity;
    let isMouseDown = false;
    time = 0;

    const maxTrailLength = 15;

    // Click ripple effects (anywhere on page)
    const activeRipples = [];
    const exhibits = document.querySelectorAll('.exhibit a');

    // Intercept exhibit link clicks for fade transition
    exhibits.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const href = link.getAttribute('href');

        // Get the bounds of the clicked exhibit row
        const rect = link.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // Calculate max radius to fit within box bounds
        const maxDiagonal = Math.sqrt(rect.width * rect.width + rect.height * rect.height) / 2;

        // Create contained ripple effect
        for (let i = 0; i < 2; i++) {
          setTimeout(() => {
            activeRipples.push({
              x: centerX,
              y: centerY,
              radius: 0,
              maxRadius: maxDiagonal * 0.8 + i * 20, // Smaller, more contained
              life: 1,
              bounds: {
                left: rect.left,
                top: rect.top,
                width: rect.width,
                height: rect.height
              }
            });
          }, i * 80);
        }

        // Fade out and navigate after ripple animation
        setTimeout(() => {
          document.body.classList.add('fade-out');
        }, CONFIG.transition.fadeDelay);

        setTimeout(() => {
          window.location.href = href;
        }, CONFIG.transition.navigateDelay);
      });
    });

    // Regular clicks (not on links) still create ripples
    document.addEventListener('click', (e) => {
      // Only if not clicking on an exhibit link (those are handled above)
      if (!e.target.closest('.exhibit a')) {
        // Calculate distance to furthest corner to reach screen edges
        const distToCorners = [
          Math.sqrt(e.clientX ** 2 + e.clientY ** 2),
          Math.sqrt((width - e.clientX) ** 2 + e.clientY ** 2),
          Math.sqrt(e.clientX ** 2 + (height - e.clientY) ** 2),
          Math.sqrt((width - e.clientX) ** 2 + (height - e.clientY) ** 2)
        ];
        const maxDist = Math.max(...distToCorners);

        for (let i = 0; i < 3; i++) {
          setTimeout(() => {
            activeRipples.push({
              x: e.clientX,
              y: e.clientY,
              radius: 0,
              maxRadius: maxDist + i * 50,
              life: 1
            });
          }, i * 60);
        }
      }
    });

    // Custom cursor with morphing (smooth lerping)
    let currentHoveredExhibit = null;
    let cursorX = width / 2;
    let cursorY = height / 2;
    let cursorWidth = CONFIG.cursor.size;
    let cursorHeight = CONFIG.cursor.size;
    let cursorBorderRadius = CONFIG.cursor.size / 2; // Start as circle
    let targetCursorX = width / 2;
    let targetCursorY = height / 2;
    let targetCursorWidth = CONFIG.cursor.size;
    let targetCursorHeight = CONFIG.cursor.size;
    let targetCursorBorderRadius = CONFIG.cursor.size / 2;

    // Consolidated mousemove handler for better performance
    document.addEventListener('mousemove', (e) => {
      // Track mouse velocity for opacity changes
      const prevMouseX = targetMouseX;
      const prevMouseY = targetMouseY;

      targetMouseX = e.clientX;
      targetMouseY = e.clientY;

      mouseVelocityX = targetMouseX - prevMouseX;
      mouseVelocityY = targetMouseY - prevMouseY;
      mouseSpeed = Math.sqrt(mouseVelocityX * mouseVelocityX + mouseVelocityY * mouseVelocityY);

      // Increase opacity when mouse moves
      targetWebOpacity = Math.min(CONFIG.web.maxOpacity, CONFIG.web.baseOpacity + mouseSpeed * CONFIG.web.opacityVelocityFactor);

      // Check if hovering over an exhibit
      const hoveredExhibit = Array.from(exhibits).find(link => {
        const rect = link.getBoundingClientRect();
        return e.clientX >= rect.left && e.clientX <= rect.right &&
               e.clientY >= rect.top && e.clientY <= rect.bottom;
      });

      if (hoveredExhibit !== currentHoveredExhibit) {
        currentHoveredExhibit = hoveredExhibit;
      }

      // Update target position, size, and border radius
      if (currentHoveredExhibit) {
        const rect = currentHoveredExhibit.getBoundingClientRect();
        targetCursorX = rect.left;
        targetCursorY = rect.top;
        targetCursorWidth = rect.width;
        targetCursorHeight = rect.height;
        targetCursorBorderRadius = 8; // Rectangle corners
      } else {
        // Center the cursor circle on the mouse position
        targetCursorX = e.clientX - CONFIG.cursor.size / 2;
        targetCursorY = e.clientY - CONFIG.cursor.size / 2;
        targetCursorWidth = CONFIG.cursor.size;
        targetCursorHeight = CONFIG.cursor.size;
        targetCursorBorderRadius = CONFIG.cursor.size / 2; // Circle
      }
    });

    // Initialize cursor position off-screen
    cursorX = -100;
    cursorY = -100;
    targetCursorX = -100;
    targetCursorY = -100;

    // Smooth cursor animation loop
    function updateCursor() {
      const morphSpeed = 0.25; // Smooth morphing for size/shape

      // Position: instant when circle, lerped when morphing to exhibit box
      if (currentHoveredExhibit) {
        // Lerp position when morphing to exhibit box
        cursorX += (targetCursorX - cursorX) * morphSpeed;
        cursorY += (targetCursorY - cursorY) * morphSpeed;
      } else {
        // Instant position when normal cursor (no delay)
        cursorX = targetCursorX;
        cursorY = targetCursorY;
      }

      // Size and border radius always lerped for smooth morphing
      cursorWidth += (targetCursorWidth - cursorWidth) * morphSpeed;
      cursorHeight += (targetCursorHeight - cursorHeight) * morphSpeed;
      cursorBorderRadius += (targetCursorBorderRadius - cursorBorderRadius) * morphSpeed;

      // Apply to DOM
      cursor.style.left = cursorX + 'px';
      cursor.style.top = cursorY + 'px';
      cursor.style.width = cursorWidth + 'px';
      cursor.style.height = cursorHeight + 'px';
      cursor.style.borderRadius = cursorBorderRadius + 'px';

      requestAnimationFrame(updateCursor);
    }
    updateCursor();

    document.addEventListener('mousedown', () => {
      isMouseDown = true;
      cursor.classList.add('click');
    });

    document.addEventListener('mouseup', () => {
      isMouseDown = false;
      cursor.classList.remove('click');
    });

    // Pause animation when page is not visible
    let animationPaused = false;
    document.addEventListener('visibilitychange', () => {
      animationPaused = document.hidden;
    });

    function animate() {
      // Skip animation when page is hidden to save CPU/battery
      if (animationPaused) {
        requestAnimationFrame(animate);
        return;
      }

      // Clear canvas completely - no fade trail
      ctx.clearRect(0, 0, width, height);

      time += 0.016;

      // Smooth mouse movement
      mouseX += (targetMouseX - mouseX) * CONFIG.mouse.lerpSpeed;
      mouseY += (targetMouseY - mouseY) * CONFIG.mouse.lerpSpeed;

      // Smooth opacity transition - keep lines always visible
      webOpacity += (targetWebOpacity - webOpacity) * CONFIG.web.opacityLerpSpeed;

      // Update bouncy web points with spring physics
      webPoints.forEach((point, i) => {
        const original = webPointsOriginal[i];

        // Add subtle breathing motion even at rest
        const breathOffset = Math.sin(time * 0.5 + i * 0.8) * CONFIG.spring.breathAmplitude;
        const breathTargetX = original.x + Math.cos(i * Math.PI / 3) * breathOffset;
        const breathTargetY = original.y + Math.sin(i * Math.PI / 3) * breathOffset;

        // Calculate vector from mouse to point
        const dx = point.x - mouseX;
        const dy = point.y - mouseY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Push point away from mouse (inverse square falloff)
        if (dist < CONFIG.web.mouseInfluenceRadius) {
          const force = (CONFIG.web.mouseInfluenceRadius - dist) / CONFIG.web.mouseInfluenceRadius;
          point.vx += (dx / dist) * force * 2;
          point.vy += (dy / dist) * force * 2;
        }

        // Spring back to breathing target position instead of static original
        point.vx += (breathTargetX - point.x) * CONFIG.spring.strength;
        point.vy += (breathTargetY - point.y) * CONFIG.spring.strength;

        // Apply damping
        point.vx *= CONFIG.spring.damping;
        point.vy *= CONFIG.spring.damping;

        // Update position
        point.x += point.vx;
        point.y += point.vy;
      });

      // Draw click ripple explosions (smooth blue waves with radial fade)
      activeRipples.forEach((ripple, index) => {
        ripple.radius += CONFIG.ripple.expandSpeed;
        ripple.life -= CONFIG.ripple.decayRate;

        if (ripple.life > 0 && ripple.radius < ripple.maxRadius) {
          // Radial fade: fast-out curve with exponential decay
          const progress = ripple.radius / ripple.maxRadius;
          const fastOutEase = 1 - Math.pow(1 - progress, 3); // Fast start, ease out
          const radialFade = Math.pow(1 - progress, 2.5); // Smooth fade outward
          const opacity = ripple.life * CONFIG.ripple.baseOpacity * radialFade;

          // Clip to bounds if ripple has bounds (exhibit clicks)
          if (ripple.bounds) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(ripple.bounds.left, ripple.bounds.top, ripple.bounds.width, ripple.bounds.height);
            ctx.clip();
          }

          // Smoother sinusoidal wave distortion
          ctx.beginPath();
          for (let i = 0; i <= CONFIG.ripple.segments; i++) {
            const angle = (i / CONFIG.ripple.segments) * Math.PI * 2;
            const wave = Math.sin(angle * 6 + time * 2) * 2 * ripple.life;
            const r = ripple.radius + wave;
            const x = ripple.x + Math.cos(angle) * r;
            const y = ripple.y + Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
          ctx.lineWidth = 2;
          ctx.stroke();

          if (ripple.bounds) {
            ctx.restore();
          }
        } else {
          activeRipples.splice(index, 1);
        }
      });

      requestAnimationFrame(animate);
    }
    animate();

    // Handle back button / page show
    window.addEventListener('pageshow', (e) => {
      if (e.persisted) {
        // Page was restored from cache (back button)
        document.body.classList.remove('fade-out');

        // Reset cursor state to prevent lag
        currentHoveredExhibit = null;
        targetCursorWidth = CONFIG.cursor.size;
        targetCursorHeight = CONFIG.cursor.size;
        targetCursorBorderRadius = CONFIG.cursor.size / 2;
        cursorWidth = CONFIG.cursor.size;
        cursorHeight = CONFIG.cursor.size;
        cursorBorderRadius = CONFIG.cursor.size / 2;
      }
    });

    // Track mouse activity for mesh gradient
    let mouseActivityTimeout;
    document.addEventListener('mousemove', () => {
      document.body.classList.add('mouse-active');
      clearTimeout(mouseActivityTimeout);
      mouseActivityTimeout = setTimeout(() => {
        document.body.classList.remove('mouse-active');
      }, 2000);
    });

    // Dynamic ray casting - update CSS variables based on mouse position
    document.querySelectorAll('.exhibit a').forEach(card => {
      card.addEventListener('mousemove', (e) => {
        const rect = card.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;

        // Calculate angle from center to mouse
        const centerX = 50;
        const centerY = 50;
        const angle = Math.atan2(y - centerY, x - centerX) * (180 / Math.PI);

        card.style.setProperty('--mouse-x', `${x}%`);
        card.style.setProperty('--mouse-y', `${y}%`);
        card.style.setProperty('--ray-angle', `${angle}deg`);
      });

      card.addEventListener('mouseleave', () => {
        card.style.setProperty('--mouse-x', '50%');
        card.style.setProperty('--mouse-y', '50%');
        card.style.setProperty('--ray-angle', '45deg');
      });
    });

    // Keyboard navigation for exhibits
    const exhibitLinks = Array.from(document.querySelectorAll('.exhibit a'));
    const githubLink = document.querySelector('.artist-statement a');
    const allFocusableElements = [...exhibitLinks, githubLink].filter(el => el !== null);
    let currentFocusIndex = -1;

    document.addEventListener('keydown', (e) => {
      // Arrow keys for navigation
      if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
        e.preventDefault();
        currentFocusIndex = (currentFocusIndex + 1) % allFocusableElements.length;
        allFocusableElements[currentFocusIndex].focus();
      } else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
        e.preventDefault();
        currentFocusIndex = currentFocusIndex <= 0 ? allFocusableElements.length - 1 : currentFocusIndex - 1;
        allFocusableElements[currentFocusIndex].focus();
      } else if (e.key === 'Enter' && currentFocusIndex >= 0) {
        e.preventDefault();
        allFocusableElements[currentFocusIndex].click();
      }
    });

    // Track focus for keyboard navigation
    allFocusableElements.forEach((el, index) => {
      el.addEventListener('focus', () => {
        currentFocusIndex = index;
      });
    });

    // Reset cursor when page becomes visible (tab switching)
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        // Snap cursor to current target immediately to prevent lag
        cursorX = targetCursorX;
        cursorY = targetCursorY;
        cursorWidth = targetCursorWidth;
        cursorHeight = targetCursorHeight;
        cursorBorderRadius = targetCursorBorderRadius;
      }
    });
  </script>
</body>
</html>
