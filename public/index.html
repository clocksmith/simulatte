<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Simulatte</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      html,
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        color: #fff;
        font-family: monospace;
        text-align: center;
        height: 100vh;
        width: 100vw;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        position: relative;
      }
      .title {
        z-index: 10;
        pointer-events: none;
        font-size: 20px;
        letter-spacing: 3px;
      }
      .content {
        z-index: 10;
        pointer-events: none;
        font-size: 16px;
      }
      p {
        margin: 0.6em 0;
        user-select: none;
      }
      .content a {
        color: #f0f;
        text-decoration: none;
        pointer-events: auto;
      }
      .content a:hover {
        text-decoration: underline;
      }
      #particle-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
        z-index: 1;
      }
      #particle-container svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
      }
      #particle-container line {
        stroke: rgba(255, 255, 255, 0.5);
        stroke-width: 0.5;
        transition: opacity 0.5s ease-out;
      }
      #particle-container circle {
        fill: rgba(255, 255, 255, 0.8);
        transition: opacity 0.5s ease-out, r 0.1s linear, cx 0.1s linear,
          cy 0.1s linear;
        transform-origin: center center;
      }
      .particle-div {
        position: absolute;
        background-color: white;
        border-radius: 50%;
        transition: opacity 0.5s linear;
        transform-origin: center center;
        will-change: transform, opacity, left, top, width, height;
      }
      @keyframes twinkle-anim {
        0%,
        100% {
          opacity: var(--twinkle-min-opacity, 0.3);
          transform: scale(0.8);
        }
        50% {
          opacity: var(--twinkle-max-opacity, 1);
          transform: scale(1.2);
        }
      }
      .twinkle {
        animation-name: twinkle-anim;
        animation-timing-function: linear;
        animation-iteration-count: infinite;
        animation-direction: alternate;
      }
      .controls {
        position: fixed;
        top: 16px;
        right: 16px;
        left: auto;
        width: 320px;
        background: rgba(0, 0, 0, 0.4);
        padding: 12px 16px;
        box-sizing: border-box;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 16px;
        border: 1px solid #555;
        border-radius: 4px;
      }
      .mode-selector {
        display: flex;
        justify-content: center;
        border: 1px solid #0a0;
        border-radius: 4px;
        overflow: hidden;
      }
      .controls .mode-selector label {
        flex-grow: 1;
        text-align: center;
        padding: 5px 0;
        font-size: 12px;
        cursor: pointer;
        background-color: #111;
        color: #ccc;
        transition: background-color 0.2s, color 0.2s;
        user-select: none;
        justify-content: center;
      }
      .mode-selector input[type="radio"] {
        display: none;
      }
      .mode-selector input[type="radio"]:checked + label {
        background-color: #0a0;
        color: #fff;
        font-weight: bold;
      }
      .mode-selector label:not(:last-child) {
        border-right: 1px solid #0a0;
      }
      .control-row {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        gap: 8px;
      }
      .control-row[data-mode]:not(.visible) {
        display: none;
      }
      .controls label {
        font-size: 12px;
        color: #eee;
        display: flex;
        align-items: center;
        gap: 4px;
        white-space: nowrap;
        flex-grow: 1;
        justify-content: flex-end;
      }
      .controls label > span:first-child {
        margin-right: auto;
        flex-shrink: 0;
      }
      .controls input[type="range"] {
        width: 100px;
        height: 6px;
        vertical-align: middle;
        cursor: pointer;
        accent-color: #0f0;
        background: #333;
        border-radius: 3px;
        appearance: none;
        -webkit-appearance: none;
        outline: none;
        flex-grow: 1;
        min-width: 50px;
      }
      .controls input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 12px;
        height: 12px;
        background: #eee;
        border-radius: 50%;
        cursor: pointer;
      }
      .controls input[type="range"]::-moz-range-thumb {
        width: 12px;
        height: 12px;
        background: #eee;
        border-radius: 50%;
        cursor: pointer;
        border: none;
      }
      .controls .value-display {
        min-width: 35px;
        display: inline-block;
        text-align: right;
        color: #fff;
        font-size: 12px;
        font-weight: bold;
        flex-shrink: 0;
      }
    </style>
  </head>
  <body>
    <div id="particle-container">
      <svg id="network-svg"></svg>
    </div>

    <div class="content">
      <p class="title">SIMULATTE</p>
      <br />
      <p>an n-gram and anagram collective</p>
      <p>created for mages who like games</p>
      <br />
      <br />
      <p>
        <sub>some</sub>d<sup>emos</sup>
        <a href="/4">d<sup>4</sup></a>
        <a href="/2">d<sup>2</sup></a>
        <a href="/0">d<sup>0</sup></a>
      </p>
    </div>

    <div class="controls">
      <div class="mode-selector">
        <input
          type="radio"
          name="mode"
          id="mode-network"
          value="network"
          checked
        />
        <label for="mode-network">Network</label>
        <input type="radio" name="mode" id="mode-space" value="space" />
        <label for="mode-space">Space</label>
      </div>

      <div class="control-row" data-mode="network space">
        <label>
          <span>Particles:</span>
          <input
            type="range"
            id="num-particles"
            min="10"
            max="1000"
            value="64"
            step="1"
          />
          <span class="value-display" id="num-particles-value">64</span>
        </label>
      </div>

      <div class="control-row" data-mode="network">
        <label>
          <span>Connect Dist:</span>
          <input
            type="range"
            id="max-line-dist"
            min="20"
            max="300"
            value="100"
            step="5"
          />
          <span class="value-display" id="max-line-dist-value">100</span>
        </label>
      </div>
      <div class="control-row" data-mode="network">
        <label>
          <span>Density:</span>
          <input
            type="range"
            id="conn-density"
            min="0.01"
            max="0.5"
            value="0.1"
            step="0.01"
          />
          <span class="value-display" id="conn-density-value">0.10</span>
        </label>
      </div>
      <div class="control-row" data-mode="network">
        <label>
          <span>Net Speed:</span>
          <input
            type="range"
            id="net-speed"
            min="0.1"
            max="2.0"
            value="0.5"
            step="0.1"
          />
          <span class="value-display" id="net-speed-value">0.5</span>
        </label>
      </div>
      <div class="control-row" data-mode="network">
        <label>
          <span>Net Twinkle:</span>
          <input
            type="range"
            id="net-twinkle"
            min="0"
            max="1"
            value="0.0"
            step="0.05"
          />
          <span class="value-display" id="net-twinkle-value">0.00</span>
        </label>
      </div>
      <div class="control-row" data-mode="network">
        <label>
          <span>Line Life (s):</span>
          <input
            type="range"
            id="line-life"
            min="1"
            max="15"
            value="5"
            step="1"
          />
          <span class="value-display" id="line-life-value">5</span>
        </label>
      </div>

      <div class="control-row" data-mode="space">
        <label>
          <span>Space Speed:</span>
          <input
            type="range"
            id="space-speed"
            min="0.1"
            max="5"
            value="0.8"
            step="0.1"
          />
          <span class="value-display" id="space-speed-value">0.8</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Spin Strength:</span>
          <input
            type="range"
            id="spin"
            min="0"
            max="0.05"
            value="0.01"
            step="0.001"
          />
          <span class="value-display" id="spin-value">0.010</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Stretch Amt:</span>
          <input
            type="range"
            id="stretch"
            min="0"
            max="1.0"
            value="0.0"
            step="0.01"
          />
          <span class="value-display" id="stretch-value">0.00</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Emit Radius:</span>
          <input
            type="range"
            id="emit-radius"
            min="0"
            max="100"
            value="30"
            step="1"
          />
          <span class="value-display" id="emit-radius-value">30</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Space Twinkle:</span>
          <input
            type="range"
            id="space-twinkle"
            min="0"
            max="1"
            value="0.8"
            step="0.05"
          />
          <span class="value-display" id="space-twinkle-value">0.80</span>
        </label>
      </div>
    </div>

    <script>
      const svgNS = "http://www.w3.org/2000/svg";
      const pCont = document.getElementById("particle-container");
      const netSvg = document.getElementById("network-svg");

      let particles = [];
      let lines = [];
      let w = window.innerWidth;
      let h = window.innerHeight;
      let animId;
      let nextPId = 0;
      let mode = "network";
      let transitioningTo = null;
      let transStartT = 0;
      const transDur = 2000;
      const PI = Math.PI;

      let cfg = {
        mode: "network",
        numParticles: 64,
        maxLineDist: 100,
        connDensity: 0.1,
        netSpeed: 0.5,
        netTwinkle: 0.0,
        lineLife: 5000,
        spaceSpeed: 0.8,
        spin: 0.01,
        stretch: 0.0,
        emitRadius: 30,
        spaceTwinkle: 0.8,
        minStarSize: 0.5,
        maxStarSize: 2.5,
        stretchFactorBase: 0.15,
        baseCircleRadius: 1.2,
      };

      function rnd(min, max) { return Math.random() * (max - min) + min; }
      function rndInt(min, max) { return Math.floor(rnd(min, max + 1)); }

      function onResize() {
        w = window.innerWidth;
        h = window.innerHeight;
        netSvg.setAttribute("viewBox", `0 0 ${w} ${h}`);
        pCont.style.width = `${w}px`;
        pCont.style.height = `${h}px`;
        particles.forEach((p) => {
          const stableMode = transitioningTo || mode;
          if ( (stableMode === "space") &&
            (p.x > w + 150 || p.y > h + 150 || p.x < -150 || p.y < -150)) {
            resetPForSpace(p);
          } else if ( (stableMode === 'network') && (p.x > w || p.y > h || p.x < 0 || p.y < 0)) {
             p.x = Math.max(0, Math.min(w, p.x));
             p.y = Math.max(0, Math.min(h, p.y));
             if (p.vx !== undefined) {
                 if (p.x <= 0 || p.x >= w) p.vx *= -1;
                 if (p.y <= 0 || p.y >= h) p.vy *= -1;
             }
          }
        });
      }
      window.addEventListener("resize", onResize);

      function createPElement(type) {
          if (type === 'circle') {
              const el = document.createElementNS(svgNS, "circle");
              el.setAttribute("r", cfg.baseCircleRadius);
              el.style.opacity = 0;
              netSvg.appendChild(el);
              return el;
          } else {
              const el = document.createElement("div");
              el.classList.add("particle-div");
              const size = rnd(cfg.minStarSize, cfg.maxStarSize);
              el.style.width = `${size}px`;
              el.style.height = `${size}px`;
              el.dataset.size = size;
              el.style.opacity = 0;
              pCont.appendChild(el);
              return el;
          }
      }

      function ensureElement(p, type) {
          const currentType = (p.el && p.el.tagName === 'circle') ? 'circle' : 'div';
          if (!p.el || type !== currentType) {
              if (p.el && p.el.parentNode) p.el.remove();
              p.el = createPElement(type);
              p.el.style.opacity = p.opacity !== undefined ? p.opacity.toFixed(3) : '0';
          }
          return p.el;
      }

      function initPState(p, targetMode) {
        p.id = p.id ?? nextPId++;
        p.mode = targetMode;
        p.targetOpacity = targetMode === 'network' ? 1 : rnd(0.4, 1);

        if (!p.el) {
            p.el = createPElement(targetMode === 'network' ? 'circle' : 'div');
            p.opacity = 0;
        } else {
            ensureElement(p, targetMode === 'network' ? 'circle' : 'div');
        }

        if (targetMode === 'network') {
            p.x = p.x ?? rnd(0, w);
            p.y = p.y ?? rnd(0, h);
            const angle = rnd(0, PI * 2);
            const speed = rnd(0.1 * cfg.netSpeed, 1.0 * cfg.netSpeed);
            p.vx = p.vx ?? (Math.cos(angle) * speed);
            p.vy = p.vy ?? (Math.sin(angle) * speed);
            p.z = undefined;
            p.twinklePhase = p.twinklePhase ?? rnd(0, PI * 2);
        } else {
            const angle = rnd(0, PI * 2);
            const radius = cfg.emitRadius === 0 ? rnd(0, 5) : parseFloat(cfg.emitRadius);
            p.x = p.x ?? (w / 2 + Math.cos(angle) * radius);
            p.y = p.y ?? (h / 2 + Math.sin(angle) * radius);
            p.z = p.z ?? rnd(0.1, 1);
            p.vx = undefined;
            p.vy = undefined;
            if (p.el && p.el.tagName === 'DIV') {
                const size = parseFloat(p.el.dataset.size) || rnd(cfg.minStarSize, cfg.maxStarSize);
                p.el.style.width = `${size}px`;
                p.el.style.height = `${size}px`;
                p.el.dataset.size = size;
                updatePTwinkle(p);
            }
        }
        p.opacity = p.opacity ?? 0;
      }

      function resetPForSpace(p) {
          const angle = rnd(0, PI * 2);
          const radius = cfg.emitRadius === 0 ? rnd(0, 5) : parseFloat(cfg.emitRadius);
          p.x = w / 2 + Math.cos(angle) * radius;
          p.y = h / 2 + Math.sin(angle) * radius;
          p.z = rnd(0.1, 1);
          p.targetOpacity = rnd(0.4, 1);
          p.opacity = 0;
          if (p.el && p.el.tagName === 'DIV') {
            p.el.style.opacity = 0;
            const size = rnd(cfg.minStarSize, cfg.maxStarSize);
            p.el.style.width = `${size}px`;
            p.el.style.height = `${size}px`;
            p.el.dataset.size = size;
            p.el.style.transform = `rotate(0deg) scaleX(1)`;
            updatePTwinkle(p);
          }
      }

      function updatePNetwork(p, now) {
        p.x += p.vx;
        p.y += p.vy;
        if (p.x <= 0 || p.x >= w) p.vx *= -1;
        if (p.y <= 0 || p.y >= h) p.vy *= -1;
        p.x = Math.max(0, Math.min(w, p.x));
        p.y = Math.max(0, Math.min(h, p.y));

        if (p.opacity < p.targetOpacity) p.opacity = Math.min( p.targetOpacity, p.opacity + 0.05 );
        else if (p.opacity > p.targetOpacity) p.opacity = Math.max( p.targetOpacity, p.opacity - 0.05 );

        ensureElement(p, 'circle');
        p.el.setAttribute("cx", p.x);
        p.el.setAttribute("cy", p.y);

        if (cfg.netTwinkle > 0) {
             const tAmt = cfg.netTwinkle;
             p.twinklePhase += 0.05 + rnd(0, 0.05);
             const baseOp = p.opacity * (0.6 + tAmt * 0.4);
             const phaseVal = Math.sin(p.twinklePhase) * 0.5 + 0.5;
             const finalOp = baseOp * (1.0 - tAmt) + baseOp * tAmt * phaseVal;
             p.el.style.opacity = finalOp.toFixed(3);

             const baseR = cfg.baseCircleRadius;
             const scaleF = 1.0 + (phaseVal - 0.5) * 0.4 * tAmt;
             p.el.setAttribute("r", (baseR * scaleF).toFixed(2));
        } else {
             p.el.style.opacity = p.opacity.toFixed(3);
             p.el.setAttribute("r", cfg.baseCircleRadius);
        }
      }

      function updatePTwinkle(p) {
        if (!p.el || p.el.tagName === "circle") return;
        const intensity = cfg.spaceTwinkle;
        const el = p.el;

        if (intensity > 0) {
          if (!el.classList.contains("twinkle")) el.classList.add("twinkle");
          const duration = 2 + (1 - intensity) * 4;
          const minOp = 0.1 + intensity * 0.2;
          const maxOp = 0.6 + intensity * 0.4;
          el.style.animationDuration = `${rnd(duration*0.8, duration*1.2).toFixed(2)}s`;
          el.style.setProperty("--twinkle-min-opacity", minOp.toFixed(2));
          el.style.setProperty("--twinkle-max-opacity", maxOp.toFixed(2));
          el.style.animationPlayState = "running";
          el.style.opacity = "";
        } else {
          if (el.classList.contains("twinkle")) {
            el.classList.remove("twinkle");
            el.style.animation = "none";
          }
        }
      }

      function updatePSpace(p, now) {
        const cx = w / 2;
        const cy = h / 2;
        let dx = p.x - cx;
        let dy = p.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const radialSpeed = (1 / p.z) * cfg.spaceSpeed * 4;
        const angle = Math.atan2(dy, dx);
        const angularSpeed = cfg.spin * 50;

        const newAngle = angle + angularSpeed * 0.016;
        const radialMove = radialSpeed;
        const nextX = cx + (dist + radialMove) * Math.cos(newAngle);
        const nextY = cy + (dist + radialMove) * Math.sin(newAngle);

        const moveX = nextX - p.x;
        const moveY = nextY - p.y;

        p.x = nextX;
        p.y = nextY;

        if (p.opacity < p.targetOpacity) p.opacity = Math.min( p.targetOpacity, p.opacity + 0.05 );

        ensureElement(p, 'div');
        const size = parseFloat(p.el.dataset.size) || 1;
        p.el.style.left = `${p.x - size / 2}px`;
        p.el.style.top = `${p.y - size / 2}px`;

        updatePTwinkle(p);

        if (cfg.spaceTwinkle === 0) {
            const speedMag = Math.sqrt(moveX * moveX + moveY * moveY);
            const baseStretch = 1 + speedMag * cfg.stretchFactorBase * cfg.spaceSpeed;
            const stretchRnd = rnd(0.8, 1.2);
            const stretchF = cfg.stretch === 0 ? 1 : Math.max(1, baseStretch * cfg.stretch * stretchRnd);
            const angleRad = Math.atan2(moveY, moveX);
            p.el.style.transform = `rotate(${angleRad}rad) scaleX(${stretchF.toFixed(3)})`;
            p.el.style.opacity = p.opacity.toFixed(3);
        } else if (!p.el.classList.contains('twinkle')) {
             p.el.style.transform = 'rotate(0deg) scaleX(1)';
        }

        const border = 150;
        if ( p.x < -border || p.x > w + border || p.y < -border || p.y > h + border ) {
          resetPForSpace(p);
        }
      }

      function updatePTransition(p, now, progress) {
           const easedP = 0.5 - 0.5 * Math.cos(progress * PI);
           const targetM = transitioningTo;

           let startX = p.startX;
           let startY = p.startY;
           let targetX, targetY;
           let targetOp = p.targetOpacity;

           ensureElement(p, targetM === 'network' ? 'circle' : 'div');

           if (targetM === 'network') {
                targetX = p.networkX ?? startX;
                targetY = p.networkY ?? startY;
                targetOp = 1;
           } else {
                const angle = p.spaceAngle ?? Math.atan2(startY - h/2, startX - w/2) || rnd(0, PI * 2);
                const radius = cfg.emitRadius === 0 ? rnd(0, 5) : parseFloat(cfg.emitRadius);
                targetX = w / 2 + Math.cos(angle) * radius;
                targetY = h / 2 + Math.sin(angle) * radius;
                targetOp = p.spaceTargetOpacity ?? rnd(0.4, 1);
           }

           p.x = startX * (1.0 - easedP) + targetX * easedP;
           p.y = startY * (1.0 - easedP) + targetY * easedP;
           p.opacity = p.startOpacity * (1.0 - easedP) + targetOp * easedP;


           if (p.el) {
               p.el.style.opacity = p.opacity.toFixed(3);
               if (p.el.tagName === 'circle') {
                   p.el.setAttribute("cx", p.x);
                   p.el.setAttribute("cy", p.y);
                   p.el.setAttribute("r", cfg.baseCircleRadius);
               } else {
                   const size = parseFloat(p.el.dataset.size) || 1;
                   p.el.style.left = `${p.x - size / 2}px`;
                   p.el.style.top = `${p.y - size / 2}px`;
                   p.el.style.transform = `scale(${0.5 + easedP * 0.5})`;
                   if (p.el.classList.contains('twinkle')) {
                        p.el.style.animationPlayState = 'paused';
                        p.el.style.animation = 'none';
                        p.el.classList.remove('twinkle');
                   }
               }
           }
      }


      function calculateEffectiveMaxLineDist() {
        const refDim = 800;
        const currDim = Math.sqrt(w * h);
        return cfg.maxLineDist * (currDim / refDim);
      }

      function createLine(p1, p2) {
        const line = document.createElementNS(svgNS, "line");
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.style.opacity = 0;
        netSvg.appendChild(line);
        return {
          el: line, p1, p2,
          opacity: 0, targetOpacity: 0.6,
          born: performance.now(),
          maxLifetime: cfg.lineLife + rnd(-500, 500),
        };
      }

      function updateLines(now, transProgress = 1) {
        const isTargetNet = (transitioningTo === 'network') || (!transitioningTo && mode === 'network');
        const lineTargetOpBase = isTargetNet ? 0.5 : 0;
        const effectiveP = isTargetNet ? transProgress : (1 - transProgress);

        const visiblePs = particles.filter((p) => p.opacity > 0.1);
        const existingKeys = new Set( lines.map( (l) => `${Math.min(l.p1.id, l.p2.id)}-${Math.max(l.p1.id, l.p2.id)}`) );
        const maxDist = calculateEffectiveMaxLineDist();

        if (isTargetNet && effectiveP > 0.5) {
            for (let i = 0; i < visiblePs.length; i++) {
                for (let j = i + 1; j < visiblePs.length; j++) {
                    const p1 = visiblePs[i];
                    const p2 = visiblePs[j];
                    const key = `${Math.min(p1.id, p2.id)}-${Math.max(p1.id, p2.id)}`;
                    if (existingKeys.has(key)) continue;
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < maxDist && Math.random() < cfg.connDensity) {
                        const newLine = createLine(p1, p2);
                        newLine.opacity = 0;
                        lines.push(newLine);
                        existingKeys.add(key);
                    }
                }
            }
        }

        for (let i = lines.length - 1; i >= 0; i--) {
          const line = lines[i];
          const age = now - line.born;
          const fadeDur = 500;
          let currentTargetOp = lineTargetOpBase;

          if (isTargetNet) {
              if (age >= line.maxLifetime) currentTargetOp = 0;
              else if (age >= line.maxLifetime - fadeDur) currentTargetOp = Math.max(0, lineTargetOpBase * (1 - (age - (line.maxLifetime - fadeDur)) / fadeDur));
          }

          line.targetOpacity = currentTargetOp * effectiveP;

          if (line.opacity < line.targetOpacity) line.opacity = Math.min(line.targetOpacity, line.opacity + 0.05);
          else if (line.opacity > line.targetOpacity) line.opacity = Math.max(line.targetOpacity, line.opacity - 0.03);

          if (line.opacity <= 0.01 && (!isTargetNet || age >= line.maxLifetime) ) {
            if (line.el.parentNode) line.el.remove();
            lines.splice(i, 1);
          } else {
            if (line.p1 && line.p2 && line.p1.el && line.p2.el) {
              line.el.setAttribute("x1", line.p1.x);
              line.el.setAttribute("y1", line.p1.y);
              line.el.setAttribute("x2", line.p2.x);
              line.el.setAttribute("y2", line.p2.y);
              line.el.style.opacity = (line.opacity * Math.min(line.p1.opacity, line.p2.opacity)).toFixed(3);
            } else {
              line.el.style.opacity = 0;
            }
          }
        }
      }

      function manageParticles() {
        const targetCount = cfg.numParticles;
        const stableMode = transitioningTo || mode;

        while (particles.length < targetCount) {
          const newP = {};
          initPState(newP, stableMode);
          newP.opacity = transitioningTo ? 0 : newP.targetOpacity;
          particles.push(newP);
        }
        while (particles.length > targetCount) {
          const removedP = particles.pop();
          if (removedP.el && removedP.el.parentNode) {
               removedP.el.style.transition = 'opacity 0.5s linear';
               removedP.el.style.opacity = 0;
               setTimeout(() => { if (removedP.el && removedP.el.parentNode) removedP.el.remove()}, 500);
           }
          lines = lines.filter(line => line.p1 !== removedP && line.p2 !== removedP);
        }

         particles.forEach(p => {
             if (p.mode !== stableMode && !transitioningTo) initPState(p, stableMode);
             if (stableMode === 'space') updatePTwinkle(p);
         });
      }

      function animate(timestamp) {
        animId = requestAnimationFrame(animate);
        const now = timestamp || performance.now();

        if (transitioningTo) {
          const elapsed = now - transStartT;
          const progress = Math.min(1, elapsed / transDur);

          particles.forEach((p) => updatePTransition(p, now, progress));
          updateLines(now, progress);

          if (progress >= 1) {
            const finalMode = transitioningTo;
            mode = transitioningTo;
            transitioningTo = null;
            particles.forEach((p) => {
              p.mode = finalMode;
              p.opacity = p.targetOpacity;
              initPState(p, finalMode);
            });
            manageParticles();
            updateCtrlVisibility();
          }
        } else {
          if (mode === "network") {
            particles.forEach((p) => updatePNetwork(p, now));
            updateLines(now);
          } else if (mode === "space") {
            particles.forEach((p) => updatePSpace(p, now));
          }
        }
      }

      function setMode(newMode) {
        if (newMode === mode || transitioningTo) return;

        transitioningTo = newMode;
        transStartT = performance.now();
        cfg.mode = newMode;

        particles.forEach((p) => {
            p.targetOpacity = (newMode === 'network') ? 1 : rnd(0.4, 1);
            p.startX = p.x;
            p.startY = p.y;
            p.startOpacity = p.opacity;
            if (newMode === 'network' && p.vx === undefined) {
                 p.networkX = p.x; p.networkY = p.y; // Store potential target
            }
            if (newMode === 'space' && p.z === undefined) {
                 p.spaceAngle = Math.atan2(p.y - h/2, p.x - w/2) || rnd(0, PI * 2);
                 p.spaceTargetOpacity = rnd(0.4, 1);
            }
        });

        updateCtrlVisibility();

        if (!animId) animId = requestAnimationFrame(animate);
      }

      function updateCtrlVisibility() {
        document.querySelectorAll(".controls .control-row[data-mode]")
          .forEach((row) => {
            const modes = row.dataset.mode.split(" ");
            const targetM = transitioningTo || mode;
            row.classList.toggle("visible", modes.includes(targetM));
          });
        netSvg.style.display = (mode === "network" || transitioningTo === "network") ? "block" : "none";
      }

      function setupCtrls() {
        const ctrlMap = {
          "num-particles": { key: "numParticles", cb: manageParticles, mode: "network space" },
          "max-line-dist": { key: "maxLineDist", mode: "network" },
          "conn-density": { key: "connDensity", fixed: 2, mode: "network" },
          "net-speed": { key: "netSpeed", fixed: 1, mode: "network" },
          "net-twinkle": { key: "netTwinkle", fixed: 2, mode: "network" },
          "line-life": { key: "lineLife", mult: 1000, mode: "network" },
          "space-speed": { key: "spaceSpeed", fixed: 1, mode: "space" },
          "spin": { key: "spin", fixed: 3, mode: "space" },
          "stretch": { key: "stretch", fixed: 2, mode: "space" },
          "emit-radius": { key: "emitRadius", mode: "space" },
          "space-twinkle": { key: "spaceTwinkle", fixed: 2, cb: manageParticles, mode: "space" },
        };

        Object.entries(ctrlMap).forEach(([id, ctrl]) => {
          const el = document.getElementById(id);
          if (!el) return;
          const valEl = document.getElementById(id + "-value");
          const initVal = cfg[ctrl.key];
          const dispVal = ctrl.mult ? initVal / ctrl.mult : initVal;

          el.value = dispVal;
          if (valEl) valEl.textContent = ctrl.fixed !== undefined ? dispVal.toFixed(ctrl.fixed) : dispVal;

          el.addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            const cfgVal = ctrl.mult ? value * ctrl.mult : value;
            cfg[ctrl.key] = cfgVal;

            if (valEl) valEl.textContent = ctrl.fixed !== undefined ? value.toFixed(ctrl.fixed) : value;

            if (id === "num-particles") cfg.numParticles = parseInt(value);

            if (ctrl.cb) ctrl.cb();
          });
        });

        document.querySelectorAll('.mode-selector input[name="mode"]')
          .forEach((radio) => radio.addEventListener("change", (e) => setMode(e.target.value)) );
      }

      function init() {
        setupCtrls();
        onResize();
        mode = cfg.mode;
        document.getElementById(`mode-${mode}`).checked = true;
        manageParticles();
        updateCtrlVisibility();
        if (!animId) animId = requestAnimationFrame(animate);
      }

      init();
    </script>
  </body>
</html>
