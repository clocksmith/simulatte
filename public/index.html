<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Simulatte</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      html,
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        color: #fff;
        font-family: monospace;
        text-align: center;
        height: 100vh;
        width: 100vw;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        position: relative;
      }
      .title {
        z-index: 10;
        pointer-events: none;
        font-size: 24px;
      }
      .content {
        z-index: 10;
        pointer-events: none;
        font-size: 16px;
      }
      p {
        margin: 0.6em 0;
        user-select: none;
      }
      .content a {
        color: #f0f;
        text-decoration: none;
        pointer-events: auto;
      }
      .content a:hover {
        text-decoration: underline;
      }
      #particle-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
        z-index: 1;
      }
      #particle-container svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #particle-container line {
        stroke: rgba(255, 255, 255, 0.5);
        stroke-width: 0.5;
        transition: opacity 0.3s ease-out;
      }
      #particle-container circle {
        fill: rgba(255, 255, 255, 0.8);
        transition: opacity 0.3s ease-out;
      }
      .particle-div {
        position: absolute;
        background-color: white;
        border-radius: 50%;
        transition: opacity 0.5s linear;
        transform-origin: center center;
        will-change: transform, opacity, left, top;
      }
      @keyframes twinkle-anim {
        0%,
        100% {
          opacity: var(--twinkle-min-opacity, 0.3);
          transform: scale(0.8);
        }
        50% {
          opacity: var(--twinkle-max-opacity, 1);
          transform: scale(1.2);
        }
      }
      .twinkle {
        animation-name: twinkle-anim;
        animation-timing-function: linear;
        animation-iteration-count: infinite;
        animation-direction: alternate;
      }
      .controls {
        position: fixed;
        top: 16px;
        right: 16px;
        left: auto;
        width: 320px;
        background: rgba(0, 0, 0, 0.4);
        padding: 12px 16px;
        box-sizing: border-box;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 16px;
        border: 1px solid #555;
        border-radius: 4px;
      }
      .mode-selector {
        display: flex;
        justify-content: center;
        border: 1px solid #0a0;
        border-radius: 4px;
        overflow: hidden;
      }
      .controls .mode-selector label {
        flex-grow: 1;
        text-align: center;
        padding: 5px 0;
        font-size: 12px;
        cursor: pointer;
        background-color: #111;
        color: #ccc;
        transition: background-color 0.2s, color 0.2s;
        user-select: none;
        justify-content: center;
      }
      .mode-selector input[type="radio"] {
        display: none;
      }
      .mode-selector input[type="radio"]:checked + label {
        background-color: #0a0;
        color: #fff;
        font-weight: bold;
      }
      .mode-selector label:not(:last-child) {
        border-right: 1px solid #0a0;
      }
      .control-row {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        gap: 8px;
      }
      .control-row[data-mode]:not(.visible) {
        display: none;
      }
      .controls label {
        font-size: 12px;
        color: #eee;
        display: flex;
        align-items: center;
        gap: 4px;
        white-space: nowrap;
        flex-grow: 1;
        justify-content: flex-end;
      }
      .controls label > span:first-child {
        margin-right: auto;
        flex-shrink: 0;
      }
      .controls input[type="range"] {
        width: 100px;
        height: 6px;
        vertical-align: middle;
        cursor: pointer;
        accent-color: #0f0;
        background: #333;
        border-radius: 3px;
        appearance: none;
        -webkit-appearance: none;
        outline: none;
        flex-grow: 1;
        min-width: 50px;
      }
      .controls input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 12px;
        height: 12px;
        background: #eee;
        border-radius: 50%;
        cursor: pointer;
      }
      .controls input[type="range"]::-moz-range-thumb {
        width: 12px;
        height: 12px;
        background: #eee;
        border-radius: 50%;
        cursor: pointer;
        border: none;
      }
      .controls .value-display {
        min-width: 35px;
        display: inline-block;
        text-align: right;
        color: #fff;
        font-size: 12px;
        font-weight: bold;
        flex-shrink: 0;
      }
    </style>
  </head>
  <body>
    <div id="particle-container">
      <svg id="network-svg"></svg>
    </div>

    <div class="content">
      <p class="title">Simulatte</p>
      <br />
      <p>an n-gram and anagram collective</p>
      <p>created for mages who like games</p>
      <br />
      <br />
      <p>
        <sub>some</sub>d<sup>emos</sup>
        <a href="/2">d<sup>2</sup></a>
        <a href="/4">d<sup>4</sup></a>
        <a href="/0">d<sup>0</sup></a>
      </p>
    </div>

    <div class="controls">
      <div class="mode-selector">
        <input
          type="radio"
          name="mode"
          id="mode-network"
          value="network"
          checked
        />
        <label for="mode-network">Network</label>
        <input type="radio" name="mode" id="mode-space" value="space" />
        <label for="mode-space">Space</label>
      </div>

      <div class="control-row" data-mode="network space">
        <label>
          <span>Particles:</span>
          <input
            type="range"
            id="num-particles"
            min="10"
            max="1000"
            value="64"
            step="1"
          />
          <span class="value-display" id="num-particles-value">64</span>
        </label>
      </div>

      <div class="control-row" data-mode="network">
        <label>
          <span>Connect Dist:</span>
          <input
            type="range"
            id="max-line-dist"
            min="20"
            max="300"
            value="100"
            step="5"
          />
          <span class="value-display" id="max-line-dist-value">100</span>
        </label>
      </div>
      <div class="control-row" data-mode="network">
        <label>
          <span>Density:</span>
          <input
            type="range"
            id="connection-density"
            min="0.01"
            max="0.5"
            value="0.1"
            step="0.01"
          />
          <span class="value-display" id="connection-density-value">0.10</span>
        </label>
      </div>
      <div class="control-row" data-mode="network">
        <label>
          <span>Net Speed:</span>
          <input
            type="range"
            id="vertex-speed"
            min="0.1"
            max="2.0"
            value="0.5"
            step="0.1"
          />
          <span class="value-display" id="vertex-speed-value">0.5</span>
        </label>
      </div>
      <div class="control-row" data-mode="network">
        <label>
          <span>Line Life (s):</span>
          <input
            type="range"
            id="line-life"
            min="1"
            max="15"
            value="5"
            step="1"
          />
          <span class="value-display" id="line-life-value">5</span>
        </label>
      </div>

      <div class="control-row" data-mode="space">
        <label>
          <span>Space Speed:</span>
          <input
            type="range"
            id="space-speed"
            min="0.1"
            max="5"
            value="0.8"
            step="0.1"
          />
          <span class="value-display" id="space-speed-value">0.8</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Spin Strength:</span>
          <input
            type="range"
            id="spin-strength"
            min="0"
            max="0.05"
            value="0.01"
            step="0.001"
          />
          <span class="value-display" id="spin-strength-value">0.010</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Stretch Amt:</span>
          <input
            type="range"
            id="stretch-amount"
            min="0"
            max="1.0"
            value="0.0"
            step="0.01"
          />
          <span class="value-display" id="stretch-amount-value">0.00</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Emit Radius:</span>
          <input
            type="range"
            id="emanation-radius"
            min="0"
            max="100"
            value="30"
            step="1"
          />
          <span class="value-display" id="emanation-radius-value">30</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Twinkle:</span>
          <input
            type="range"
            id="twinkle-intensity"
            min="0"
            max="1"
            value="0.8"
            step="0.05"
          />
          <span class="value-display" id="twinkle-intensity-value">0.80</span>
        </label>
      </div>
    </div>

    <script>
      const svgNS = "http://www.w3.org/2000/svg";
      const particleContainer = document.getElementById("particle-container");
      const networkSvg = document.getElementById("network-svg");

      let particles = [];
      let lines = [];
      let width = window.innerWidth;
      let height = window.innerHeight;
      let animationId;
      let nextParticleId = 0;
      let currentMode = "network";

      let config = {
        mode: "network",
        numParticles: 64,
        maxLineDist: 100,
        connectionDensity: 0.1,
        vertexSpeed: 0.5,
        lineLifetime: 5000,
        spaceSpeed: 0.8,
        spinStrength: 0.01,
        stretchAmount: 0.0,
        emanationRadius: 30,
        twinkleIntensity: 0.8,
        minStarSize: 0.5,
        maxStarSize: 2.5,
        stretchFactorBase: 0.15,
      };

      function random(min, max) {
        return Math.random() * (max - min) + min;
      }
      function randomInt(min, max) {
        return Math.floor(random(min, max + 1));
      }

      function resizeHandler() {
        width = window.innerWidth;
        height = window.innerHeight;
        networkSvg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        particleContainer.style.width = `${width}px`;
        particleContainer.style.height = `${height}px`;
        particles.forEach((p) => {
          if (
            currentMode === "space" &&
            (p.x > width + 150 ||
              p.y > height + 150 ||
              p.x < -150 ||
              p.y < -150)
          ) {
            resetParticleForSpace(p);
          } else if (
            currentMode === "network" &&
            (p.x > width || p.y > height || p.x < 0 || p.y < 0)
          ) {
            p.x = Math.max(0, Math.min(width, p.x));
            p.y = Math.max(0, Math.min(height, p.y));
          }
        });
      }
      window.addEventListener("resize", resizeHandler);

      function createParticleElement(mode) {
        if (mode === "network") {
          const circle = document.createElementNS(svgNS, "circle");
          circle.setAttribute("r", 1.2);
          circle.style.opacity = 0;
          networkSvg.appendChild(circle);
          return circle;
        } else {
          const star = document.createElement("div");
          star.classList.add("particle-div");
          const size = random(config.minStarSize, config.maxStarSize);
          star.style.width = `${size}px`;
          star.style.height = `${size}px`;
          star.dataset.size = size;
          star.style.opacity = 0;
          particleContainer.appendChild(star);
          return star;
        }
      }

      function removeParticleElement(particle) {
        if (particle.el && particle.el.parentNode) {
          particle.el.remove();
        }
        particle.el = null;
      }

      function switchParticleElement(particle, newMode) {
        removeParticleElement(particle);
        particle.el = createParticleElement(newMode);
      }

      function initializeParticleState(particle, mode) {
        particle.id = nextParticleId++;
        particle.opacity = 0;
        particle.targetOpacity = mode === "network" ? 1 : random(0.4, 1);
        if (!particle.el) {
          particle.el = createParticleElement(mode);
        }

        if (mode === "network") {
          particle.x = random(0, width);
          particle.y = random(0, height);
          const angle = random(0, Math.PI * 2);
          const speed = random(
            0.1 * config.vertexSpeed,
            1.0 * config.vertexSpeed
          );
          particle.vx = Math.cos(angle) * speed;
          particle.vy = Math.sin(angle) * speed;
          particle.z = undefined;
        } else {
          const angle = random(0, Math.PI * 2);
          const radius = config.emanationRadius;
          particle.x = width / 2 + Math.cos(angle) * radius;
          particle.y = height / 2 + Math.sin(angle) * radius;
          particle.z = random(0.1, 1);
          particle.vx = undefined;
          particle.vy = undefined;
          if (particle.el && particle.el.tagName === "DIV") {
            const size = random(config.minStarSize, config.maxStarSize);
            particle.el.style.width = `${size}px`;
            particle.el.style.height = `${size}px`;
            particle.el.dataset.size = size;
            updateParticleTwinkle(particle);
          }
        }
        if (particle.el) particle.el.style.opacity = particle.opacity;
      }

      function resetParticleForSpace(particle) {
        const angle = random(0, Math.PI * 2);
        const radius = config.emanationRadius;
        particle.x = width / 2 + Math.cos(angle) * radius;
        particle.y = height / 2 + Math.sin(angle) * radius;
        particle.z = random(0.1, 1);
        particle.targetOpacity = random(0.4, 1);
        particle.opacity = 0;
        if (particle.el && particle.el.tagName === "DIV") {
          particle.el.style.opacity = 0;
          const size = random(config.minStarSize, config.maxStarSize);
          particle.el.style.width = `${size}px`;
          particle.el.style.height = `${size}px`;
          particle.el.dataset.size = size;
          particle.el.style.transform = `rotate(0deg) scaleX(1)`;
          updateParticleTwinkle(particle);
        }
      }

      function updateParticleNetwork(particle) {
        particle.x += particle.vx;
        particle.y += particle.vy;
        if (particle.x < 0 || particle.x > width) particle.vx *= -1;
        if (particle.y < 0 || particle.y > height) particle.vy *= -1;
        particle.x = Math.max(0, Math.min(width, particle.x));
        particle.y = Math.max(0, Math.min(height, particle.y));

        if (particle.opacity < particle.targetOpacity)
          particle.opacity = Math.min(
            particle.targetOpacity,
            particle.opacity + 0.05
          );
        else if (particle.opacity > particle.targetOpacity)
          particle.opacity = Math.max(
            particle.targetOpacity,
            particle.opacity - 0.05
          );

        particle.el.setAttribute("cx", particle.x);
        particle.el.setAttribute("cy", particle.y);
        particle.el.style.opacity = particle.opacity;
      }

      function updateParticleTwinkle(particle) {
        if (!particle.el || particle.el.tagName === "circle") return;
        const intensity = config.twinkleIntensity;
        const el = particle.el;

        if (intensity > 0) {
          if (!el.classList.contains("twinkle")) {
            el.classList.add("twinkle");
          }
          const duration = 2 + (1 - intensity) * 4;
          const minOpacity = 0.1 + intensity * 0.2;
          const maxOpacity = 0.6 + intensity * 0.4;
          el.style.animationDuration = `${random(
            duration * 0.8,
            duration * 1.2
          ).toFixed(2)}s`;
          el.style.setProperty("--twinkle-min-opacity", minOpacity.toFixed(2));
          el.style.setProperty("--twinkle-max-opacity", maxOpacity.toFixed(2));
          el.style.animationPlayState = "running";
          el.style.opacity = "";
          el.style.transform = "";
        } else {
          if (el.classList.contains("twinkle")) {
            el.classList.remove("twinkle");
            el.style.animation = "none";
          }
        }
      }

      function updateParticleSpace(particle) {
        const centerX = width / 2;
        const centerY = height / 2;
        let dx = particle.x - centerX;
        let dy = particle.y - centerY;
        const distFromCenter = Math.sqrt(dx * dx + dy * dy);
        const baseRadialSpeed = (1 / particle.z) * config.spaceSpeed * 4;
        const angle = Math.atan2(dy, dx);
        const angularSpeed = config.spinStrength * 50;

        const newAngle = angle + angularSpeed * 0.016; // Approx delta time
        const radialMoveDist = baseRadialSpeed;
        const nextX =
          centerX + (distFromCenter + radialMoveDist) * Math.cos(newAngle);
        const nextY =
          centerY + (distFromCenter + radialMoveDist) * Math.sin(newAngle);

        const moveX = nextX - particle.x;
        const moveY = nextY - particle.y;

        particle.x = nextX;
        particle.y = nextY;

        if (particle.opacity < particle.targetOpacity) {
          particle.opacity = Math.min(
            particle.targetOpacity,
            particle.opacity + 0.05
          );
        }

        const size = parseFloat(particle.el.dataset.size) || 1;
        particle.el.style.left = `${particle.x - size / 2}px`;
        particle.el.style.top = `${particle.y - size / 2}px`;

        updateParticleTwinkle(particle);

        if (config.twinkleIntensity === 0) {
          const speedMag = Math.sqrt(moveX * moveX + moveY * moveY);
          const baseStretch =
            1 + speedMag * config.stretchFactorBase * config.spaceSpeed;
          const stretchRandomness = random(0.8, 1.2); // Random factor +/- 20%
          const stretchFactor =
            config.stretchAmount === 0
              ? 1
              : Math.max(
                  1,
                  baseStretch * config.stretchAmount * stretchRandomness
                );
          const angleRad = Math.atan2(moveY, moveX);

          particle.el.style.transform = `rotate(${angleRad}rad) scaleX(${stretchFactor.toFixed(
            3
          )})`;
          particle.el.style.opacity = particle.opacity;
        }

        const border = 150;
        if (
          particle.x < -border ||
          particle.x > width + border ||
          particle.y < -border ||
          particle.y > height + border
        ) {
          resetParticleForSpace(particle);
        }
      }

      function calculateEffectiveMaxLineDist() {
        const referenceDimension = 800;
        const currentDimension = Math.sqrt(width * height);
        return config.maxLineDist * (currentDimension / referenceDimension);
      }

      function createLine(p1, p2) {
        const line = document.createElementNS(svgNS, "line");
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.style.opacity = 0;
        networkSvg.appendChild(line);
        return {
          el: line,
          p1,
          p2,
          opacity: 0,
          targetOpacity: 0.6,
          born: performance.now(),
          maxLifetime: config.lineLifetime + random(-500, 500),
        };
      }

      function updateLines(now) {
        const visibleParticles = particles.filter((p) => p.opacity > 0.1);
        const existingLineKeys = new Set(
          lines.map(
            (l) => `${Math.min(l.p1.id, l.p2.id)}-${Math.max(l.p1.id, l.p2.id)}`
          )
        );
        const effectiveMaxDist = calculateEffectiveMaxLineDist();

        for (let i = 0; i < visibleParticles.length; i++) {
          for (let j = i + 1; j < visibleParticles.length; j++) {
            const p1 = visibleParticles[i];
            const p2 = visibleParticles[j];
            const lineKey = `${Math.min(p1.id, p2.id)}-${Math.max(
              p1.id,
              p2.id
            )}`;
            if (existingLineKeys.has(lineKey)) continue;
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (
              dist < effectiveMaxDist &&
              Math.random() < config.connectionDensity
            ) {
              const newLine = createLine(p1, p2);
              lines.push(newLine);
              existingLineKeys.add(lineKey);
            }
          }
        }

        for (let i = lines.length - 1; i >= 0; i--) {
          const line = lines[i];
          const age = now - line.born;
          const fadeDuration = 500;

          if (age >= line.maxLifetime) {
            line.targetOpacity = 0;
          } else if (age >= line.maxLifetime - fadeDuration) {
            line.targetOpacity = Math.max(
              0,
              1 - (age - (line.maxLifetime - fadeDuration)) / fadeDuration
            );
          } else {
            line.targetOpacity = 0.5;
          }

          if (line.opacity < line.targetOpacity)
            line.opacity = Math.min(line.targetOpacity, line.opacity + 0.05);
          else if (line.opacity > line.targetOpacity)
            line.opacity = Math.max(line.targetOpacity, line.opacity - 0.03);

          if (line.opacity <= 0.01 && age >= line.maxLifetime) {
            if (line.el.parentNode) line.el.remove();
            lines.splice(i, 1);
          } else {
            if (line.p1 && line.p2) {
              line.el.setAttribute("x1", line.p1.x);
              line.el.setAttribute("y1", line.p1.y);
              line.el.setAttribute("x2", line.p2.x);
              line.el.setAttribute("y2", line.p2.y);
              line.el.style.opacity =
                line.opacity * Math.min(line.p1.opacity, line.p2.opacity);
            } else {
              line.el.style.opacity = 0;
            }
          }
        }
      }

      function manageParticles() {
        const targetCount = config.numParticles;

        while (particles.length < targetCount) {
          const newParticle = {};
          initializeParticleState(newParticle, currentMode);
          particles.push(newParticle);
        }
        while (particles.length > targetCount) {
          const removedParticle = particles.pop();
          removedParticle.targetOpacity = 0;
          setTimeout(() => removeParticleElement(removedParticle), 1000);
          if (currentMode === "network") {
            lines = lines.filter((line) => {
              if (line.p1 === removedParticle || line.p2 === removedParticle) {
                line.targetOpacity = 0;
              }
              return true;
            });
          }
        }

        if (currentMode === "network") {
          particles.forEach((p) => {
            if (p.vx === undefined || p.vy === undefined) {
              initializeParticleState(p, "network"); // Re-init if switching back
            }
            const speedMagnitude = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
            const desiredSpeed = random(
              0.1 * config.vertexSpeed,
              1.0 * config.vertexSpeed
            );
            if (speedMagnitude > 0) {
              const scale = desiredSpeed / speedMagnitude;
              p.vx *= scale;
              p.vy *= scale;
            } else {
              const angle = random(0, Math.PI * 2);
              p.vx = Math.cos(angle) * desiredSpeed;
              p.vy = Math.sin(angle) * desiredSpeed;
            }
          });
        } else {
          particles.forEach((p) => {
            if (p.z === undefined) {
              initializeParticleState(p, "space"); // Re-init if switching back
            }
            updateParticleTwinkle(p);
          });
        }
      }

      function animate(timestamp) {
        animationId = requestAnimationFrame(animate);
        const now = timestamp || performance.now();

        if (currentMode === "network") {
          particles.forEach((p) => updateParticleNetwork(p));
          updateLines(now);
        } else if (currentMode === "space") {
          particles.forEach((p) => updateParticleSpace(p));
        }
      }

      function setMode(newMode) {
        if (newMode === currentMode) return;
        currentMode = newMode;
        config.mode = newMode;

        particles.forEach((p) => {
          switchParticleElement(p, newMode);
          initializeParticleState(p, newMode);
        });

        lines.forEach((l) => {
          if (l.el.parentNode) l.el.remove();
        });
        lines = [];
        networkSvg.innerHTML = "";

        manageParticles();
        updateControlVisibility();

        if (!animationId) {
          animationId = requestAnimationFrame(animate);
        }
      }

      function updateControlVisibility() {
        document
          .querySelectorAll(".controls .control-row[data-mode]")
          .forEach((row) => {
            const modes = row.dataset.mode.split(" ");
            if (modes.includes(currentMode)) {
              row.classList.add("visible");
            } else {
              row.classList.remove("visible");
            }
          });
        networkSvg.style.display = currentMode === "network" ? "block" : "none";
      }

      function setupControls() {
        const controlsMap = {
          "num-particles": {
            key: "numParticles",
            valueId: "num-particles-value",
            callback: manageParticles,
            mode: "network space",
          },
          "max-line-dist": {
            key: "maxLineDist",
            valueId: "max-line-dist-value",
            mode: "network",
          },
          "connection-density": {
            key: "connectionDensity",
            valueId: "connection-density-value",
            fixed: 2,
            mode: "network",
          },
          "vertex-speed": {
            key: "vertexSpeed",
            valueId: "vertex-speed-value",
            fixed: 1,
            mode: "network",
          },
          "line-life": {
            key: "lineLifetime",
            valueId: "line-life-value",
            multiplier: 1000,
            mode: "network",
          },
          "space-speed": {
            key: "spaceSpeed",
            valueId: "space-speed-value",
            fixed: 1,
            mode: "space",
          },
          "spin-strength": {
            key: "spinStrength",
            valueId: "spin-strength-value",
            fixed: 3,
            mode: "space",
          },
          "stretch-amount": {
            key: "stretchAmount",
            valueId: "stretch-amount-value",
            fixed: 2,
            mode: "space",
          },
          "emanation-radius": {
            key: "emanationRadius",
            valueId: "emanation-radius-value",
            mode: "space",
          },
          "twinkle-intensity": {
            key: "twinkleIntensity",
            valueId: "twinkle-intensity-value",
            fixed: 2,
            callback: manageParticles,
            mode: "space",
          },
        };

        Object.entries(controlsMap).forEach(([id, control]) => {
          const element = document.getElementById(id);
          if (!element) return;
          const valueElement = document.getElementById(control.valueId);
          const initialConfigValue = config[control.key];
          const displayValue = control.multiplier
            ? initialConfigValue / control.multiplier
            : initialConfigValue;

          element.value = displayValue;
          if (valueElement)
            valueElement.textContent =
              control.fixed !== undefined
                ? displayValue.toFixed(control.fixed)
                : displayValue;

          element.addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            const configValue = control.multiplier
              ? value * control.multiplier
              : value;
            config[control.key] = configValue;

            if (valueElement)
              valueElement.textContent =
                control.fixed !== undefined
                  ? value.toFixed(control.fixed)
                  : value;

            if (id === "num-particles") {
              config.numParticles = parseInt(value);
              if (control.callback) control.callback();
            } else if (control.callback) {
              control.callback();
            }
          });
        });

        document
          .querySelectorAll('.mode-selector input[name="mode"]')
          .forEach((radio) => {
            radio.addEventListener("change", (e) => {
              setMode(e.target.value);
            });
          });
      }

      function init() {
        setupControls();
        resizeHandler();
        setMode(config.mode);
        manageParticles();
        updateControlVisibility();
        if (!animationId) {
          animationId = requestAnimationFrame(animate);
        }
      }

      init();
    </script>
  </body>
</html>
