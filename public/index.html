<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Simulatte</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      html,
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        color: #fff;
        font-family: monospace;
        text-align: center;
        height: 100vh;
        width: 100vw;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        position: relative;
      }
      .title {
        z-index: 10;
        pointer-events: none;
        font-size: 20px;
        letter-spacing: 3px;
      }
      .content {
        z-index: 10;
        pointer-events: none;
        font-size: 16px;
      }
      p {
        margin: 0.6em 0;
        user-select: none;
      }
      .content a {
        color: #f0f;
        text-decoration: none;
        pointer-events: auto;
      }
      .content a:hover {
        text-decoration: underline;
      }
      #particle-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
        z-index: 1;
      }
      #particle-container svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
      }
      #particle-container line {
        stroke: rgba(255, 255, 255, 0.5);
        stroke-width: 0.5;
        transition: opacity 0.5s ease-out;
      }
      #particle-container circle {
        fill: rgba(255, 255, 255, 0.8);
        transition: opacity 0.5s ease-out, r 0.1s linear;
        transform-origin: center center;
      }
      .particle-div {
        position: absolute;
        background-color: white;
        border-radius: 50%;
        transition: opacity 0.5s linear;
        transform-origin: center center;
        will-change: transform, opacity, left, top, width, height;
      }
      @keyframes twinkle-anim {
        0%,
        100% {
          opacity: var(--twinkle-min-opacity, 0.3);
          transform: scale(0.8);
        }
        50% {
          opacity: var(--twinkle-max-opacity, 1);
          transform: scale(1.2);
        }
      }
      .twinkle {
        animation-name: twinkle-anim;
        animation-timing-function: linear;
        animation-iteration-count: infinite;
        animation-direction: alternate;
      }
      .controls {
        position: fixed;
        top: 16px;
        right: 16px;
        left: auto;
        width: 320px;
        background: rgba(0, 0, 0, 0.4);
        padding: 12px 16px;
        box-sizing: border-box;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 16px;
        border: 1px solid #555;
        border-radius: 4px;
      }
      .mode-selector {
        display: flex;
        justify-content: center;
        border: 1px solid #0a0;
        border-radius: 4px;
        overflow: hidden;
      }
      .controls .mode-selector label {
        flex-grow: 1;
        text-align: center;
        padding: 5px 0;
        font-size: 12px;
        cursor: pointer;
        background-color: #111;
        color: #ccc;
        transition: background-color 0.2s, color 0.2s;
        user-select: none;
        justify-content: center;
      }
      .mode-selector input[type="radio"] {
        display: none;
      }
      .mode-selector input[type="radio"]:checked + label {
        background-color: #0a0;
        color: #fff;
        font-weight: bold;
      }
      .mode-selector label:not(:last-child) {
        border-right: 1px solid #0a0;
      }
      .control-row {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        gap: 8px;
      }
      .control-row[data-mode]:not(.visible) {
        display: none;
      }
      .controls label {
        font-size: 12px;
        color: #eee;
        display: flex;
        align-items: center;
        gap: 4px;
        white-space: nowrap;
        flex-grow: 1;
        justify-content: flex-end;
      }
      .controls label > span:first-child {
        margin-right: auto;
        flex-shrink: 0;
      }
      .controls input[type="range"] {
        width: 100px;
        height: 6px;
        vertical-align: middle;
        cursor: pointer;
        accent-color: #0f0;
        background: #333;
        border-radius: 3px;
        appearance: none;
        -webkit-appearance: none;
        outline: none;
        flex-grow: 1;
        min-width: 50px;
      }
      .controls input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 12px;
        height: 12px;
        background: #eee;
        border-radius: 50%;
        cursor: pointer;
      }
      .controls input[type="range"]::-moz-range-thumb {
        width: 12px;
        height: 12px;
        background: #eee;
        border-radius: 50%;
        cursor: pointer;
        border: none;
      }
      .controls .value-display {
        min-width: 35px;
        display: inline-block;
        text-align: right;
        color: #fff;
        font-size: 12px;
        font-weight: bold;
        flex-shrink: 0;
      }
    </style>
  </head>
  <body>
    <div id="particle-container">
      <svg id="network-svg"></svg>
    </div>

    <div class="content">
      <p class="title">SIMULATTE</p>
      <br />
      <p>an n-gram and anagram collective</p>
      <p>created for mages who like games</p>
      <br />
      <br />
      <p>
        <sub>some</sub>d<sup>emos</sup>\
        <a href="/4">d<sup>4</sup></a>
        <a href="/2">d<sup>2</sup></a>
        <a href="/0">d<sup>0</sup></a>
      </p>
    </div>

    <div class="controls">
      <div class="mode-selector">
        <input
          type="radio"
          name="mode"
          id="mode-network"
          value="network"
          checked
        />
        <label for="mode-network">Network</label>
        <input type="radio" name="mode" id="mode-space" value="space" />
        <label for="mode-space">Space</label>
      </div>

      <div class="control-row" data-mode="network space">
        <label>
          <span>Particles:</span>
          <input
            type="range"
            id="num-particles"
            min="10"
            max="1000"
            value="64"
            step="1"
          />
          <span class="value-display" id="num-particles-value">64</span>
        </label>
      </div>

      <div class="control-row" data-mode="network">
        <label>
          <span>Connect Dist:</span>
          <input
            type="range"
            id="max-line-dist"
            min="20"
            max="300"
            value="100"
            step="5"
          />
          <span class="value-display" id="max-line-dist-value">100</span>
        </label>
      </div>
      <div class="control-row" data-mode="network">
        <label>
          <span>Density:</span>
          <input
            type="range"
            id="connection-density"
            min="0.01"
            max="0.5"
            value="0.1"
            step="0.01"
          />
          <span class="value-display" id="connection-density-value">0.10</span>
        </label>
      </div>
      <div class="control-row" data-mode="network">
        <label>
          <span>Net Speed:</span>
          <input
            type="range"
            id="vertex-speed"
            min="0.1"
            max="2.0"
            value="0.5"
            step="0.1"
          />
          <span class="value-display" id="vertex-speed-value">0.5</span>
        </label>
      </div>
      <div class="control-row" data-mode="network">
        <label>
          <span>Net Twinkle:</span>
          <input
            type="range"
            id="network-twinkle"
            min="0"
            max="1"
            value="0.0"
            step="0.05"
          />
          <span class="value-display" id="network-twinkle-value">0.00</span>
        </label>
      </div>
      <div class="control-row" data-mode="network">
        <label>
          <span>Line Life (s):</span>
          <input
            type="range"
            id="line-life"
            min="1"
            max="15"
            value="5"
            step="1"
          />
          <span class="value-display" id="line-life-value">5</span>
        </label>
      </div>

      <div class="control-row" data-mode="space">
        <label>
          <span>Space Speed:</span>
          <input
            type="range"
            id="space-speed"
            min="0.1"
            max="5"
            value="0.8"
            step="0.1"
          />
          <span class="value-display" id="space-speed-value">0.8</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Spin Strength:</span>
          <input
            type="range"
            id="spin-strength"
            min="0"
            max="0.05"
            value="0.01"
            step="0.001"
          />
          <span class="value-display" id="spin-strength-value">0.010</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Stretch Amt:</span>
          <input
            type="range"
            id="stretch-amount"
            min="0"
            max="1.0"
            value="0.0"
            step="0.01"
          />
          <span class="value-display" id="stretch-amount-value">0.00</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Emit Radius:</span>
          <input
            type="range"
            id="emanation-radius"
            min="0"
            max="100"
            value="30"
            step="1"
          />
          <span class="value-display" id="emanation-radius-value">30</span>
        </label>
      </div>
      <div class="control-row" data-mode="space">
        <label>
          <span>Space Twinkle:</span>
          <input
            type="range"
            id="twinkle-intensity"
            min="0"
            max="1"
            value="0.8"
            step="0.05"
          />
          <span class="value-display" id="twinkle-intensity-value">0.80</span>
        </label>
      </div>
    </div>

    <script>
      const svgNS = "http://www.w3.org/2000/svg";
      const particleContainer = document.getElementById("particle-container");
      const networkSvg = document.getElementById("network-svg");

      let particles = [];
      let lines = [];
      let width = window.innerWidth;
      let height = window.innerHeight;
      let animationId;
      let nextParticleId = 0;
      let currentMode = "network";
      let transitioningTo = null;
      let transitionStartTime = 0;
      const transitionDuration = 2000;

      let config = {
        mode: "network",
        numParticles: 64,
        maxLineDist: 100,
        connectionDensity: 0.1,
        vertexSpeed: 0.5,
        networkTwinkle: 0.0,
        lineLifetime: 5000,
        spaceSpeed: 0.8,
        spinStrength: 0.01,
        stretchAmount: 0.0,
        emanationRadius: 30,
        spaceTwinkleIntensity: 0.8,
        minStarSize: 0.5,
        maxStarSize: 2.5,
        stretchFactorBase: 0.15,
        baseCircleRadius: 1.2,
      };

      function random(min, max) {
        return Math.random() * (max - min) + min;
      }
      function randomInt(min, max) {
        return Math.floor(random(min, max + 1));
      }

      function resizeHandler() {
        width = window.innerWidth;
        height = window.innerHeight;
        networkSvg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        particleContainer.style.width = `${width}px`;
        particleContainer.style.height = `${height}px`;
        particles.forEach((p) => {
          if (
            (currentMode === "space" || transitioningTo === "space") &&
            (p.x > width + 150 ||
              p.y > height + 150 ||
              p.x < -150 ||
              p.y < -150)
          ) {
            resetParticleForSpace(p);
          } else if (
            (currentMode === "network" || transitioningTo === "network") &&
            (p.x > width || p.y > height || p.x < 0 || p.y < 0)
          ) {
            p.x = Math.max(0, Math.min(width, p.x));
            p.y = Math.max(0, Math.min(height, p.y));
            if (p.vx !== undefined) {
              if (p.x <= 0 || p.x >= width) p.vx *= -1;
              if (p.y <= 0 || p.y >= height) p.vy *= -1;
            }
          }
        });
      }
      window.addEventListener("resize", resizeHandler);

      function createParticleElement(type) {
        if (type === "circle") {
          const el = document.createElementNS(svgNS, "circle");
          el.setAttribute("r", config.baseCircleRadius);
          el.style.opacity = 0;
          networkSvg.appendChild(el);
          return el;
        } else {
          // div
          const el = document.createElement("div");
          el.classList.add("particle-div");
          const size = random(config.minStarSize, config.maxStarSize);
          el.style.width = `${size}px`;
          el.style.height = `${size}px`;
          el.dataset.size = size;
          el.style.opacity = 0;
          particleContainer.appendChild(el);
          return el;
        }
      }

      function ensureElement(particle, type) {
        if (
          !particle.el ||
          (type === "circle" && particle.el.tagName !== "circle") ||
          (type === "div" && particle.el.tagName !== "DIV")
        ) {
          if (particle.el && particle.el.parentNode) {
            particle.el.remove();
          }
          particle.el = createParticleElement(type);
        }
        return particle.el;
      }

      function initializeParticleState(particle, mode) {
        particle.id = particle.id ?? nextParticleId++;
        particle.transitionProgress = 0;
        particle.mode = mode;

        const isNetwork = mode === "network";
        ensureElement(particle, isNetwork ? "circle" : "div");

        particle.targetOpacity = isNetwork ? 1 : random(0.4, 1);

        if (isNetwork) {
          particle.x = particle.x ?? random(0, width);
          particle.y = particle.y ?? random(0, height);
          const angle = random(0, Math.PI * 2);
          const speed = random(
            0.1 * config.vertexSpeed,
            1.0 * config.vertexSpeed
          );
          particle.vx = Math.cos(angle) * speed;
          particle.vy = Math.sin(angle) * speed;
          particle.z = undefined;
          particle.twinklePhase = random(0, PI * 2);
        } else {
          const angle = random(0, Math.PI * 2);
          const radius =
            config.emanationRadius === 0
              ? random(0, 5)
              : config.emanationRadius;
          particle.x = particle.x ?? width / 2 + Math.cos(angle) * radius;
          particle.y = particle.y ?? height / 2 + Math.sin(angle) * radius;
          particle.z = particle.z ?? random(0.1, 1);
          particle.vx = undefined;
          particle.vy = undefined;
          if (particle.el && particle.el.tagName === "DIV") {
            const size =
              parseFloat(particle.el.dataset.size) ||
              random(config.minStarSize, config.maxStarSize);
            particle.el.style.width = `${size}px`;
            particle.el.style.height = `${size}px`;
            particle.el.dataset.size = size;
            updateParticleTwinkle(particle);
          }
        }
        particle.opacity = particle.opacity ?? 0;
        if (particle.el) particle.el.style.opacity = particle.opacity;
      }

      function resetParticleForSpace(particle) {
        const angle = random(0, Math.PI * 2);
        const radius =
          config.emanationRadius === 0 ? random(0, 5) : config.emanationRadius;
        particle.x = width / 2 + Math.cos(angle) * radius;
        particle.y = height / 2 + Math.sin(angle) * radius;
        particle.z = random(0.1, 1);
        particle.targetOpacity = random(0.4, 1);
        particle.opacity = 0;
        if (particle.el && particle.el.tagName === "DIV") {
          particle.el.style.opacity = 0;
          const size = random(config.minStarSize, config.maxStarSize);
          particle.el.style.width = `${size}px`;
          particle.el.style.height = `${size}px`;
          particle.el.dataset.size = size;
          particle.el.style.transform = `rotate(0deg) scaleX(1)`;
          updateParticleTwinkle(particle);
        }
      }

      function updateParticleNetwork(particle, now) {
        particle.x += particle.vx;
        particle.y += particle.vy;
        if (particle.x <= 0 || particle.x >= width) particle.vx *= -1;
        if (particle.y <= 0 || particle.y >= height) particle.vy *= -1;
        particle.x = Math.max(0, Math.min(width, particle.x));
        particle.y = Math.max(0, Math.min(height, particle.y));

        if (particle.opacity < particle.targetOpacity)
          particle.opacity = Math.min(
            particle.targetOpacity,
            particle.opacity + 0.05
          );
        else if (particle.opacity > particle.targetOpacity)
          particle.opacity = Math.max(
            particle.targetOpacity,
            particle.opacity - 0.05
          );

        ensureElement(particle, "circle");
        particle.el.setAttribute("cx", particle.x);
        particle.el.setAttribute("cy", particle.y);

        if (config.networkTwinkle > 0) {
          const twinkleAmount = config.networkTwinkle;
          particle.twinklePhase += 0.05 + random(0, 0.05);
          const baseOpacity = particle.opacity * (0.6 + twinkleAmount * 0.4);
          const phaseOpacity = Math.sin(particle.twinklePhase) * 0.5 + 0.5;
          const finalOpacity =
            baseOpacity * (1.0 - twinkleAmount) +
            baseOpacity * twinkleAmount * phaseOpacity;
          particle.el.style.opacity = finalOpacity.toFixed(3);

          const baseRadius = config.baseCircleRadius;
          const scaleFactor = 1.0 + (phaseOpacity - 0.5) * 0.4 * twinkleAmount;
          particle.el.setAttribute("r", (baseRadius * scaleFactor).toFixed(2));
        } else {
          particle.el.style.opacity = particle.opacity.toFixed(3);
          particle.el.setAttribute("r", config.baseCircleRadius);
        }
      }

      function updateParticleTwinkle(particle) {
        if (!particle.el || particle.el.tagName === "circle") return;
        const intensity = config.spaceTwinkleIntensity;
        const el = particle.el;

        if (intensity > 0) {
          if (!el.classList.contains("twinkle")) {
            el.classList.add("twinkle");
          }
          const duration = 2 + (1 - intensity) * 4;
          const minOpacity = 0.1 + intensity * 0.2;
          const maxOpacity = 0.6 + intensity * 0.4;
          el.style.animationDuration = `${random(
            duration * 0.8,
            duration * 1.2
          ).toFixed(2)}s`;
          el.style.setProperty("--twinkle-min-opacity", minOpacity.toFixed(2));
          el.style.setProperty("--twinkle-max-opacity", maxOpacity.toFixed(2));
          el.style.animationPlayState = "running";
          el.style.opacity = "";
          el.style.transform = "";
        } else {
          if (el.classList.contains("twinkle")) {
            el.classList.remove("twinkle");
            el.style.animation = "none";
          }
        }
      }

      function updateParticleSpace(particle, now) {
        const centerX = width / 2;
        const centerY = height / 2;
        let dx = particle.x - centerX;
        let dy = particle.y - centerY;
        const distFromCenter = Math.sqrt(dx * dx + dy * dy);
        const baseRadialSpeed = (1 / particle.z) * config.spaceSpeed * 4;
        const angle = Math.atan2(dy, dx);
        const angularSpeed = config.spinStrength * 50;

        const newAngle = angle + angularSpeed * 0.016;
        const radialMoveDist = baseRadialSpeed;
        const nextX =
          centerX + (distFromCenter + radialMoveDist) * Math.cos(newAngle);
        const nextY =
          centerY + (distFromCenter + radialMoveDist) * Math.sin(newAngle);

        const moveX = nextX - particle.x;
        const moveY = nextY - particle.y;

        particle.x = nextX;
        particle.y = nextY;

        if (particle.opacity < particle.targetOpacity) {
          particle.opacity = Math.min(
            particle.targetOpacity,
            particle.opacity + 0.05
          );
        }

        ensureElement(particle, "div");
        const size = parseFloat(particle.el.dataset.size) || 1;
        particle.el.style.left = `${particle.x - size / 2}px`;
        particle.el.style.top = `${particle.y - size / 2}px`;

        updateParticleTwinkle(particle);

        if (config.spaceTwinkleIntensity === 0) {
          const speedMag = Math.sqrt(moveX * moveX + moveY * moveY);
          const baseStretch =
            1 + speedMag * config.stretchFactorBase * config.spaceSpeed;
          const stretchRandomness = random(0.8, 1.2);
          const stretchFactor =
            config.stretchAmount === 0
              ? 1
              : Math.max(
                  1,
                  baseStretch * config.stretchAmount * stretchRandomness
                );
          const angleRad = Math.atan2(moveY, moveX);

          particle.el.style.transform = `rotate(${angleRad}rad) scaleX(${stretchFactor.toFixed(
            3
          )})`;
          particle.el.style.opacity = particle.opacity.toFixed(3);
        }

        const border = 150;
        if (
          particle.x < -border ||
          particle.x > width + border ||
          particle.y < -border ||
          particle.y > height + border
        ) {
          resetParticleForSpace(particle);
        }
      }

      function updateParticleTransition(particle, now, progress) {
        const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
        const targetMode = transitioningTo;
        const sourceMode = targetMode === "network" ? "space" : "network";

        ensureElement(particle, targetMode === "network" ? "circle" : "div");

        let targetX, targetY;
        if (targetMode === "network") {
          targetX = particle.x + particle.vx * (1.0 - easedProgress);
          targetY = particle.y + particle.vy * (1.0 - easedProgress);
        } else {
          const centerX = width / 2;
          const centerY = height / 2;
          const angle = Math.atan2(particle.y - centerY, particle.x - centerX);
          const radius =
            config.emanationRadius === 0
              ? random(0, 5)
              : config.emanationRadius;
          const startX = centerX + Math.cos(angle) * radius;
          const startY = centerY + Math.sin(angle) * radius;
          targetX = particle.x * (1.0 - easedProgress) + startX * easedProgress;
          targetY = particle.y * (1.0 - easedProgress) + startY * easedProgress;
        }

        particle.x = targetX;
        particle.y = targetY;
        particle.opacity = particle.targetOpacity * easedProgress;

        if (particle.el) {
          if (particle.el.tagName === "circle") {
            particle.el.setAttribute("cx", particle.x);
            particle.el.setAttribute("cy", particle.y);
            particle.el.style.opacity = particle.opacity.toFixed(3);
          } else {
            const size = parseFloat(particle.el.dataset.size) || 1;
            particle.el.style.left = `${particle.x - size / 2}px`;
            particle.el.style.top = `${particle.y - size / 2}px`;
            particle.el.style.opacity = particle.opacity.toFixed(3);
            particle.el.style.transform = "";
            if (particle.el.classList.contains("twinkle")) {
              particle.el.style.animation = "none";
              particle.el.classList.remove("twinkle");
            }
          }
        }
      }

      function calculateEffectiveMaxLineDist() {
        const referenceDimension = 800;
        const currentDimension = Math.sqrt(width * height);
        return config.maxLineDist * (currentDimension / referenceDimension);
      }

      function createLine(p1, p2) {
        const line = document.createElementNS(svgNS, "line");
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.style.opacity = 0;
        networkSvg.appendChild(line);
        return {
          el: line,
          p1,
          p2,
          opacity: 0,
          targetOpacity: 0.6,
          born: performance.now(),
          maxLifetime: config.lineLifetime + random(-500, 500),
        };
      }

      function updateLines(now, transitionProgress = 1) {
        const visibleParticles = particles.filter((p) => p.opacity > 0.1);
        const existingLineKeys = new Set(
          lines.map(
            (l) => `${Math.min(l.p1.id, l.p2.id)}-${Math.max(l.p1.id, l.p2.id)}`
          )
        );
        const effectiveMaxDist = calculateEffectiveMaxLineDist();

        if (transitionProgress === 1) {
          for (let i = 0; i < visibleParticles.length; i++) {
            for (let j = i + 1; j < visibleParticles.length; j++) {
              const p1 = visibleParticles[i];
              const p2 = visibleParticles[j];
              const lineKey = `${Math.min(p1.id, p2.id)}-${Math.max(
                p1.id,
                p2.id
              )}`;
              if (existingLineKeys.has(lineKey)) continue;
              const dx = p1.x - p2.x;
              const dy = p1.y - p2.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (
                dist < effectiveMaxDist &&
                Math.random() < config.connectionDensity
              ) {
                const newLine = createLine(p1, p2);
                lines.push(newLine);
                existingLineKeys.add(lineKey);
              }
            }
          }
        }

        for (let i = lines.length - 1; i >= 0; i--) {
          const line = lines[i];
          const age = now - line.born;
          const fadeDuration = 500;

          if (transitionProgress < 1) {
            line.targetOpacity = 0; // Fade out lines during transition away from network
          } else if (age >= line.maxLifetime) {
            line.targetOpacity = 0;
          } else if (age >= line.maxLifetime - fadeDuration) {
            line.targetOpacity = Math.max(
              0,
              1 - (age - (line.maxLifetime - fadeDuration)) / fadeDuration
            );
          } else {
            line.targetOpacity = 0.5;
          }

          if (line.opacity < line.targetOpacity)
            line.opacity = Math.min(line.targetOpacity, line.opacity + 0.05);
          else if (line.opacity > line.targetOpacity)
            line.opacity = Math.max(line.targetOpacity, line.opacity - 0.03);

          if (
            line.opacity <= 0.01 &&
            (age >= line.maxLifetime || transitionProgress < 1)
          ) {
            if (line.el.parentNode) line.el.remove();
            lines.splice(i, 1);
          } else {
            if (line.p1 && line.p2) {
              line.el.setAttribute("x1", line.p1.x);
              line.el.setAttribute("y1", line.p1.y);
              line.el.setAttribute("x2", line.p2.x);
              line.el.setAttribute("y2", line.p2.y);
              line.el.style.opacity =
                line.opacity * Math.min(line.p1.opacity, line.p2.opacity);
            } else {
              line.el.style.opacity = 0;
            }
          }
        }
      }

      function manageParticles() {
        const targetCount = config.numParticles;

        while (particles.length < targetCount) {
          const newParticle = {};
          initializeParticleState(newParticle, currentMode);
          particles.push(newParticle);
        }
        while (particles.length > targetCount) {
          const removedParticle = particles.pop();
          removeParticleElement(removedParticle);
          lines = lines.filter(
            (line) => line.p1 !== removedParticle && line.p2 !== removedParticle
          );
        }

        if (currentMode === "network") {
          particles.forEach((p) => {
            if (p.vx === undefined || p.vy === undefined) {
              initializeParticleState(p, "network");
            }
            const speedMagnitude = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
            const desiredSpeed = random(
              0.1 * config.vertexSpeed,
              1.0 * config.vertexSpeed
            );
            if (speedMagnitude > 0) {
              const scale = desiredSpeed / speedMagnitude;
              p.vx *= scale;
              p.vy *= scale;
            } else {
              const angle = random(0, Math.PI * 2);
              p.vx = Math.cos(angle) * desiredSpeed;
              p.vy = Math.sin(angle) * desiredSpeed;
            }
          });
        } else {
          particles.forEach((p) => {
            if (p.z === undefined) {
              initializeParticleState(p, "space");
            }
            updateParticleTwinkle(p);
          });
        }
      }

      function animate(timestamp) {
        animationId = requestAnimationFrame(animate);
        const now = timestamp || performance.now();

        if (transitioningTo) {
          const elapsed = now - transitionStartTime;
          const progress = Math.min(1, elapsed / transitionDuration);

          particles.forEach((p) => updateParticleTransition(p, now, progress));
          updateLines(
            now,
            transitioningTo === "network" ? progress : 1 - progress
          );

          if (progress >= 1) {
            currentMode = transitioningTo;
            transitioningTo = null;
            particles.forEach((p) => {
              p.mode = currentMode;
              p.opacity = p.targetOpacity;
              if (p.mode === "space") updateParticleTwinkle(p);
            });
            manageParticles();
            updateControlVisibility();
          }
        } else {
          if (currentMode === "network") {
            particles.forEach((p) => updateParticleNetwork(p, now));
            updateLines(now);
          } else if (currentMode === "space") {
            particles.forEach((p) => updateParticleSpace(p, now));
          }
        }
      }

      function setMode(newMode) {
        if (newMode === currentMode || transitioningTo) return;

        transitioningTo = newMode;
        transitionStartTime = performance.now();
        config.mode = newMode;

        particles.forEach((p) => {
          if (newMode === "network") {
            p.targetOpacity = 1;
            if (p.vx === undefined) initializeParticleState(p, "network");
          } else {
            p.targetOpacity = random(0.4, 1);
            if (p.z === undefined) initializeParticleState(p, "space");
          }
        });

        updateControlVisibility();

        if (!animationId) {
          animationId = requestAnimationFrame(animate);
        }
      }

      function updateControlVisibility() {
        document
          .querySelectorAll(".controls .control-row[data-mode]")
          .forEach((row) => {
            const modes = row.dataset.mode.split(" ");
            const targetMode = transitioningTo || currentMode;
            if (modes.includes(targetMode)) {
              row.classList.add("visible");
            } else {
              row.classList.remove("visible");
            }
          });
        networkSvg.style.display =
          currentMode === "network" || transitioningTo === "network"
            ? "block"
            : "none";
      }

      function setupControls() {
        const controlsMap = {
          "num-particles": {
            key: "numParticles",
            valueId: "num-particles-value",
            callback: manageParticles,
            mode: "network space",
          },
          "max-line-dist": {
            key: "maxLineDist",
            valueId: "max-line-dist-value",
            mode: "network",
          },
          "connection-density": {
            key: "connectionDensity",
            valueId: "connection-density-value",
            fixed: 2,
            mode: "network",
          },
          "vertex-speed": {
            key: "vertexSpeed",
            valueId: "vertex-speed-value",
            fixed: 1,
            mode: "network",
          },
          "network-twinkle": {
            key: "networkTwinkle",
            valueId: "network-twinkle-value",
            fixed: 2,
            mode: "network",
          },
          "line-life": {
            key: "lineLifetime",
            valueId: "line-life-value",
            multiplier: 1000,
            mode: "network",
          },
          "space-speed": {
            key: "spaceSpeed",
            valueId: "space-speed-value",
            fixed: 1,
            mode: "space",
          },
          "spin-strength": {
            key: "spinStrength",
            valueId: "spin-strength-value",
            fixed: 3,
            mode: "space",
          },
          "stretch-amount": {
            key: "stretchAmount",
            valueId: "stretch-amount-value",
            fixed: 2,
            mode: "space",
          },
          "emanation-radius": {
            key: "emanationRadius",
            valueId: "emanation-radius-value",
            mode: "space",
          },
          "twinkle-intensity": {
            key: "spaceTwinkleIntensity",
            valueId: "twinkle-intensity-value",
            fixed: 2,
            callback: manageParticles,
            mode: "space",
          },
        };

        Object.entries(controlsMap).forEach(([id, control]) => {
          const element = document.getElementById(id);
          if (!element) return;
          const valueElement = document.getElementById(control.valueId);
          const initialConfigValue = config[control.key];
          const displayValue = control.multiplier
            ? initialConfigValue / control.multiplier
            : initialConfigValue;

          element.value = displayValue;
          if (valueElement)
            valueElement.textContent =
              control.fixed !== undefined
                ? displayValue.toFixed(control.fixed)
                : displayValue;

          element.addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            const configValue = control.multiplier
              ? value * control.multiplier
              : value;
            config[control.key] = configValue;

            if (valueElement)
              valueElement.textContent =
                control.fixed !== undefined
                  ? value.toFixed(control.fixed)
                  : value;

            if (id === "num-particles") {
              config.numParticles = parseInt(value);
              if (control.callback) control.callback();
            } else if (control.callback) {
              control.callback();
            }
          });
        });

        document
          .querySelectorAll('.mode-selector input[name="mode"]')
          .forEach((radio) => {
            radio.addEventListener("change", (e) => {
              setMode(e.target.value);
            });
          });
      }

      function init() {
        setupControls();
        resizeHandler();
        currentMode = config.mode;
        document.getElementById(`mode-${currentMode}`).checked = true;
        manageParticles();
        updateControlVisibility();
        if (!animationId) {
          animationId = requestAnimationFrame(animate);
        }
      }

      init();
    </script>
  </body>
</html>
