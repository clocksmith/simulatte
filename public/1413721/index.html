<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TPU - Toroidal Processing Unit Simulator</title>
  <meta name="description" content="Google TPU architecture simulator with 2D/3D/Twisted torus topologies and realistic bandwidth/compute metrics">
  <style>
    :root {
      --bg-dark: #000000;
      --bg-medium: #0f0f0f;
      --bg-light: #1a1a1a;
      --text-primary: #ffffff;
      --text-secondary: #a0a0a0;
      --accent-magenta: #9966cc;
      --accent-green: #66bb66;
      --accent-cyan: #66cccc;
      --accent-orange: #ff9933;
      --accent-red: #ff4444;
      --border: #555555;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      background: var(--bg-dark);
      color: var(--text-primary);
      padding: 20px;
      overflow-x: hidden;
    }

    .container {
      max-width: 1800px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 20px;
      padding: 20px;
      background: var(--bg-medium);
      border: 1px solid var(--border);
      border-radius: 8px;
    }

    h1 {
      color: var(--accent-magenta);
      margin-bottom: 8px;
      font-size: 2rem;
      letter-spacing: -1px;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }

    .mode-selector {
      background: var(--bg-medium);
      border: 1px solid var(--accent-cyan);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }

    .mode-selector h3 {
      color: var(--accent-cyan);
      margin-bottom: 10px;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .mode-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .mode-btn {
      flex: 1;
      min-width: 150px;
      padding: 10px 15px;
      background: var(--bg-light);
      border: 2px solid var(--border);
      color: var(--text-secondary);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.85rem;
      font-weight: bold;
    }

    .mode-btn:hover {
      border-color: var(--accent-magenta);
      color: var(--text-primary);
    }

    .mode-btn.active {
      background: var(--accent-magenta);
      border-color: var(--accent-magenta);
      color: #000;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .visualization-panel {
      background: var(--bg-medium);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px;
    }

    .visualization-panel h2 {
      color: var(--accent-green);
      margin-bottom: 10px;
      font-size: 1.1rem;
      text-align: center;
    }

    .viz-description {
      color: var(--text-secondary);
      font-size: 0.75rem;
      margin-bottom: 15px;
      text-align: center;
      line-height: 1.5;
    }

    canvas {
      display: block;
      width: 100%;
      height: 600px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-dark);
      cursor: crosshair;
    }

    .metrics-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .metric-group {
      background: var(--bg-medium);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 15px;
    }

    .metric-group h3 {
      color: var(--accent-orange);
      margin-bottom: 10px;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 0.8rem;
    }

    .metric-label {
      color: var(--text-secondary);
    }

    .metric-value {
      color: var(--accent-green);
      font-weight: bold;
      font-family: 'SF Mono', monospace;
    }

    .metric-value.warning {
      color: var(--accent-orange);
    }

    .metric-value.critical {
      color: var(--accent-red);
    }

    .controls {
      background: var(--bg-medium);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }

    .controls h3 {
      color: var(--accent-magenta);
      margin-bottom: 12px;
      font-size: 0.9rem;
      text-transform: uppercase;
    }

    .control-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 12px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
    }

    label {
      color: var(--text-secondary);
      margin-bottom: 5px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      background: var(--bg-light);
      border-radius: 3px;
      outline: none;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: var(--accent-magenta);
      border-radius: 50%;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: var(--accent-magenta);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .value-display {
      color: var(--accent-green);
      font-weight: bold;
      margin-left: 8px;
      font-family: 'SF Mono', monospace;
    }

    button {
      background: var(--accent-magenta);
      color: #000;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'SF Mono', monospace;
    }

    button:hover {
      background: #b088ee;
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
    }

    .info-box {
      background: var(--bg-light);
      border-left: 3px solid var(--accent-cyan);
      padding: 12px;
      margin-bottom: 15px;
      border-radius: 4px;
    }

    .info-box h4 {
      color: var(--accent-cyan);
      font-size: 0.8rem;
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    .info-box p {
      color: var(--text-secondary);
      font-size: 0.75rem;
      line-height: 1.5;
    }

    @media (max-width: 1200px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
      canvas {
        height: 500px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>TPU: Toroidal Processing Unit Simulator</h1>
      <p class="subtitle">Google TPU Architecture ‚Ä¢ 2D/3D/Twisted Torus Topologies ‚Ä¢ Bandwidth/Compute Simulation</p>
    </header>

    <div class="mode-selector">
      <h3>üåê Topology</h3>
      <div class="mode-buttons">
        <button class="mode-btn active" data-mode="topology" data-value="2d-torus">2D Torus (v2/v3)</button>
        <button class="mode-btn" data-mode="topology" data-value="3d-torus">3D Torus (v4/v5p)</button>
        <button class="mode-btn" data-mode="topology" data-value="twisted-torus">Twisted Torus (v5p)</button>
      </div>
    </div>

    <div class="mode-selector">
      <h3>‚öôÔ∏è Simulation Mode</h3>
      <div class="mode-buttons">
        <button class="mode-btn active" data-mode="simulation" data-value="gameoflife">Game of Life</button>
        <button class="mode-btn" data-mode="simulation" data-value="bandwidth">Bandwidth Traffic</button>
        <button class="mode-btn" data-mode="simulation" data-value="compute">Compute Load</button>
      </div>
    </div>

    <div class="info-box">
      <h4>üìò About This Simulation</h4>
      <p id="mode-description">
        <strong>Game of Life Mode:</strong> Educational mode showing Conway's Game of Life on a toroidal grid.
        Demonstrates how periodic boundary conditions work - edges wrap around seamlessly.
      </p>
    </div>

    <div class="main-grid">
      <div class="visualization-panel">
        <h2 id="viz-title">2D Torus Network Topology</h2>
        <p class="viz-description" id="viz-desc">
          Each node connects to 4 nearest neighbors. Click to activate nodes. Edges wrap around.
        </p>
        <canvas id="main-canvas"></canvas>
      </div>

      <div class="metrics-panel">
        <div class="metric-group">
          <h3>üîó Network Metrics</h3>
          <div class="metric-row">
            <span class="metric-label">Topology:</span>
            <span class="metric-value" id="metric-topology">2D Torus 8√ó8</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Total Nodes:</span>
            <span class="metric-value" id="metric-nodes">64</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Neighbors/Node:</span>
            <span class="metric-value" id="metric-degree">4</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Total Bandwidth:</span>
            <span class="metric-value" id="metric-bandwidth">307.2 Gbps</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Avg Latency:</span>
            <span class="metric-value" id="metric-latency">4.0 hops</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Link Utilization:</span>
            <span class="metric-value" id="metric-utilization">0%</span>
          </div>
        </div>

        <div class="metric-group">
          <h3>üíª Compute Metrics</h3>
          <div class="metric-row">
            <span class="metric-label">Active Nodes:</span>
            <span class="metric-value" id="metric-active">0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Total FLOPS:</span>
            <span class="metric-value" id="metric-flops">0.0 PFLOP/s</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Power Draw:</span>
            <span class="metric-value" id="metric-power">0.0 kW</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Avg Temperature:</span>
            <span class="metric-value" id="metric-temp">25¬∞C</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Energy Efficiency:</span>
            <span class="metric-value" id="metric-efficiency">0 GFLOPS/W</span>
          </div>
        </div>

        <div class="metric-group">
          <h3>üìä Simulation Stats</h3>
          <div class="metric-row">
            <span class="metric-label">Generation:</span>
            <span class="metric-value" id="metric-generation">0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Activity:</span>
            <span class="metric-value" id="metric-activity">0.0%</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">FPS:</span>
            <span class="metric-value" id="metric-fps">60</span>
          </div>
        </div>
      </div>
    </div>

    <div class="controls">
      <h3>üéõÔ∏è Controls</h3>
      <div class="control-row">
        <div class="control-group">
          <label>
            Grid Size: <span class="value-display" id="gridSizeValue">8</span>
          </label>
          <input type="range" id="gridSize" min="4" max="16" value="8" step="2">
        </div>
        <div class="control-group">
          <label>
            Update Speed: <span class="value-display" id="speedValue">5</span> fps
          </label>
          <input type="range" id="speed" min="1" max="30" value="5">
        </div>
        <div class="control-group">
          <label>
            Traffic Rate: <span class="value-display" id="trafficValue">10</span> packets/sec
          </label>
          <input type="range" id="traffic" min="0" max="100" value="10" step="5">
        </div>
      </div>
      <div class="control-row">
        <div class="control-group">
          <label>
            Chip TFLOPS: <span class="value-display" id="tflopsValue">275</span> TFLOP/s
          </label>
          <input type="range" id="tflops" min="50" max="500" value="275" step="25">
        </div>
        <div class="control-group">
          <label>
            Chip Power: <span class="value-display" id="powerValue">175</span> W
          </label>
          <input type="range" id="power" min="50" max="400" value="175" step="25">
        </div>
      </div>
      <div class="control-row">
        <button id="randomize">üé≤ Randomize</button>
        <button id="clear">üóëÔ∏è Clear All</button>
        <button id="toggleAuto">‚ñ∂Ô∏è Start Auto-Update</button>
      </div>
    </div>
  </div>

  <script>
    'use strict';

    // ==================== STATE ====================
    const state = {
      topology: '2d-torus',        // '2d-torus', '3d-torus', 'twisted-torus'
      simulationMode: 'gameoflife', // 'gameoflife', 'bandwidth', 'compute'
      gridSize: 8,
      grid: [],                     // Main state grid
      autoUpdate: false,
      generation: 0,

      // Network metrics
      bandwidth: 4800,              // Gbps per chip (TPU v5p spec)
      latency: 0,
      utilization: 0,

      // Compute metrics
      chipTFLOPS: 275,              // TPU v6e Trillium spec
      chipPower: 175,               // Watts per chip
      activeNodes: 0,
      totalFLOPS: 0,
      totalPower: 0,
      avgTemp: 25,

      // Game of Life rules
      birthRule: [3],
      survivalRule: [2, 3],

      // Traffic simulation
      packets: [],
      trafficRate: 10,              // packets per second
      packetAccumulator: 0,

      // Canvas
      needsRender: true,

      // 3D rotation (for 3D torus)
      rotationX: -0.5,
      rotationY: 0,
      isDragging: false,
      lastMouseX: 0,
      lastMouseY: 0,
    };

    // ==================== CANVAS SETUP ====================
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    let lastUpdate = 0;

    function resizeCanvas() {
      const width = canvas.offsetWidth || 800;
      const height = canvas.offsetHeight || 600;
      if (width > 0 && height > 0) {
        canvas.width = width;
        canvas.height = height;
      }
    }

    // ==================== TOPOLOGY FUNCTIONS ====================
    function initGrid() {
      const size = state.gridSize;
      state.grid = Array(size).fill(null).map(() =>
        Array(size).fill(null).map(() =>
          Array(size).fill(0)
        )
      );
      state.generation = 0;
      state.packets = [];
      updateMetrics();
      state.needsRender = true;
    }

    function getNeighbors2D(x, y) {
      const size = state.gridSize;
      const xm = (x - 1 + size) % size;
      const xp = (x + 1) % size;
      const ym = (y - 1 + size) % size;
      const yp = (y + 1) % size;
      return [
        [xm, y, 0],          // left
        [xp, y, 0],          // right
        [x, ym, 0],          // up
        [x, yp, 0],          // down
        [xm, ym, 0],         // upper-left
        [xp, ym, 0],         // upper-right
        [xm, yp, 0],         // lower-left
        [xp, yp, 0],         // lower-right
      ];
    }

    function getNeighbors3D(x, y, z) {
      const size = state.gridSize;
      return [
        [(x - 1 + size) % size, y, z],          // left
        [(x + 1) % size, y, z],                 // right
        [x, (y - 1 + size) % size, z],          // front
        [x, (y + 1) % size, z],                 // back
        [x, y, (z - 1 + size) % size],          // down
        [x, y, (z + 1) % size],                 // up
      ];
    }

    function getNeighborsTwisted(x, y, z) {
      const size = state.gridSize;
      const neighbors = getNeighbors3D(x, y, z);

      // Add twisted connections (M√∂bius-like wraparound)
      // When wrapping in X dimension, also flip Y
      if (x === size - 1) {
        neighbors.push([0, (size - 1 - y + size) % size, z]);
      }
      if (x === 0) {
        neighbors.push([size - 1, (size - 1 - y + size) % size, z]);
      }

      return neighbors;
    }

    // ==================== SIMULATION MODES ====================
    function updateGameOfLife() {
      const size = state.gridSize;
      if (state.topology === '2d-torus') {
        const newPlane = Array(size).fill(null).map(() => Array(size).fill(0));
        const plane = state.grid[0];
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const neighbors = getNeighbors2D(x, y).reduce((sum, [nx, ny]) => sum + plane[ny][nx], 0);
            const current = plane[y][x];
            newPlane[y][x] = current === 1
              ? (state.survivalRule.includes(neighbors) ? 1 : 0)
              : (state.birthRule.includes(neighbors) ? 1 : 0);
          }
        }
        state.grid[0] = newPlane;
      } else {
        const newGrid = Array(size).fill(null).map(() =>
          Array(size).fill(null).map(() => Array(size).fill(0))
        );
        for (let z = 0; z < size; z++) {
          for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
              const neighbors = (state.topology === '3d-torus' ? getNeighbors3D(x, y, z) : getNeighborsTwisted(x, y, z))
                .reduce((sum, [nx, ny, nz]) => sum + state.grid[nz][ny][nx], 0);
              const current = state.grid[z][y][x];
              newGrid[z][y][x] = current === 1
                ? (state.survivalRule.includes(neighbors) ? 1 : 0)
                : (state.birthRule.includes(neighbors) ? 1 : 0);
            }
          }
        }
        state.grid = newGrid;
      }
      state.generation++;
      updateMetrics();
    }

    function updateBandwidthSimulation() {
      // Generate new packets
      state.packetAccumulator = (state.packetAccumulator || 0) + state.trafficRate / 60;
      const packetsToGenerate = Math.floor(state.packetAccumulator);
      state.packetAccumulator -= packetsToGenerate;
      for (let i = 0; i < packetsToGenerate; i++) {
        const srcX = Math.floor(Math.random() * state.gridSize);
        const srcY = Math.floor(Math.random() * state.gridSize);
        const srcZ = 0;
        const dstX = Math.floor(Math.random() * state.gridSize);
        const dstY = Math.floor(Math.random() * state.gridSize);
        const dstZ = 0;

        state.packets.push({
          srcX, srcY, srcZ,
          dstX, dstY, dstZ,
          currentX: srcX,
          currentY: srcY,
          currentZ: srcZ,
          hops: 0,
          maxHops: 100,
        });
      }

      // Route packets (dimension-order routing)
      state.packets = state.packets.filter(packet => {
        if (packet.currentX !== packet.dstX) {
          packet.currentX = (packet.currentX + (packet.dstX > packet.currentX ? 1 : -1) + state.gridSize) % state.gridSize;
          packet.hops++;
        } else if (packet.currentY !== packet.dstY) {
          packet.currentY = (packet.currentY + (packet.dstY > packet.currentY ? 1 : -1) + state.gridSize) % state.gridSize;
          packet.hops++;
        } else if (packet.currentZ !== packet.dstZ) {
          packet.currentZ = (packet.currentZ + (packet.dstZ > packet.currentZ ? 1 : -1) + state.gridSize) % state.gridSize;
          packet.hops++;
        } else {
          return false; // Packet arrived
        }

        return packet.hops < packet.maxHops;
      });

      // Mark nodes with traffic
      state.grid.forEach((plane, z) => {
        plane.forEach((row, y) => {
          row.forEach((cell, x) => {
            state.grid[z][y][x] = 0;
          });
        });
      });

      state.packets.forEach(packet => {
        state.grid[packet.currentZ][packet.currentY][packet.currentX] = 1;
      });

      updateMetrics();
    }

    function updateComputeSimulation() {
      // Simple heat diffusion model
      const size = state.gridSize;
      const newGrid = Array(size).fill(null).map(() =>
        Array(size).fill(null).map(() => Array(size).fill(0))
      );

      for (let z = 0; z < size; z++) {
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const neighborList = state.topology === '2d-torus'
              ? getNeighbors2D(x, y).map(([nx, ny]) => [nx, ny, 0])
              : (state.topology === '3d-torus'
                ? getNeighbors3D(x, y, z)
                : getNeighborsTwisted(x, y, z));

            let avgHeat = state.grid[z][y][x];
            neighborList.forEach(([nx, ny, nz]) => {
              avgHeat += state.grid[nz][ny][nx];
            });
            avgHeat /= (neighborList.length + 1);

            if (Math.random() < 0.05) {
              avgHeat = Math.min(100, avgHeat + Math.random() * 20);
            }

            newGrid[z][y][x] = avgHeat * 0.95;
          }
        }
      }

      state.grid = newGrid;
      updateMetrics();
    }

    // ==================== METRICS ====================
    function updateMetrics() {
      const size = state.gridSize;
      let activeNodes = 0;
      let totalHeat = 0;

      state.grid.forEach(plane => {
        plane.forEach(row => {
          row.forEach(cell => {
            if (state.simulationMode === 'gameoflife' || state.simulationMode === 'bandwidth') {
              if (cell > 0) activeNodes++;
            } else {
              if (cell > 10) activeNodes++;
              totalHeat += cell;
            }
          });
        });
      });

      state.activeNodes = activeNodes;
      const totalNodes = size * size * (state.topology === '2d-torus' ? 1 : size);
      const degree = state.topology === '2d-torus'
        ? 8
        : state.topology === '3d-torus'
          ? 6
          : 8;

      // Network metrics
      const totalBandwidth = totalNodes * state.bandwidth * degree / 2; // Divided by 2 to avoid double-counting links
      state.utilization = state.packets.length > 0 ? Math.min(100, (state.packets.length / totalNodes) * 100) : 0;

      // Compute metrics
      state.totalFLOPS = activeNodes * state.chipTFLOPS;
      state.totalPower = activeNodes * state.chipPower;
      state.avgTemp = state.simulationMode === 'compute'
        ? 25 + (totalHeat / totalNodes) * 0.5
        : 25 + (activeNodes / totalNodes) * 50;

      // Update UI
      document.getElementById('metric-topology').textContent =
        state.topology === '2d-torus' ? `2D Torus ${size}√ó${size}` :
        state.topology === '3d-torus' ? `3D Torus ${size}√ó${size}√ó${size}` :
        `Twisted Torus ${size}√ó${size}√ó${size}`;

      document.getElementById('metric-nodes').textContent = totalNodes;
      document.getElementById('metric-degree').textContent = degree;
      document.getElementById('metric-bandwidth').textContent = (totalBandwidth / 1000).toFixed(1) + ' Tbps';
      document.getElementById('metric-latency').textContent = (size / 2).toFixed(1) + ' hops';
      document.getElementById('metric-utilization').textContent = state.utilization.toFixed(1) + '%';

      document.getElementById('metric-active').textContent = activeNodes;
      document.getElementById('metric-flops').textContent = (state.totalFLOPS / 1000).toFixed(2) + ' PFLOP/s';
      document.getElementById('metric-power').textContent = (state.totalPower / 1000).toFixed(2) + ' kW';
      document.getElementById('metric-temp').textContent = Math.round(state.avgTemp) + '¬∞C';

      const efficiency = state.totalPower > 0 ? (state.totalFLOPS * 1000 / state.totalPower) : 0;
      document.getElementById('metric-efficiency').textContent = Math.round(efficiency) + ' GFLOPS/W';

      document.getElementById('metric-generation').textContent = state.generation;
      document.getElementById('metric-activity').textContent = ((activeNodes / totalNodes) * 100).toFixed(1) + '%';

      // Update metric value colors
      const utilElem = document.getElementById('metric-utilization');
      utilElem.className = 'metric-value';
      if (state.utilization > 70) utilElem.classList.add('critical');
      else if (state.utilization > 40) utilElem.classList.add('warning');

      const tempElem = document.getElementById('metric-temp');
      tempElem.className = 'metric-value';
      if (state.avgTemp > 80) tempElem.classList.add('critical');
      else if (state.avgTemp > 60) tempElem.classList.add('warning');
    }

    // ==================== RENDERING ====================
    function render2DTorus() {
      const size = state.gridSize;
      const cellSize = Math.min(canvas.width, canvas.height) / (size + 2);
      const offsetX = (canvas.width - size * cellSize) / 2;
      const offsetY = (canvas.height - size * cellSize) / 2;

      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw cells
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const value = state.grid[0][y][x];

          if (state.simulationMode === 'compute') {
            // Heat map
            const intensity = Math.min(255, Math.floor(value * 2.55));
            ctx.fillStyle = `rgb(${intensity}, ${Math.floor(intensity * 0.3)}, 0)`;
          } else {
            // Binary on/off
            ctx.fillStyle = value > 0 ? '#66bb66' : '#0a0a0a';
          }

          ctx.fillRect(
            offsetX + x * cellSize + 1,
            offsetY + y * cellSize + 1,
            cellSize - 2,
            cellSize - 2
          );

          // Border
          ctx.strokeStyle = value > 0 ? '#66bb66' : '#333333';
          ctx.lineWidth = value > 0 ? 2 : 0.5;
          ctx.strokeRect(
            offsetX + x * cellSize,
            offsetY + y * cellSize,
            cellSize,
            cellSize
          );
        }
      }

      // Draw wraparound arrows
      ctx.fillStyle = '#9966cc';
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const gridWidth = size * cellSize;
      const gridHeight = size * cellSize;

      if (offsetY > 20) {
        ctx.fillText('‚Üï', canvas.width / 2, offsetY - 10);
        ctx.fillText('‚Üï', canvas.width / 2, offsetY + gridHeight + 10);
      }
      if (offsetX > 20) {
        ctx.fillText('‚Üî', offsetX - 10, canvas.height / 2);
        ctx.fillText('‚Üî', offsetX + gridWidth + 10, canvas.height / 2);
      }

      // Draw packets if in bandwidth mode
      if (state.simulationMode === 'bandwidth') {
        ctx.fillStyle = '#ffff00';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ffff00';
        state.packets.forEach(packet => {
          const px = offsetX + packet.currentX * cellSize + cellSize / 2;
          const py = offsetY + packet.currentY * cellSize + cellSize / 2;
          ctx.beginPath();
          ctx.arc(px, py, 4, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.shadowBlur = 0;
      }
    }

    function render3DTorus() {
      const minorRadius = Math.min(canvas.width, canvas.height) * 0.15;
      const majorRadius = Math.min(canvas.width, canvas.height) * 0.35;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const size = state.gridSize;

      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const cosX = Math.cos(state.rotationX);
      const sinX = Math.sin(state.rotationX);
      const cosY = Math.cos(state.rotationY);
      const sinY = Math.sin(state.rotationY);

      const points = [];
      const pointMap = new Map();

      for (let z = 0; z < size; z++) {
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const u = (x / size) * TWO_PI;
            const v = (y / size) * TWO_PI;
            const w = (z / size) * TWO_PI;

            const baseX = (majorRadius + minorRadius * Math.cos(v)) * Math.cos(u);
            const baseY = (majorRadius + minorRadius * Math.cos(v)) * Math.sin(u);
            const baseZ = minorRadius * Math.sin(v);

            const x3d = baseX;
            const y3d = baseY * cosX - baseZ * sinX;
            const z3d = baseY * sinX + baseZ * cosX;

            const rotX = x3d * cosY - z3d * sinY;
            const rotZ = x3d * sinY + z3d * cosY;

            const perspective = 400 / (400 + rotZ);
            const screenX = centerX + rotX * perspective;
            const screenY = centerY + y3d * perspective;

            const point = {
              x, y, z,
              screenX, screenY,
              depth: rotZ,
              value: state.grid[z][y][x],
              scale: perspective,
            };
            points.push(point);
            pointMap.set(`${x},${y},${z}`, point);
          }
        }
      }

      points.sort((a, b) => a.depth - b.depth);

      points.forEach(point => {
        const neighbors = [
          [(point.x + 1) % size, point.y, point.z],
          [point.x, (point.y + 1) % size, point.z],
          [point.x, point.y, (point.z + 1) % size],
        ];

        if (state.topology === 'twisted-torus') {
          if (point.x === size - 1) {
            neighbors.push([0, (size - 1 - point.y + size) % size, point.z]);
          }
        }

        neighbors.forEach(([nx, ny, nz], idx) => {
          const neighbor = pointMap.get(`${nx},${ny},${nz}`);
          if (!neighbor) return;
          const active = point.value > 0 || neighbor.value > 0;
          const isTwisted = state.topology === 'twisted-torus' && idx >= 3;

          ctx.strokeStyle = isTwisted
            ? (active ? 'rgba(153, 102, 204, 0.5)' : 'rgba(153, 102, 204, 0.2)')
            : (active ? 'rgba(102, 187, 102, 0.35)' : 'rgba(60, 60, 60, 0.15)');
          ctx.lineWidth = isTwisted ? 1.2 : 0.6;
          ctx.beginPath();
          ctx.moveTo(point.screenX, point.screenY);
          ctx.lineTo(neighbor.screenX, neighbor.screenY);
          ctx.stroke();
        });
      });

      points.forEach(point => {
        const radius = Math.max(2, 3 * point.scale);
        if (state.simulationMode === 'compute') {
          const intensity = Math.min(255, Math.floor(point.value * 2.55));
          ctx.fillStyle = `rgb(${intensity}, ${Math.floor(intensity * 0.3)}, 0)`;
        } else {
          ctx.fillStyle = point.value > 0 ? '#66bb66' : '#222';
        }
        ctx.beginPath();
        ctx.arc(point.screenX, point.screenY, radius, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.fillStyle = '#666';
      ctx.font = '12px monospace';
      ctx.textAlign = 'left';
      ctx.fillText('Drag to rotate', 10, canvas.height - 10);
    }

    function renderFrame() {
      if (state.topology === '2d-torus') {
        render2DTorus();
      } else {
        render3DTorus();
      }
      state.needsRender = false;
    }

    // ==================== EVENT HANDLERS ====================
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const mode = btn.dataset.mode;
        const value = btn.dataset.value;

        btn.parentElement.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        if (mode === 'topology') {
          state.topology = value;
          initGrid();
          updateModeDescription();
        } else if (mode === 'simulation') {
          state.simulationMode = value;
          updateModeDescription();
        }

        state.needsRender = true;
      });
    });

    function updateModeDescription() {
      const desc = document.getElementById('mode-description');
      const vizTitle = document.getElementById('viz-title');
      const vizDesc = document.getElementById('viz-desc');

      let description = '';
      let title = '';
      let vizDescription = '';

      if (state.simulationMode === 'gameoflife') {
        description = '<strong>Game of Life Mode:</strong> Educational mode showing Conway\'s Game of Life on a toroidal grid. Demonstrates how periodic boundary conditions work - edges wrap around seamlessly.';
        title = 'Conway\'s Game of Life on Torus';
        vizDescription = 'Click cells to activate. Watch patterns propagate and wrap around edges.';
      } else if (state.simulationMode === 'bandwidth') {
        description = '<strong>Bandwidth Traffic Mode:</strong> Simulates packet routing between TPU chips. Uses dimension-order routing (standard for torus networks). Yellow dots = packets in transit. Monitor link utilization and latency.';
        title = 'TPU Interconnect Traffic';
        vizDescription = 'Traffic flows via dimension-order routing. Adjust traffic rate to see congestion.';
      } else {
        description = '<strong>Compute Load Mode:</strong> Simulates computational workload distribution and heat dissipation across TPU chips. Color intensity = temperature. Realistic power and FLOPS metrics based on TPU v6e Trillium specs.';
        title = 'TPU Compute Heat Map';
        vizDescription = 'Color intensity shows chip temperature. Heat diffuses to neighbors via ICI links.';
      }

      desc.innerHTML = description;
      vizTitle.textContent = title;
      vizDesc.textContent = vizDescription;
    }

    // Canvas click handler (2D mode)
    canvas.addEventListener('click', (e) => {
      if (state.topology !== '2d-torus') return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const size = state.gridSize;
      const cellSize = Math.min(canvas.width, canvas.height) / (size + 2);
      const offsetX = (canvas.width - size * cellSize) / 2;
      const offsetY = (canvas.height - size * cellSize) / 2;

      const gridX = Math.floor((x - offsetX) / cellSize);
      const gridY = Math.floor((y - offsetY) / cellSize);

      if (gridX >= 0 && gridX < size && gridY >= 0 && gridY < size) {
        if (state.simulationMode === 'gameoflife' || state.simulationMode === 'bandwidth') {
          state.grid[0][gridY][gridX] = state.grid[0][gridY][gridX] ? 0 : 1;
        } else {
          state.grid[0][gridY][gridX] = state.grid[0][gridY][gridX] > 0 ? 0 : 50;
        }
        updateMetrics();
        state.needsRender = true;
      }
    });

    // 3D rotation handlers
    canvas.addEventListener('mousedown', (e) => {
      if (state.topology === '2d-torus') return;
      state.isDragging = true;
      state.lastMouseX = e.clientX;
      state.lastMouseY = e.clientY;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!state.isDragging || state.topology === '2d-torus') return;

      const deltaX = e.clientX - state.lastMouseX;
      const deltaY = e.clientY - state.lastMouseY;

      state.rotationY += deltaX * 0.01;
      state.rotationX += deltaY * 0.01;

      state.lastMouseX = e.clientX;
      state.lastMouseY = e.clientY;

      state.needsRender = true;
    });

    canvas.addEventListener('mouseup', () => {
      state.isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
      state.isDragging = false;
    });

    // Control handlers
    document.getElementById('gridSize').addEventListener('input', (e) => {
      state.gridSize = parseInt(e.target.value);
      document.getElementById('gridSizeValue').textContent = state.gridSize;
      initGrid();
      resizeCanvas();
      state.needsRender = true;
    });

    document.getElementById('speed').addEventListener('input', (e) => {
      document.getElementById('speedValue').textContent = e.target.value;
    });

    document.getElementById('traffic').addEventListener('input', (e) => {
      state.trafficRate = parseInt(e.target.value);
      document.getElementById('trafficValue').textContent = state.trafficRate;
    });

    document.getElementById('tflops').addEventListener('input', (e) => {
      state.chipTFLOPS = parseInt(e.target.value);
      document.getElementById('tflopsValue').textContent = state.chipTFLOPS;
      updateMetrics();
    });

    document.getElementById('power').addEventListener('input', (e) => {
      state.chipPower = parseInt(e.target.value);
      document.getElementById('powerValue').textContent = state.chipPower;
      updateMetrics();
    });

    document.getElementById('randomize').addEventListener('click', () => {
      const size = state.gridSize;
      for (let z = 0; z < state.grid.length; z++) {
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            if (state.simulationMode === 'compute') {
              state.grid[z][y][x] = Math.random() > 0.7 ? Math.random() * 100 : 0;
            } else {
              state.grid[z][y][x] = Math.random() > 0.7 ? 1 : 0;
            }
          }
        }
      }
      state.generation = 0;
      updateMetrics();
      state.needsRender = true;
    });

    document.getElementById('clear').addEventListener('click', () => {
      initGrid();
      state.needsRender = true;
    });

    document.getElementById('toggleAuto').addEventListener('click', (e) => {
      state.autoUpdate = !state.autoUpdate;
      e.target.textContent = state.autoUpdate ? '‚è∏Ô∏è Stop Auto-Update' : '‚ñ∂Ô∏è Start Auto-Update';
    });

    // Animation loop
    function animate(time) {
      const fps = parseInt(document.getElementById('speed').value);
      const interval = 1000 / fps;

      if (state.autoUpdate && time - lastUpdate > interval) {
        if (state.simulationMode === 'gameoflife') {
          updateGameOfLife();
        } else if (state.simulationMode === 'bandwidth') {
          updateBandwidthSimulation();
        } else {
          updateComputeSimulation();
        }
        lastUpdate = time;
        state.needsRender = true;
      }

      if (state.needsRender) {
        renderFrame();
      }

      // Update FPS counter
      const currentFPS = Math.round(1000 / (time - (window.lastFrameTime || time)));
      window.lastFrameTime = time;
      document.getElementById('metric-fps').textContent = isFinite(currentFPS) ? currentFPS : 60;

      requestAnimationFrame(animate);
    }

    // Initialize
    window.addEventListener('resize', () => {
      resizeCanvas();
      state.needsRender = true;
    });

    document.addEventListener('DOMContentLoaded', () => {
      requestAnimationFrame(() => {
        resizeCanvas();
        initGrid();
        renderFrame();
        requestAnimationFrame(animate);
      });
    });
  </script>
</body>
</html>
