<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AEH - Adversarial Equity Heuristics</title>
    <link rel="stylesheet" href="../simulatte-core.css">
    <style>
      /* HEA-specific variables */
      :root {
        --win-color: var(--accent-secondary);   /* Green for wins */
        --loss-color: var(--accent-primary);    /* Magenta for losses */
        --tie-color: var(--accent-tertiary);    /* Cyan for ties */
      }
      body {
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .container {
        width: 100%;
        max-width: 1400px;
        display: grid;
        grid-template-columns: 450px 1fr;
        gap: 20px;
      }
      .panel {
        background-color: var(--surface-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }
      h1 {
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 8px;
        margin-top: 0;
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      h2,
      h3 {
        color: var(--primary-text);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 8px;
        margin-top: 0;
        font-weight: 400;
      }
      p,
      label {
        color: var(--secondary-text);
        line-height: 1.6;
      }
      .info-box {
        background-color: rgba(68, 1, 84, 0.2);
        border-left: 3px solid #440154;
        padding: 10px 15px;
        margin: 15px 0;
        border-radius: 4px;
      }

      /* LEFT PANEL */
      .controls {
        margin-bottom: 20px;
      }
      .slider-container {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      input[type="range"] {
        width: 100%;
        cursor: pointer;
      }
      #opponent-count-label {
        font-weight: bold;
        font-size: 1.2em;
        color: var(--highlight-color);
        min-width: 120px;
      }

      .heatmap-container {
        display: grid;
        grid-template-columns: repeat(13, 1fr);
        width: 100%;
        aspect-ratio: 1/1;
        gap: 1px;
        background-color: var(--border-color);
        border: 2px solid var(--border-color);
      }
      .heatmap-cell {
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 11px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.1s ease, box-shadow 0.1s ease;
        user-select: none;
        color: white;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
      }
      .heatmap-cell:hover {
        transform: scale(1.1);
        z-index: 10;
      }
      .heatmap-cell.selected {
        box-shadow: 0 0 0 3px var(--highlight-color) inset;
        transform: scale(1.05);
        z-index: 5;
      }

      /* RIGHT PANEL */
      .poker-table {
        position: relative;
        width: 100%;
        aspect-ratio: 1.6/1;
        border: 2px solid #2a2a2a;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .hand-display {
        display: flex;
        gap: 5px;
        align-items: center;
      }
      .card {
        width: 40px;
        height: 60px;
        border-radius: 5px;
        background-color: white;
        color: black;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 18px;
        font-weight: bold;
        border: 1px solid #ccc;
        user-select: none;
        box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.4);
      }
      .card.red {
        color: #d32f2f;
      }
      .card.black {
        color: #000000;
      }
      .card.board-enter {
        animation: boardReveal 0.35s ease;
      }
      @keyframes boardReveal {
        from {
          transform: translateY(10px) scale(0.95);
          opacity: 0;
        }
        to {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
      }
      .card-back {
        background: #212121;
        border: 1px solid #444;
        background-image: repeating-linear-gradient(
          45deg,
          transparent,
          transparent 3px,
          rgba(255, 255, 255, 0.05) 3px,
          rgba(255, 255, 255, 0.05) 6px
        );
      }
      #board-cards-container {
        position: absolute;
      }
      #hero-hand-container {
        position: absolute;
        bottom: 8%;
        left: 50%;
        transform: translateX(-50%);
      }
      .opponent-position {
        position: absolute;
        transform: translate(-50%, -50%);
      }
      .opponent-position.winner .card:not(.card-back) {
        box-shadow: 0 0 0 3px var(--highlight-color);
      }
      #hero-hand-container.winner .card {
        box-shadow: 0 0 0 3px var(--highlight-color);
      }
      .card.winning-card {
        box-shadow: 0 0 0 4px gold !important;
        transform: scale(1.05);
      }
      .opponent-position.leader::after,
      #hero-hand-container.leader::after {
        content: "â˜…";
        position: absolute;
        top: -25px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 20px;
        color: gold;
      }
      .position-label {
        position: absolute;
        bottom: -20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 11px;
        color: var(--secondary-text);
        white-space: nowrap;
      }

      .equity-display {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
        text-align: center;
        margin-bottom: 12px;
        width: 100%;
      }
      .equity-box {
        background-color: #2a2a2a;
        padding: 10px;
        border-radius: 6px;
        position: relative;
      }
      .equity-box h4 {
        margin: 0 0 5px 0;
        font-size: 0.9em;
        color: var(--secondary-text);
        border: none;
      }
      .equity-box .value {
        font-size: 1.5em;
        font-weight: bold;
        color: #55c667ff;
      }
      .equity-box .value.live {
        font-size: 1.8em;
        color: var(--highlight-color);
      }

      .equity-box .equity-metadata {
        display: block;
        margin-top: 6px;
        font-size: 0.75em;
        color: var(--secondary-text);
      }

      .equity-delta-row {
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }
      .delta-pill {
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.08);
        font-weight: 600;
        font-size: 0.85em;
        color: var(--secondary-text);
        border: 1px solid rgba(255, 255, 255, 0.12);
        min-width: 120px;
        text-align: center;
      }
      .delta-pill.positive {
        background: rgba(53, 183, 121, 0.18);
        border-color: rgba(53, 183, 121, 0.4);
        color: #35b779;
      }
      .delta-pill.negative {
        background: rgba(255, 105, 180, 0.18);
        border-color: rgba(255, 105, 180, 0.45);
        color: var(--accent-primary);
      }
      .sparkline-wrapper {
        flex: 1;
        min-width: 180px;
        background: #2a2a2a;
        border-radius: 6px;
        padding: 6px 10px 4px;
      }
      #equity-delta-sparkline {
        width: 100%;
        height: 40px;
        display: block;
      }

      #interactive-controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 20px;
      }
      .sim-button {
        background-color: #35b779;
        color: black;
        border: none;
        padding: 10px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.2s;
      }
      .sim-button:hover:not(:disabled) {
        background-color: #44c489;
      }
      .sim-button:disabled {
        background-color: #555;
        color: #888;
        cursor: not-allowed;
      }
      .sim-button.small {
        padding: 6px 10px;
        font-size: 0.8em;
      }
      .sim-button.active {
        background-color: var(--highlight-color);
      }

      .suit-tracker-section {
        margin-top: 18px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 6px;
        padding: 14px;
        display: none;
      }
      .suit-tracker-section h3 {
        margin-top: 0;
        text-align: left;
        font-size: 1em;
        color: var(--primary-text);
        border: none;
      }
      .suit-tracker-content {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
        align-items: stretch;
      }
      #suit-donut-chart {
        flex: 0 0 160px;
      }
      #suit-donut-chart svg {
        width: 160px;
        height: 160px;
        display: block;
      }
      #suit-summary {
        flex: 1 1 180px;
        font-size: 0.85em;
        color: var(--secondary-text);
      }
      .suit-summary-item {
        margin-bottom: 10px;
        padding-bottom: 10px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }
      .suit-summary-item:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }
      .suit-tag {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-weight: 600;
        color: var(--primary-text);
      }
      .suit-tag .pip {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75em;
        color: #111;
      }

      .sensitivity-controls {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }
      #sensitivity-section {
        display: none;
      }
      .sensitivity-table {
        overflow-x: auto;
      }
      .sensitivity-table table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.85em;
      }
      .sensitivity-table th,
      .sensitivity-table td {
        padding: 6px 8px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        text-align: left;
        color: var(--secondary-text);
      }
      .sensitivity-table th {
        font-weight: 600;
        color: var(--primary-text);
      }
      .sensitivity-table tr.improver td.delta {
        color: #35b779;
      }
      .sensitivity-table tr.buster td.delta {
        color: var(--accent-primary);
      }
      .sensitivity-table td.card {
        font-weight: 600;
        color: var(--primary-text);
      }

      /* CHARTING STYLES */
      .charts-section {
        margin-top: 20px;
      }
      .charts-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }
      .chart-container {
        background-color: #2a2a2a;
        padding: 15px;
        border-radius: 6px;
      }
      .chart-container h3 {
        margin: 0 0 10px 0;
        font-size: 1em;
        text-align: center;
      }
      .chart-container svg {
        width: 100%;
        height: 200px;
        display: block;
      }
      .chart-tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 100;
      }

      @media (max-width: 1200px) {
        .container {
          grid-template-columns: 1fr;
        }
      }
      @media (max-width: 600px) {
        .charts-grid {
          grid-template-columns: 1fr;
        }
        .poker-table {
          aspect-ratio: 1.2/1;
        }
        .opponent-position {
          transform: translate(-50%, -50%) scale(0.85);
        }
        .card {
          width: 32px;
          height: 48px;
          font-size: 14px;
        }
        #hero-hand-container {
          bottom: 2%;
        }
      }
    </style>
  </head>
  <body>
    <div style="text-align: center; margin-bottom: 20px">
      <h1>AEH - Adversarial Equity Heuristics</h1>
      <p>
        Explore pre-flop strategy and see how equity shifts post-flop with full
        showdown analysis.
      </p>
    </div>

    <div class="container">
      <!-- LEFT PANEL -->
      <div class="left-panel panel">
        <h2>1. Pre-Flop Strategy</h2>
        <div class="controls">
          <label for="opponent-slider">Number of Opponents:</label>
          <div class="slider-container">
            <input
              type="range"
              id="opponent-slider"
              min="1"
              max="9"
              value="8"
            />
            <span id="opponent-count-label">8 Opponents</span>
          </div>
        </div>
        <div id="heatmap" class="heatmap-container"></div>
        <div class="info-box">
          <p>
            Select a hand from the grid. Color shows absolute strength (Bright/Yellow =
            Strong, Teal = Medium, Dark Purple = Weak).
          </p>
        </div>
      </div>

      <!-- RIGHT PANEL -->
      <div class="right-panel">
        <div class="panel">
          <h2>
            2. In-Game Analysis:
            <span id="selected-hand-title">No Hand Selected</span>
          </h2>
          <div class="equity-display">
            <div class="equity-box" title="Average win rate for this hand across all possible scenarios with this many opponents">
              <h4>Expected Win Rate (All Scenarios)</h4>
              <span class="value" id="theoretical-equity-val">--</span>
              <span class="equity-metadata" id="theoretical-equity-meta"></span>
            </div>
            <div class="equity-box" id="live-equity-hidden-box" title="Win probability assuming opponents are still hidden and can hold any remaining cards">
              <h4>Win Probability (Unknown Villains)</h4>
              <span class="value live" id="live-equity-hidden-val">--</span>
              <span class="equity-metadata" id="live-equity-hidden-meta"></span>
            </div>
            <div class="equity-box" id="live-equity-known-box" title="Win probability with perfect information about every player's hole cards">
              <h4>Win Probability (All Cards Revealed)</h4>
              <span class="value live" id="live-equity-known-val">--</span>
              <span class="equity-metadata" id="live-equity-known-meta"></span>
            </div>
          </div>
          <div class="equity-delta-row" id="equity-delta-row" style="display: none;">
            <div id="equity-delta-pill" class="delta-pill neutral">Î” --</div>
            <div class="sparkline-wrapper">
              <svg id="equity-delta-sparkline" viewBox="0 0 120 40"></svg>
            </div>
          </div>
          <div class="info-box" id="equity-explainer" style="display: none;">
            <p>
              <strong>Unknown Villains</strong> treats every opponent card as unseen and rerolls their ranges each simulation. <strong>All Cards Revealed</strong> conditions on the exact hands currently dealt. The delta and sparkline show how much perfect information is worth street by street.
            </p>
          </div>
          <div class="poker-table" id="poker-table-area">
            <div id="board-cards-container" class="hand-display"></div>
            <div id="hero-hand-container" class="hand-display"></div>
            <!-- Opponent hands will be added here dynamically -->
          </div>
          <div id="interactive-controls">
            <button id="start-interactive-btn" class="sim-button" disabled>
              Play This Hand
            </button>
            <button
              id="deal-street-btn"
              class="sim-button"
              style="display: none"
            >
              Deal Flop
            </button>
            <button
              id="reset-hand-btn"
              class="sim-button"
              style="display: none"
            >
              New Hand
            </button>
            <button
              id="toggle-cards-btn"
              class="sim-button"
              style="display: none"
            >
              Reveal Opponent Cards
            </button>
          </div>
          <div id="suit-tracker-section" class="suit-tracker-section">
            <h3>Flush Outlook</h3>
            <div class="suit-tracker-content">
              <div id="suit-donut-chart"></div>
              <div id="suit-summary"></div>
            </div>
          </div>
        </div>

        <div class="panel">
          <h2>3. Performance & Showdown</h2>
          <div id="charts-sections">
            <div class="charts-section" id="preflop-charts-section">
              <h3>Pre-Flop Analysis (Long-Term)</h3>
              <div class="charts-grid" id="preflop-charts-grid"></div>
            </div>
            <div
              class="charts-section"
              id="live-charts-section"
              style="display: none"
            >
              <h3>Live Hand Analysis</h3>
              <div class="charts-grid" id="live-charts-grid"></div>
            </div>
            <div class="charts-section" id="sensitivity-section">
              <h3>Next Card Impact</h3>
              <div class="sensitivity-controls">
                <button class="sim-button small" data-sensitivity-mode="fog" id="sensitivity-fog-btn">
                  Unknown Villains
                </button>
                <button class="sim-button small" data-sensitivity-mode="omniscient" id="sensitivity-known-btn">
                  All Cards Revealed
                </button>
              </div>
              <div class="sensitivity-table" id="sensitivity-table-container"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="tooltip" class="chart-tooltip"></div>

    <script>
      // ===================================================================================
      //               DEFINITIVE HOLD'EM ANALYZER SCRIPT
      // ===================================================================================

      document.addEventListener("DOMContentLoaded", () => {
        // SECTION 1: DATA, CONSTANTS, & STATE
        const RANKS = "AKQJT98765432".split("");
        const SUITS = ["s", "h", "d", "c"];
        const SUIT_SYMBOLS = { s: "â™ ", h: "â™¥", d: "â™¦", c: "â™£" };
        const SUIT_LABELS = {
          s: "Spades",
          h: "Hearts",
          d: "Diamonds",
          c: "Clubs",
        };
        const SUIT_COLOR_MAP = {
          s: "#4c78ff",
          h: "#ff5c8d",
          d: "#f6b26b",
          c: "#63c35b",
        };
        const RANK_INDEX = RANKS.reduce((acc, r, idx) => {
          acc[r] = idx;
          return acc;
        }, {});
        const HAND_RANKS_TXT = [
          "High Card",
          "Pair",
          "Two Pair",
          "3-of-a-Kind",
          "Straight",
          "Flush",
          "Full House",
          "4-of-a-Kind",
          "Straight Flush",
        ];
        const STREET_SEQUENCE = ["preflop", "flop", "turn", "river"];
        const STREET_LABELS = {
          preflop: "Preflop",
          flop: "Flop",
          turn: "Turn",
          river: "River",
        };
        const STREET_ORDER = STREET_SEQUENCE.reduce((acc, street, idx) => {
          acc[street] = idx;
          return acc;
        }, {});
        const SIM_SAMPLES_BY_STREET = {
          preflop: 1800,
          flop: 1400,
          turn: 1000,
          river: 1,
        };
        const equityData = {
          AA: {
            1: 85.2,
            2: 73.5,
            3: 64.5,
            4: 57.2,
            5: 51.2,
            6: 46.2,
            7: 41.9,
            8: 38.3,
            9: 35.1,
          },
          KK: {
            1: 82.4,
            2: 69.1,
            3: 58.7,
            4: 50.8,
            5: 44.4,
            6: 39.2,
            7: 34.9,
            8: 31.3,
            9: 28.3,
          },
          QQ: {
            1: 79.9,
            2: 65.3,
            3: 54.4,
            4: 46.5,
            5: 39.9,
            6: 34.7,
            7: 30.5,
            8: 27.1,
            9: 24.3,
          },
          JJ: {
            1: 77.5,
            2: 61.6,
            3: 50.3,
            4: 42.3,
            5: 36,
            6: 30.8,
            7: 26.7,
            8: 23.5,
            9: 20.9,
          },
          TT: {
            1: 75,
            2: 58,
            3: 46.5,
            4: 38.4,
            5: 32.3,
            6: 27.4,
            7: 23.5,
            8: 20.5,
            9: 18,
          },
          99: {
            1: 72.1,
            2: 54.5,
            3: 42.8,
            4: 34.9,
            5: 29.1,
            6: 24.5,
            7: 20.8,
            8: 17.9,
            9: 15.6,
          },
          88: {
            1: 69.1,
            2: 50.9,
            3: 39.2,
            4: 31.6,
            5: 26,
            6: 21.7,
            7: 18.3,
            8: 15.6,
            9: 13.5,
          },
          77: {
            1: 66.2,
            2: 47.5,
            3: 35.8,
            4: 28.4,
            5: 23.2,
            6: 19.2,
            7: 16,
            8: 13.6,
            9: 11.6,
          },
          66: {
            1: 63.2,
            2: 44.1,
            3: 32.5,
            4: 25.4,
            5: 20.5,
            6: 16.8,
            7: 13.9,
            8: 11.6,
            9: 9.8,
          },
          55: {
            1: 60.1,
            2: 40.8,
            3: 29.4,
            4: 22.5,
            5: 17.9,
            6: 14.6,
            7: 12,
            8: 9.9,
            9: 8.2,
          },
          44: {
            1: 56.9,
            2: 37.4,
            3: 26.4,
            4: 19.8,
            5: 15.6,
            6: 12.6,
            7: 10.2,
            8: 8.3,
            9: 6.8,
          },
          33: {
            1: 53.7,
            2: 34.2,
            3: 23.6,
            4: 17.3,
            5: 13.4,
            6: 10.7,
            7: 8.6,
            8: 6.9,
            9: 5.6,
          },
          22: {
            1: 50.4,
            2: 31,
            3: 20.9,
            4: 14.9,
            5: 11.4,
            6: 9,
            7: 7.1,
            8: 5.7,
            9: 4.6,
          },
          AKs: {
            1: 67,
            2: 51.2,
            3: 41.2,
            4: 34.1,
            5: 28.9,
            6: 24.9,
            7: 21.7,
            8: 19.1,
            9: 17,
          },
          AQs: {
            1: 66.1,
            2: 49.8,
            3: 39.5,
            4: 32.3,
            5: 27.2,
            6: 23.2,
            7: 20.1,
            8: 17.6,
            9: 15.6,
          },
          AJs: {
            1: 65.2,
            2: 48.4,
            3: 38,
            4: 30.7,
            5: 25.6,
            6: 21.8,
            7: 18.8,
            8: 16.4,
            9: 14.5,
          },
          ATs: {
            1: 64.3,
            2: 47.1,
            3: 36.5,
            4: 29.2,
            5: 24.2,
            6: 20.4,
            7: 17.5,
            8: 15.2,
            9: 13.3,
          },
          A9s: {
            1: 62.5,
            2: 44.9,
            3: 34.4,
            4: 27.1,
            5: 22.2,
            6: 18.6,
            7: 15.8,
            8: 13.6,
            9: 11.9,
          },
          A8s: {
            1: 61.5,
            2: 43.7,
            3: 33.2,
            4: 26,
            5: 21.1,
            6: 17.6,
            7: 14.9,
            8: 12.8,
            9: 11.1,
          },
          A7s: {
            1: 60.4,
            2: 42.4,
            3: 31.9,
            4: 24.8,
            5: 20,
            6: 16.6,
            7: 14,
            8: 12,
            9: 10.4,
          },
          A6s: {
            1: 59.3,
            2: 41.2,
            3: 30.7,
            4: 23.6,
            5: 18.9,
            6: 15.6,
            7: 13.1,
            8: 11.2,
            9: 9.7,
          },
          A5s: {
            1: 59.7,
            2: 41.6,
            3: 31.3,
            4: 24.3,
            5: 19.6,
            6: 16.2,
            7: 13.7,
            8: 11.7,
            9: 10.2,
          },
          A4s: {
            1: 58.5,
            2: 40.4,
            3: 30.1,
            4: 23.1,
            5: 18.5,
            6: 15.2,
            7: 12.8,
            8: 10.9,
            9: 9.4,
          },
          A3s: {
            1: 57.4,
            2: 39.1,
            3: 28.8,
            4: 22,
            5: 17.4,
            6: 14.3,
            7: 12,
            8: 10.2,
            9: 8.8,
          },
          A2s: {
            1: 56.2,
            2: 37.9,
            3: 27.6,
            4: 21,
            5: 16.5,
            6: 13.4,
            7: 11.2,
            8: 9.5,
            9: 8.1,
          },
          KQs: {
            1: 63.4,
            2: 46.5,
            3: 36.2,
            4: 29,
            5: 24,
            6: 20.2,
            7: 17.3,
            8: 15,
            9: 13.2,
          },
          KJs: {
            1: 62.4,
            2: 45.1,
            3: 34.6,
            4: 27.4,
            5: 22.4,
            6: 18.8,
            7: 16,
            8: 13.8,
            9: 12.1,
          },
          KTs: {
            1: 61.5,
            2: 43.8,
            3: 33.3,
            4: 26.1,
            5: 21.3,
            6: 17.8,
            7: 15.1,
            8: 13,
            9: 11.3,
          },
          K9s: {
            1: 59.5,
            2: 41.5,
            3: 31.1,
            4: 24.1,
            5: 19.4,
            6: 16.1,
            7: 13.6,
            8: 11.6,
            9: 10,
          },
          K8s: {
            1: 58.4,
            2: 40.2,
            3: 29.9,
            4: 23,
            5: 18.4,
            6: 15.2,
            7: 12.7,
            8: 10.8,
            9: 9.3,
          },
          K7s: {
            1: 57.2,
            2: 38.9,
            3: 28.7,
            4: 21.9,
            5: 17.4,
            6: 14.3,
            7: 12,
            8: 10.2,
            9: 8.7,
          },
          K6s: {
            1: 55.9,
            2: 37.5,
            3: 27.4,
            4: 20.8,
            5: 16.5,
            6: 13.5,
            7: 11.3,
            8: 9.5,
            9: 8.1,
          },
          K5s: {
            1: 54.7,
            2: 36.3,
            3: 26.3,
            4: 19.8,
            5: 15.6,
            6: 12.7,
            7: 10.6,
            8: 8.9,
            9: 7.6,
          },
          K4s: {
            1: 53.4,
            2: 35,
            3: 25.1,
            4: 18.8,
            5: 14.7,
            6: 12,
            7: 9.9,
            8: 8.3,
            9: 7,
          },
          K3s: {
            1: 52.2,
            2: 33.7,
            3: 23.9,
            4: 17.8,
            5: 13.8,
            6: 11.2,
            7: 9.2,
            8: 7.7,
            9: 6.5,
          },
          K2s: {
            1: 51,
            2: 32.5,
            3: 22.8,
            4: 16.9,
            5: 13,
            6: 10.5,
            7: 8.6,
            8: 7.2,
            9: 6,
          },
          QJs: {
            1: 60.4,
            2: 43,
            3: 32.7,
            4: 25.6,
            5: 20.7,
            6: 17.3,
            7: 14.7,
            8: 12.6,
            9: 11,
          },
          QTs: {
            1: 59.4,
            2: 41.7,
            3: 31.4,
            4: 24.4,
            5: 19.6,
            6: 16.3,
            7: 13.8,
            8: 11.8,
            9: 10.3,
          },
          Q9s: {
            1: 57.4,
            2: 39.4,
            3: 29.2,
            4: 22.4,
            5: 17.9,
            6: 14.7,
            7: 12.4,
            8: 10.5,
            9: 9.1,
          },
          Q8s: {
            1: 56.1,
            2: 38,
            3: 27.8,
            4: 21.2,
            5: 16.8,
            6: 13.8,
            7: 11.5,
            8: 9.7,
            9: 8.3,
          },
          Q7s: {
            1: 54.7,
            2: 36.6,
            3: 26.5,
            4: 19.9,
            5: 15.7,
            6: 12.8,
            7: 10.7,
            8: 9,
            9: 7.6,
          },
          Q6s: {
            1: 53.4,
            2: 35.2,
            3: 25.3,
            4: 18.9,
            5: 14.8,
            6: 12,
            7: 10,
            8: 8.4,
            9: 7.1,
          },
          Q5s: {
            1: 52.1,
            2: 33.9,
            3: 24.2,
            4: 17.9,
            5: 13.9,
            6: 11.3,
            7: 9.3,
            8: 7.8,
            9: 6.6,
          },
          Q4s: {
            1: 50.8,
            2: 32.6,
            3: 23,
            4: 16.9,
            5: 13.1,
            6: 10.6,
            7: 8.7,
            8: 7.2,
            9: 6.1,
          },
          Q3s: {
            1: 49.6,
            2: 31.3,
            3: 21.8,
            4: 15.9,
            5: 12.3,
            6: 9.9,
            7: 8.1,
            8: 6.7,
            9: 5.6,
          },
          Q2s: {
            1: 48.4,
            2: 30.1,
            3: 20.8,
            4: 15.1,
            5: 11.6,
            6: 9.3,
            7: 7.6,
            8: 6.3,
            9: 5.3,
          },
          JTs: {
            1: 57.3,
            2: 40,
            3: 29.9,
            4: 23,
            5: 18.4,
            6: 15.2,
            7: 12.8,
            8: 11,
            9: 9.5,
          },
          J9s: {
            1: 55.2,
            2: 37.7,
            3: 27.7,
            4: 21,
            5: 16.6,
            6: 13.6,
            7: 11.4,
            8: 9.6,
            9: 8.2,
          },
          J8s: {
            1: 53.8,
            2: 36.2,
            3: 26.3,
            4: 19.7,
            5: 15.5,
            6: 12.6,
            7: 10.5,
            8: 8.8,
            9: 7.5,
          },
          J7s: {
            1: 52.3,
            2: 34.7,
            3: 24.9,
            4: 18.5,
            5: 14.4,
            6: 11.7,
            7: 9.7,
            8: 8.1,
            9: 6.8,
          },
          J6s: {
            1: 50.8,
            2: 33.3,
            3: 23.6,
            4: 17.4,
            5: 13.4,
            6: 10.8,
            7: 8.9,
            8: 7.4,
            9: 6.2,
          },
          J5s: {
            1: 49.4,
            2: 31.9,
            3: 22.3,
            4: 16.3,
            5: 12.5,
            6: 10.1,
            7: 8.3,
            8: 6.9,
            9: 5.7,
          },
          J4s: {
            1: 48,
            2: 30.6,
            3: 21.2,
            4: 15.3,
            5: 11.7,
            6: 9.4,
            7: 7.7,
            8: 6.4,
            9: 5.3,
          },
          J3s: {
            1: 46.7,
            2: 29.3,
            3: 20.1,
            4: 14.4,
            5: 11,
            6: 8.8,
            7: 7.2,
            8: 5.9,
            9: 4.9,
          },
          J2s: {
            1: 45.4,
            2: 28,
            3: 19,
            4: 13.6,
            5: 10.3,
            6: 8.2,
            7: 6.7,
            8: 5.5,
            9: 4.6,
          },
          T9s: {
            1: 54.2,
            2: 37,
            3: 27.2,
            4: 20.8,
            5: 16.5,
            6: 13.6,
            7: 11.4,
            8: 9.7,
            9: 8.4,
          },
          T8s: {
            1: 52,
            2: 34.9,
            3: 25.2,
            4: 18.9,
            5: 14.8,
            6: 12,
            7: 10,
            8: 8.4,
            9: 7.1,
          },
          T7s: {
            1: 50.5,
            2: 33.4,
            3: 23.8,
            4: 17.7,
            5: 13.7,
            6: 11,
            7: 9.1,
            8: 7.6,
            9: 6.4,
          },
          T6s: {
            1: 48.9,
            2: 31.8,
            3: 22.4,
            4: 16.5,
            5: 12.7,
            6: 10.2,
            7: 8.4,
            8: 6.9,
            9: 5.8,
          },
          "98s": {
            1: 51.3,
            2: 34.3,
            3: 24.8,
            4: 18.8,
            5: 14.8,
            6: 12.1,
            7: 10.1,
            8: 8.6,
            9: 7.3,
          },
          "97s": {
            1: 49.1,
            2: 32.2,
            3: 22.8,
            4: 17,
            5: 13.2,
            6: 10.7,
            7: 8.8,
            8: 7.4,
            9: 6.2,
          },
          "96s": {
            1: 47.4,
            2: 30.6,
            3: 21.4,
            4: 15.8,
            5: 12.2,
            6: 9.8,
            7: 8,
            8: 6.7,
            9: 5.6,
          },
          "87s": {
            1: 48.5,
            2: 31.7,
            3: 22.5,
            4: 16.9,
            5: 13.2,
            6: 10.7,
            8: 7.5,
            9: 6.4,
            7: 8.9,
          },
          "86s": {
            1: 46.2,
            2: 29.6,
            3: 20.6,
            4: 15.1,
            5: 11.7,
            6: 9.4,
            7: 7.7,
            8: 6.4,
            9: 5.4,
          },
          "76s": {
            1: 45.7,
            2: 29.2,
            3: 20.4,
            4: 15.1,
            5: 11.8,
            6: 9.5,
            7: 7.9,
            8: 6.6,
            9: 5.6,
          },
          "75s": {
            1: 43.5,
            2: 27.1,
            3: 18.6,
            4: 13.6,
            5: 10.5,
            6: 8.4,
            7: 6.9,
            8: 5.7,
            9: 4.8,
          },
          "65s": {
            1: 43.4,
            2: 27.2,
            3: 18.8,
            4: 13.8,
            5: 10.7,
            6: 8.6,
            7: 7.1,
            8: 5.9,
            9: 5,
          },
          "54s": {
            1: 42.2,
            2: 26.2,
            3: 18,
            4: 13.2,
            5: 10.2,
            6: 8.1,
            7: 6.7,
            8: 5.5,
            9: 4.6,
          },
          AKo: {
            1: 65,
            2: 48.6,
            3: 38.3,
            4: 31.1,
            5: 25.9,
            6: 22,
            7: 18.9,
            8: 16.4,
            9: 14.4,
          },
          AQo: {
            1: 64,
            2: 47.1,
            3: 36.5,
            4: 29.3,
            5: 24.2,
            6: 20.3,
            7: 17.3,
            8: 15,
            9: 13.1,
          },
          AJo: {
            1: 63.1,
            2: 45.7,
            3: 35,
            4: 27.8,
            5: 22.8,
            6: 19,
            7: 16.2,
            8: 14,
            9: 12.2,
          },
          ATo: {
            1: 62.1,
            2: 44.4,
            3: 33.6,
            4: 26.3,
            5: 21.4,
            6: 17.8,
            7: 15.1,
            8: 13,
            9: 11.3,
          },
          A9o: {
            1: 60.1,
            2: 42,
            3: 31.3,
            4: 24.2,
            5: 19.5,
            6: 16,
            7: 13.5,
            8: 11.5,
            9: 9.9,
          },
          A8o: {
            1: 59.1,
            2: 40.8,
            3: 30.1,
            4: 23.1,
            5: 18.4,
            6: 15.1,
            7: 12.6,
            8: 10.8,
            9: 9.3,
          },
          A7o: {
            1: 57.9,
            2: 39.4,
            3: 28.8,
            4: 21.9,
            5: 17.4,
            6: 14.2,
            7: 11.8,
            8: 10,
            9: 8.6,
          },
          A6o: {
            1: 56.7,
            2: 38.1,
            3: 27.5,
            4: 20.8,
            5: 16.4,
            6: 13.3,
            7: 11.1,
            8: 9.4,
            9: 8,
          },
          A5o: {
            1: 55.4,
            2: 36.8,
            3: 26.4,
            4: 19.8,
            5: 15.5,
            6: 12.6,
            7: 10.5,
            8: 8.8,
            9: 7.5,
          },
          A4o: {
            1: 54.2,
            2: 35.5,
            3: 25.2,
            4: 18.8,
            5: 14.7,
            6: 11.9,
            7: 9.8,
            8: 8.2,
            9: 7,
          },
          A3o: {
            1: 53,
            2: 34.2,
            3: 24.1,
            4: 17.8,
            5: 13.8,
            6: 11.1,
            7: 9.2,
            8: 7.7,
            9: 6.5,
          },
          A2o: {
            1: 51.8,
            2: 32.9,
            3: 22.9,
            4: 16.8,
            5: 13,
            6: 10.4,
            7: 8.6,
            8: 7.2,
            9: 6.1,
          },
          KQo: {
            1: 61.2,
            2: 43.6,
            3: 33.2,
            4: 26.1,
            5: 21.2,
            6: 17.6,
            7: 14.9,
            8: 12.8,
            9: 11.1,
          },
          KJo: {
            1: 60.1,
            2: 42.2,
            3: 31.7,
            4: 24.6,
            5: 19.8,
            6: 16.4,
            7: 13.8,
            8: 11.8,
            9: 10.2,
          },
          KTo: {
            1: 59.1,
            2: 40.8,
            3: 30.3,
            4: 23.3,
            5: 18.6,
            6: 15.3,
            7: 12.8,
            8: 11,
            9: 9.5,
          },
          K9o: {
            1: 56.9,
            2: 38.4,
            3: 28.1,
            4: 21.3,
            5: 16.8,
            6: 13.7,
            7: 11.3,
            8: 9.6,
            9: 8.2,
          },
          K8o: {
            1: 55.7,
            2: 37,
            3: 26.8,
            4: 20.1,
            5: 15.8,
            6: 12.8,
            7: 10.5,
            8: 8.9,
            9: 7.6,
          },
          K7o: {
            1: 54.5,
            2: 35.7,
            3: 25.6,
            4: 19.1,
            5: 14.8,
            6: 11.9,
            7: 9.8,
            8: 8.2,
            9: 7,
          },
          K6o: {
            1: 53.1,
            2: 34.2,
            3: 24.2,
            4: 17.9,
            5: 13.8,
            6: 11.1,
            7: 9.1,
            8: 7.6,
            9: 6.4,
          },
          K5o: {
            1: 51.7,
            2: 32.8,
            3: 22.9,
            4: 16.8,
            5: 12.8,
            6: 10.3,
            7: 8.4,
            8: 7,
            9: 5.9,
          },
          K4o: {
            1: 50.3,
            2: 31.4,
            3: 21.7,
            4: 15.8,
            5: 11.9,
            6: 9.5,
            7: 7.8,
            8: 6.4,
            9: 5.4,
          },
          K3o: {
            1: 48.9,
            2: 30,
            3: 20.5,
            4: 14.8,
            5: 11.1,
            6: 8.8,
            7: 7.2,
            8: 5.9,
            9: 4.9,
          },
          K2o: {
            1: 47.6,
            2: 28.7,
            3: 19.4,
            4: 13.8,
            5: 10.3,
            6: 8.2,
            7: 6.6,
            8: 5.4,
            9: 4.5,
          },
          QJo: {
            1: 58,
            2: 40,
            3: 29.8,
            4: 22.8,
            5: 18.2,
            6: 15,
            7: 12.6,
            8: 10.7,
            9: 9.3,
          },
          QTo: {
            1: 56.9,
            2: 38.6,
            3: 28.5,
            4: 21.6,
            5: 17.1,
            6: 14,
            7: 11.7,
            8: 9.9,
            9: 8.5,
          },
          Q9o: {
            1: 54.7,
            2: 36.2,
            3: 26.2,
            4: 19.5,
            5: 15.2,
            6: 12.3,
            7: 10.1,
            8: 8.5,
            9: 7.2,
          },
          Q8o: {
            1: 53.3,
            2: 34.7,
            3: 24.8,
            4: 18.3,
            5: 14.2,
            6: 11.4,
            7: 9.4,
            8: 7.8,
            9: 6.6,
          },
          Q7o: {
            1: 51.9,
            2: 33.2,
            3: 23.5,
            4: 17.2,
            5: 13.2,
            6: 10.6,
            7: 8.7,
            8: 7.2,
            9: 6,
          },
          Q6o: {
            1: 50.5,
            2: 31.8,
            3: 22.2,
            4: 16.1,
            5: 12.3,
            6: 9.8,
            7: 8,
            8: 6.6,
            9: 5.5,
          },
          Q5o: {
            1: 49,
            2: 30.4,
            3: 21,
            4: 15.1,
            5: 11.5,
            6: 9.1,
            7: 7.4,
            8: 6.1,
            9: 5.1,
          },
          Q4o: {
            1: 47.6,
            2: 29,
            3: 19.8,
            4: 14.1,
            5: 10.7,
            6: 8.4,
            7: 6.8,
            8: 5.6,
            9: 4.7,
          },
          Q3o: {
            1: 46.2,
            2: 27.6,
            3: 18.7,
            4: 13.2,
            5: 9.9,
            6: 7.8,
            7: 6.3,
            8: 5.2,
            9: 4.3,
          },
          Q2o: {
            1: 44.9,
            2: 26.3,
            3: 17.6,
            4: 12.4,
            5: 9.2,
            6: 7.2,
            7: 5.8,
            8: 4.8,
            9: 3.9,
          },
          JTo: {
            1: 54.8,
            2: 36.9,
            3: 27,
            4: 20.2,
            5: 15.9,
            6: 13,
            7: 10.8,
            8: 9.2,
            9: 7.9,
          },
          J9o: {
            1: 52.6,
            2: 34.5,
            3: 24.7,
            4: 18.2,
            5: 14.1,
            6: 11.4,
            7: 9.4,
            8: 7.9,
            9: 6.7,
          },
          J8o: {
            1: 51.1,
            2: 32.9,
            3: 23.3,
            4: 17,
            5: 13.1,
            6: 10.5,
            7: 8.6,
            8: 7.2,
            9: 6,
          },
          J7o: {
            1: 49.5,
            2: 31.4,
            3: 21.9,
            4: 15.8,
            5: 12.1,
            6: 9.6,
            7: 7.8,
            8: 6.5,
            9: 5.4,
          },
          T9o: {
            1: 51.5,
            2: 33.8,
            3: 24.3,
            4: 18,
            5: 14,
            6: 11.3,
            7: 9.4,
            8: 7.9,
            9: 6.7,
          },
          T8o: {
            1: 49.2,
            2: 31.6,
            3: 22.3,
            4: 16.3,
            5: 12.5,
            6: 10,
            7: 8.2,
            8: 6.8,
            9: 5.7,
          },
          "98o": {
            1: 48.4,
            2: 31,
            3: 21.9,
            4: 16.1,
            5: 12.4,
            6: 10,
            7: 8.2,
            8: 6.9,
            9: 5.8,
          },
          "97o": {
            1: 46.1,
            2: 28.9,
            3: 20,
            4: 14.5,
            5: 11.1,
            6: 8.8,
            7: 7.2,
            8: 6,
            9: 5,
          },
          "87o": {
            1: 45.4,
            2: 28.3,
            3: 19.6,
            4: 14.3,
            5: 11,
            6: 8.8,
            7: 7.2,
            8: 6,
            9: 5,
          },
          "86o": {
            1: 42.9,
            2: 26.1,
            3: 17.8,
            4: 12.8,
            5: 9.7,
            6: 7.7,
            7: 6.2,
            8: 5.1,
            9: 4.3,
          },
          "76o": {
            1: 42.4,
            2: 25.6,
            3: 17.5,
            4: 12.6,
            5: 9.6,
            6: 7.6,
            7: 6.2,
            8: 5.1,
            9: 4.3,
          },
          "72o": {
            1: 32.3,
            2: 19,
            3: 13.3,
            4: 9.7,
            5: 7.4,
            6: 5.9,
            7: 4.8,
            8: 4,
            9: 3.3,
          },
        };
        const VIRIDIS_PALETTE = [
          [0.267, 0.00487, 0.329],
          [0.282, 0.1, 0.422],
          [0.274, 0.199, 0.495],
          [0.247, 0.294, 0.542],
          [0.211, 0.387, 0.563],
          [0.174, 0.481, 0.561],
          [0.141, 0.573, 0.54],
          [0.122, 0.665, 0.506],
          [0.134, 0.755, 0.459],
          [0.208, 0.838, 0.389],
          [0.327, 0.914, 0.299],
          [0.48, 0.973, 0.207],
          [0.655, 1.012, 0.135],
          [0.84, 1.025, 0.106],
          [0.993, 1.009, 0.128],
        ];
        const appState = {
          numOpponents: 8,
          selectedHand: null,
          currentTheoretical: null,
          theoreticalCache: new Map(),
          currentDeal: null,
          latestLiveResult: { omniscient: null, fog: null },
          showOpponentCards: false,
          equityHistory: [],
          sensitivityMode: "fog",
          previousBoardCount: 0,
        };

        // SECTION 2: UI & UTILITIES
        function getViridisColor(t) {
          t = Math.max(0, Math.min(1, t));
          const i = Math.floor(t * (VIRIDIS_PALETTE.length - 1));
          const f = t * (VIRIDIS_PALETTE.length - 1) - i;
          const c1 = VIRIDIS_PALETTE[i];
          const c2 =
            VIRIDIS_PALETTE[Math.min(VIRIDIS_PALETTE.length - 1, i + 1)];
          const r = (c1[0] + (c2[0] - c1[0]) * f) * 255;
          const g = (c1[1] + (c2[1] - c1[1]) * f) * 255;
          const b = (c1[2] + (c2[2] - c1[2]) * f) * 255;
          return `rgb(${r},${g},${b})`;
        }
        function getEquityColor(equity) {
          const minEquity = 5;
          const maxEquity = 85;
          const normalized = (equity - minEquity) / (maxEquity - minEquity);
          return getViridisColor(normalized);
        }
        function renderHeatmap() {
          const heatmap = document.getElementById("heatmap");
          heatmap.innerHTML = "";
          RANKS.forEach((r1, i) => {
            RANKS.forEach((r2, j) => {
              const cell = document.createElement("div");
              cell.classList.add("heatmap-cell");
              let hand =
                i < j ? r1 + r2 + "s" : i > j ? r2 + r1 + "o" : r1 + r2;
              cell.textContent = hand.replace(/[so]/, "");
              cell.dataset.hand = hand;
              heatmap.appendChild(cell);
            });
          });
        }
        function updateHeatmapColors() {
          document.querySelectorAll(".heatmap-cell").forEach((cell) => {
            const equity =
              (equityData[cell.dataset.hand] &&
                equityData[cell.dataset.hand][appState.numOpponents]) ||
              0;
            cell.style.backgroundColor = getEquityColor(equity);
          });
        }
        function createCardElement(cardStr) {
          const cardDiv = document.createElement("div");
          if (!cardStr) {
            cardDiv.className = "card card-back";
            return cardDiv;
          }
          const rank = cardStr.slice(0, -1);
          const suit = cardStr.slice(-1);
          const suitSymbols = { s: "â™ ", h: "â™¥", d: "â™¦", c: "â™£" };
          const colorClass = suit === "h" || suit === "d" ? "red" : "black";
          cardDiv.className = `card ${colorClass}`;
          cardDiv.innerHTML = `${rank}<br>${suitSymbols[suit]}`;
          return cardDiv;
        }
        function renderPokerTable(showdown = false, winners = [], winningHands = []) {
          const table = document.getElementById("poker-table-area");
          const heroDiv = document.getElementById("hero-hand-container");
          const boardDiv = document.getElementById("board-cards-container");
          if (!table || !heroDiv || !boardDiv) return;

          heroDiv.innerHTML = "";
          heroDiv.classList.remove("winner", "leader");
          boardDiv.innerHTML = "";
          table
            .querySelectorAll(".opponent-position")
            .forEach((el) => el.remove());

          if (!appState.currentDeal) {
            // Show static display before dealing
            const heroCards = appState.selectedHand
              ? displayHandFromString(appState.selectedHand)
              : [];
            heroCards.forEach((c) => heroDiv.appendChild(createCardElement(c)));

            const opponents = appState.numOpponents;
            const radius = 45;
            const angleStep = 360 / (opponents + 1);
            for (let i = 0; i < opponents; i++) {
              const angle = ((90 + (i + 1) * angleStep) * Math.PI) / 180;
              const x = 50 + radius * Math.cos(angle);
              const y = 50 + radius * Math.sin(angle) * 0.75;
              const oppDiv = document.createElement("div");
              oppDiv.className = "opponent-position hand-display";
              oppDiv.style.left = `${x}%`;
              oppDiv.style.top = `${y}%`;
              oppDiv.appendChild(createCardElement(null));
              oppDiv.appendChild(createCardElement(null));
              table.appendChild(oppDiv);
            }
            appState.previousBoardCount = 0;
            return;
          }

          // Show live dealt cards
          const { heroHand, opponentHands, board, street } = appState.currentDeal;
          const showCards = showdown || appState.showOpponentCards;

          heroHand.forEach((c) => {
            const card = createCardElement(c);
            if (winningHands[0] && winningHands[0].includes(c)) {
              card.classList.add("winning-card");
            }
            heroDiv.appendChild(card);
          });
          heroDiv.classList.toggle("winner", winners.includes(0));

          const radius = 45;
          const angleStep = 360 / (appState.numOpponents + 1);
          opponentHands.forEach((hand, i) => {
            const angle = ((90 + (i + 1) * angleStep) * Math.PI) / 180;
            const x = 50 + radius * Math.cos(angle);
            const y = 50 + radius * Math.sin(angle) * 0.75;
            const oppDiv = document.createElement("div");
            oppDiv.className = "opponent-position hand-display";
            oppDiv.style.left = `${x}%`;
            oppDiv.style.top = `${y}%`;

            const card1 = createCardElement(showCards ? hand[0] : null);
            const card2 = createCardElement(showCards ? hand[1] : null);
            const playerIndex = i + 1;
            if (winningHands[playerIndex] && showCards) {
              if (winningHands[playerIndex].includes(hand[0])) card1.classList.add("winning-card");
              if (winningHands[playerIndex].includes(hand[1])) card2.classList.add("winning-card");
            }
            oppDiv.appendChild(card1);
            oppDiv.appendChild(card2);
            oppDiv.classList.toggle("winner", winners.includes(playerIndex));

            const label = document.createElement("div");
            label.className = "position-label";
            label.textContent = `Opp ${i + 1}`;
            oppDiv.appendChild(label);

            table.appendChild(oppDiv);
          });

          const boardCards =
            street === "preflop"
              ? []
              : board.slice(
                  0,
                  street === "flop" ? 3 : street === "turn" ? 4 : 5
                );
          const previousBoard = appState.previousBoardCount || 0;
          boardCards.forEach((c, idx) => {
            const card = createCardElement(c);
            // Check if this board card is part of any winning hand
            if (showdown && winningHands.some(wh => wh && wh.includes(c))) {
              card.classList.add("winning-card");
            }
            if (idx >= previousBoard) {
              card.classList.add("board-enter");
            }
            boardDiv.appendChild(card);
          });
          appState.previousBoardCount = boardCards.length;
        }

        function displayHandFromString(handStr) {
          if (!handStr || handStr.length < 2) return [];
          const r1 = handStr[0];
          const r2 = handStr[1];
          if (handStr.length === 2) {
            return [r1 + "s", r1 + "h"];
          }
          if (handStr[2] === "s") {
            return [r1 + "s", r2 + "s"];
          }
          return [r1 + "s", r2 + "h"];
        }
        function resetUIForNewSelection() {
          document.getElementById("selected-hand-title").textContent =
            appState.selectedHand || "No Hand Selected";
          appState.currentTheoretical = null;
          appState.latestLiveResult = { omniscient: null, fog: null };
          appState.currentDeal = null;
          appState.showOpponentCards = false;
          appState.equityHistory = [];
          appState.sensitivityMode = "fog";
          appState.previousBoardCount = 0;
          updateEquityDisplay(null, null);
          document.getElementById("preflop-charts-grid").innerHTML =
            '<div class="info-box" style="grid-column: 1 / -1; text-align: center;"><p>Select a hand to see its analysis.</p></div>';
          document.getElementById("live-charts-section").style.display = "none";
          document.getElementById("equity-explainer").style.display = "none";
          document.getElementById("equity-delta-row").style.display = "none";
          document.getElementById("suit-tracker-section").style.display = "none";
          document.getElementById("sensitivity-section").style.display = "none";
          document.getElementById("sensitivity-table-container").innerHTML = "";
          document
            .querySelectorAll(".sensitivity-controls .sim-button")
            .forEach((btn) => btn.classList.remove("active"));
          document.getElementById("start-interactive-btn").disabled = !appState.selectedHand;
          document.getElementById("start-interactive-btn").style.display = "inline-block";
          document.getElementById("deal-street-btn").style.display = "none";
          document.getElementById("reset-hand-btn").style.display = "none";
          document.getElementById("toggle-cards-btn").style.display = "none";
          renderPokerTable();
        }
        function updateEquityDisplay(theoretical, live) {
          const theoreticalEl = document.getElementById(
            "theoretical-equity-val"
          );
          const theoreticalMetaEl = document.getElementById(
            "theoretical-equity-meta"
          );
          const hiddenEl = document.getElementById("live-equity-hidden-val");
          const hiddenMetaEl = document.getElementById(
            "live-equity-hidden-meta"
          );
          const knownEl = document.getElementById("live-equity-known-val");
          const knownMetaEl = document.getElementById("live-equity-known-meta");
          const deltaRow = document.getElementById("equity-delta-row");
          const deltaPill = document.getElementById("equity-delta-pill");
          const explainer = document.getElementById("equity-explainer");

          const fog = live && live.fog ? live.fog : null;
          const omniscient = live && live.omniscient ? live.omniscient : null;

          if (theoreticalEl) {
            if (theoretical && typeof theoretical.equity === "number") {
              theoreticalEl.textContent = `${theoretical.equity.toFixed(1)}%`;
              theoreticalEl.title = theoretical.samples
                ? `Simulated over ${theoretical.samples} samples`
                : `Precomputed table value`;
              if (theoreticalMetaEl) {
                theoreticalMetaEl.textContent = theoretical.samples
                  ? `Monte Carlo (${theoretical.samples.toLocaleString()} runs)`
                  : `Lookup table`;
              }
            } else {
              theoreticalEl.textContent = "--";
              theoreticalEl.removeAttribute("title");
              if (theoreticalMetaEl) theoreticalMetaEl.textContent = "";
            }
          }

          const setLiveBox = (el, metaEl, result) => {
            if (!el) return;
            if (result && typeof result.equity === "number") {
              el.textContent = `${result.equity.toFixed(1)}%`;
              const stderrVal =
                result.stderr && !Number.isNaN(result.stderr)
                  ? result.stderr.toFixed(2)
                  : null;
              const titleBits = [];
              if (stderrVal) titleBits.push(`Std Err Â±${stderrVal}%`);
              if (typeof result.ties === "number" && result.samples) {
                titleBits.push(`Ties ${(result.ties / result.samples * 100).toFixed(1)}%`);
              }
              if (titleBits.length) {
                el.title = titleBits.join(" Â· ");
              } else {
                el.removeAttribute("title");
              }
              if (metaEl) {
                const metaParts = [];
                if (result.samples) {
                  metaParts.push(`${result.samples.toLocaleString()} sims`);
                }
                if (stderrVal) {
                  metaParts.push(`Â±${stderrVal}%`);
                }
                if (typeof result.ties === "number" && result.samples) {
                  metaParts.push(`ties ${(result.ties / result.samples * 100).toFixed(1)}%`);
                }
                metaEl.textContent = metaParts.join(" Â· ");
              }
            } else {
              el.textContent = "--";
              el.removeAttribute("title");
              if (metaEl) metaEl.textContent = "";
            }
          };

          setLiveBox(hiddenEl, hiddenMetaEl, fog);
          setLiveBox(knownEl, knownMetaEl, omniscient);

          if (fog && omniscient) {
            const delta = fog.equity - omniscient.equity;
            const rounded = delta.toFixed(1);
            deltaRow.style.display = "flex";
            deltaPill.textContent = `Î” Unknown - Revealed: ${delta >= 0 ? "+" : ""}${rounded}%`;
            deltaPill.classList.remove("positive", "negative");
            if (Math.abs(delta) < 0.15) {
              deltaPill.classList.remove("positive", "negative");
            } else if (delta > 0) {
              deltaPill.classList.add("positive");
              deltaPill.classList.remove("negative");
            } else {
              deltaPill.classList.add("negative");
              deltaPill.classList.remove("positive");
            }
            renderEquitySparkline(appState.equityHistory);
          } else {
            deltaRow.style.display = "none";
            const spark = document.getElementById("equity-delta-sparkline");
            if (spark) spark.innerHTML = "";
          }

          if (explainer) {
            explainer.style.display = fog || omniscient ? "block" : "none";
          }
        }


        // SECTION 3: POKER LOGIC & SIMULATION
        function createDeck() {
          return SUITS.flatMap((s) => RANKS.map((r) => r + s));
        }
        function shuffleDeck(deck) {
          for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
          }
          return deck;
        }
        function handStringToCards(handStr) {
          const r1 = handStr[0],
            r2 = handStr[1];

          // For pairs, return same rank with different suits
          if (handStr.length === 2) {
            const suit1 = SUITS[Math.floor(Math.random() * SUITS.length)];
            const availableSuits = SUITS.filter(s => s !== suit1);
            const suit2 = availableSuits[Math.floor(Math.random() * availableSuits.length)];
            return [r1 + suit1, r1 + suit2];
          }

          // For suited hands, pick a random suit for both cards
          if (handStr[2] === "s") {
            const suit = SUITS[Math.floor(Math.random() * SUITS.length)];
            return [r1 + suit, r2 + suit];
          }

          // For offsuit hands, pick two different random suits
          const suit1 = SUITS[Math.floor(Math.random() * SUITS.length)];
          const availableSuits = SUITS.filter(s => s !== suit1);
          const suit2 = availableSuits[Math.floor(Math.random() * availableSuits.length)];
          return [r1 + suit1, r2 + suit2];
        }
        function evaluateHand(sevenCards) {
          const rankValues = "23456789TJQKA";
          const cardRanks = sevenCards
            .map((c) => rankValues.indexOf(c[0]))
            .sort((a, b) => b - a);
          const cardSuits = sevenCards.map((c) => c[1]);
          const rankCounts = cardRanks.reduce(
            (acc, r) => ((acc[r] = (acc[r] || 0) + 1), acc),
            {}
          );
          const suitCounts = cardSuits.reduce(
            (acc, s) => ((acc[s] = (acc[s] || 0) + 1), acc),
            {}
          );
          const isFlush = Object.values(suitCounts).some((c) => c >= 5);
          const flushSuit = isFlush
            ? Object.keys(suitCounts).find((s) => suitCounts[s] >= 5)
            : null;
          const flushRanks = isFlush
            ? sevenCards
                .filter((c) => c[1] === flushSuit)
                .map((c) => rankValues.indexOf(c[0]))
                .sort((a, b) => b - a)
            : [];
          const uniqueRanks = [...new Set(cardRanks)];
          let isStraight = false,
            straightHighRank = -1;
          if ([12, 3, 2, 1, 0].every((r) => uniqueRanks.includes(r))) {
            isStraight = true;
            straightHighRank = 3;
          } else {
            for (let i = 0; i <= uniqueRanks.length - 5; i++) {
              if (uniqueRanks[i] - uniqueRanks[i + 4] === 4) {
                isStraight = true;
                straightHighRank = uniqueRanks[i];
                break;
              }
            }
          }
          let isStraightFlush = false,
            sfHighRank = -1;
          if (isFlush) {
            const uniqueFlushRanks = [...new Set(flushRanks)];
            if ([12, 3, 2, 1, 0].every((r) => uniqueFlushRanks.includes(r))) {
              isStraightFlush = true;
              sfHighRank = 3;
            } else {
              for (let i = 0; i <= uniqueFlushRanks.length - 5; i++) {
                if (uniqueFlushRanks[i] - uniqueFlushRanks[i + 4] === 4) {
                  isStraightFlush = true;
                  sfHighRank = uniqueFlushRanks[i];
                  break;
                }
              }
            }
          }
          if (isStraightFlush) return [8, sfHighRank];
          const counts = Object.values(rankCounts).sort((a, b) => b - a);
          const rankKeys = Object.keys(rankCounts)
            .sort((a, b) => rankCounts[b] - rankCounts[a] || b - a)
            .map(Number);
          if (counts[0] === 4) return [7, rankKeys[0], rankKeys[1]];
          if (counts[0] === 3 && counts[1] >= 2)
            return [6, rankKeys[0], rankKeys[1]];
          if (isFlush) return [5, ...flushRanks.slice(0, 5)];
          if (isStraight) return [4, straightHighRank];
          if (counts[0] === 3) return [3, rankKeys[0], ...rankKeys.slice(1, 3)];
          if (counts[0] === 2 && counts[1] === 2)
            return [2, rankKeys[0], rankKeys[1], rankKeys[2]];
          if (counts[0] === 2) return [1, rankKeys[0], ...rankKeys.slice(1, 4)];
          return [0, ...cardRanks.slice(0, 5)];
        }
        function compareScores(sA, sB) {
          for (let i = 0; i < sA.length; i++) {
            if (sA[i] > sB[i]) return 1;
            if (sA[i] < sB[i]) return -1;
          }
          return 0;
        }

        function getSamplesForStreet(street) {
          return SIM_SAMPLES_BY_STREET[street] || 1200;
        }

        function computeEquityForDeal(
          heroHand,
          opponentHands,
          boardCards,
          options = {}
        ) {
          const { mode = "omniscient", samples, trackNextCard = false } = options;
          const opponentsCount = opponentHands.length;
          const knownCards = new Set([...heroHand, ...boardCards]);
          if (mode === "omniscient") {
            opponentHands.flat().forEach((c) => knownCards.add(c));
          }
          const baseDeck = createDeck().filter((card) => !knownCards.has(card));
          const cardsNeeded = Math.max(0, 5 - boardCards.length);
          const requestedSamples =
            samples && samples > 0 ? Math.floor(samples) : 1000;
          const totalSims =
            mode === "omniscient" && cardsNeeded === 0 ? 1 : requestedSamples;

          let wins = 0;
          let ties = 0;
          let sum = 0;
          let sumSq = 0;
          const handDistribution = new Array(9).fill(0);
          const impactMap = trackNextCard ? new Map() : null;

          for (let sim = 0; sim < totalSims; sim++) {
            const deckCopy =
              cardsNeeded > 0 || mode === "fog"
                ? shuffleDeck([...baseDeck])
                : [...baseDeck];

            const simOpponents =
              mode === "omniscient"
                ? opponentHands
                : Array.from({ length: opponentsCount }, () => [
                    deckCopy.pop(),
                    deckCopy.pop(),
                  ]);

            const fullBoard = [...boardCards];
            while (fullBoard.length < 5) {
              fullBoard.push(deckCopy.pop());
            }

            const heroScore = evaluateHand([...heroHand, ...fullBoard]);
            handDistribution[heroScore[0]]++;

            const opponentScores = simOpponents.map((hand) =>
              evaluateHand([...hand, ...fullBoard])
            );

            let heroWins = true;
            let isTie = false;
            for (const oppScore of opponentScores) {
              const cmp = compareScores(heroScore, oppScore);
              if (cmp < 0) {
                heroWins = false;
                isTie = false;
                break;
              } else if (cmp === 0) {
                isTie = true;
              }
            }

            if (heroWins && isTie) {
              ties++;
            } else if (heroWins) {
              wins++;
            }

            const outcome = heroWins ? (isTie ? 0.5 : 1) : 0;
            sum += outcome;
            sumSq += outcome * outcome;

            if (impactMap && cardsNeeded > 0) {
              const keyCard = fullBoard[boardCards.length];
              if (keyCard) {
                const entry = impactMap.get(keyCard) || { sum: 0, count: 0 };
                entry.sum += outcome;
                entry.count += 1;
                impactMap.set(keyCard, entry);
              }
            }
          }

          const mean = sum / totalSims;
          const equity = mean * 100;
          const variance = Math.max(0, sumSq / totalSims - mean * mean);
          const stderr = Math.sqrt(variance / totalSims) * 100;

          const result = {
            equity,
            samples: totalSims,
            handDistribution,
            wins,
            ties,
            stderr,
            mode,
            nextCardImpacts: [],
          };

          if (impactMap && impactMap.size) {
            result.nextCardImpacts = Array.from(impactMap.entries()).map(
              ([card, stats]) => ({
                card,
                equity: (stats.sum / stats.count) * 100,
                delta: (stats.sum / stats.count) * 100 - equity,
                count: stats.count,
              })
            );
          }

          return result;
        }

        function startInteractiveHand() {
          if (!appState.selectedHand) return;

          const heroCards = handStringToCards(appState.selectedHand);
          const deck = shuffleDeck(
            createDeck().filter((c) => !heroCards.includes(c))
          );
          const opponentHands = Array.from(
            { length: appState.numOpponents },
            () => [deck.pop(), deck.pop()]
          );
          const board = Array.from({ length: 5 }, () => deck.pop());

          appState.currentDeal = {
            street: "preflop",
            deck,
            heroHand: heroCards,
            opponentHands,
            board,
          };
          appState.previousBoardCount = 0;

          document.getElementById("start-interactive-btn").style.display = "none";
          const dealBtn = document.getElementById("deal-street-btn");
          dealBtn.style.display = "inline-block";
          dealBtn.textContent = "Deal Flop";
          dealBtn.disabled = false;
          document.getElementById("reset-hand-btn").style.display = "inline-block";
          document.getElementById("toggle-cards-btn").style.display = "inline-block";
          document.getElementById("live-charts-section").style.display = "block";
          document.getElementById("equity-explainer").style.display = "block";

          updateLiveAnalysis();
        }

        function dealNextStreet() {
          if (!appState.currentDeal) return;
          const dealBtn = document.getElementById("deal-street-btn");
          dealBtn.disabled = true;

          const streets = ["preflop", "flop", "turn", "river"];
          const currentIdx = streets.indexOf(appState.currentDeal.street);
          if (currentIdx < streets.length - 1) {
            appState.currentDeal.street = streets[currentIdx + 1];
          }

          updateLiveAnalysis();
          const nextIdx = streets.indexOf(appState.currentDeal.street) + 1;
          if (nextIdx < streets.length) {
            dealBtn.textContent = `Deal ${
              streets[nextIdx].charAt(0).toUpperCase() + streets[nextIdx].slice(1)
            }`;
            dealBtn.disabled = false;
          } else {
            dealBtn.textContent = "Showdown!";
            handleShowdown();
          }
        }

        function updateLiveAnalysis() {
          renderPokerTable();
          const { heroHand, opponentHands, board, street } = appState.currentDeal;
          const boardCards =
            street === "preflop"
              ? []
              : board.slice(
                  0,
                  street === "flop" ? 3 : street === "turn" ? 4 : 5
                );

          const samples = getSamplesForStreet(street);
          const fogResult = computeEquityForDeal(heroHand, opponentHands, boardCards, {
            mode: "fog",
            samples,
            trackNextCard: true,
          });
          const omniscientResult = computeEquityForDeal(
            heroHand,
            opponentHands,
            boardCards,
            {
              mode: "omniscient",
              samples,
              trackNextCard: true,
            }
          );

          appState.latestLiveResult = {
            fog: fogResult,
            omniscient: omniscientResult,
          };
          recordEquitySnapshot(street, fogResult, omniscientResult);
          updateEquityDisplay(appState.currentTheoretical, appState.latestLiveResult);
          renderLiveCharts();
          renderSuitTracker(heroHand, opponentHands, boardCards);
          renderSensitivitySection();
        }

        function recordEquitySnapshot(street, fogResult, omniscientResult) {
          if (!street) return;
          const snapshot = {
            street,
            fog: fogResult.equity,
            omniscient: omniscientResult.equity,
            delta: fogResult.equity - omniscientResult.equity,
          };
          const idx = appState.equityHistory.findIndex(
            (entry) => entry.street === street
          );
          if (idx >= 0) {
            appState.equityHistory[idx] = snapshot;
          } else {
            appState.equityHistory.push(snapshot);
          }
          appState.equityHistory.sort(
            (a, b) => STREET_ORDER[a.street] - STREET_ORDER[b.street]
          );
        }

        function renderLiveCharts() {
          const liveSection = document.getElementById("live-charts-section");
          const liveChartsGrid = document.getElementById("live-charts-grid");
          if (!liveSection || !liveChartsGrid) return;
          if (!appState.equityHistory.length) {
            liveSection.style.display = "none";
            liveChartsGrid.innerHTML = "";
            return;
          }

          liveSection.style.display = "block";
          liveChartsGrid.innerHTML =
            '<div class="chart-container" id="equity-timeline-chart"></div>' +
            '<div class="chart-container" id="live-dist-chart"></div>';

          const timelineContainer = document.getElementById(
            "equity-timeline-chart"
          );
          renderEquityTimeline(timelineContainer, appState.equityHistory);

          const activeMode = appState.sensitivityMode || "fog";
          const activeResult = appState.latestLiveResult[activeMode];
          const distContainer = document.getElementById("live-dist-chart");
          if (activeResult && distContainer) {
            createDistributionBarChart(
              distContainer,
              `Final Hand Strength % (${activeMode === "fog" ? "Unknown Villains" : "All Cards Revealed"})`,
              activeResult.handDistribution.map((count, i) => ({
                label: HAND_RANKS_TXT[i],
                value: activeResult.samples
                  ? count / activeResult.samples
                  : 0,
              }))
            );
          }
        }

        function renderEquityTimeline(container, history) {
          if (!container) return;
          container.innerHTML =
            '<h3>Equity Timeline</h3><svg viewBox="0 0 320 200"></svg>';
          const svg = container.querySelector("svg");
          if (!history.length) {
            svg.innerHTML =
              '<text x="160" y="100" text-anchor="middle" fill="#aaa">No Data</text>';
            return;
          }

          const values = history
            .flatMap((entry) => [entry.fog, entry.omniscient])
            .filter((val) => typeof val === "number");
          if (!values.length) {
            svg.innerHTML =
              '<text x="160" y="100" text-anchor="middle" fill="#aaa">No Data</text>';
            return;
          }

          const width = 320;
          const height = 200;
          const margin = { top: 24, right: 20, bottom: 32, left: 44 };
          const plotWidth = width - margin.left - margin.right;
          const plotHeight = height - margin.top - margin.bottom;
          const minVal = Math.max(0, Math.min(...values) - 5);
          const maxVal = Math.min(100, Math.max(...values) + 5);
          const range = Math.max(5, maxVal - minVal);
          const stepX =
            history.length > 1 ? plotWidth / (history.length - 1) : plotWidth;

          const buildPoints = (key) =>
            history.map((entry, idx) => {
              const value = entry[key];
              const x =
                margin.left +
                (history.length > 1 ? idx * stepX : plotWidth / 2);
              const y =
                margin.top +
                plotHeight -
                ((value - minVal) / range) * plotHeight;
              return { x, y, value, entry };
            });

          const fogPoints = buildPoints("fog");
          const knownPoints = buildPoints("omniscient");

          const axes = `
            <line x1="${margin.left}" y1="${margin.top + plotHeight}"
              x2="${margin.left + plotWidth}" y2="${margin.top + plotHeight}" stroke="#555"/>
            <line x1="${margin.left}" y1="${margin.top}"
              x2="${margin.left}" y2="${margin.top + plotHeight}" stroke="#555"/>
          `;
          svg.innerHTML = axes;

          const drawPath = (points, color, dashed = false) => {
            const d = points
              .map((pt, idx) => `${idx === 0 ? "M" : "L"} ${pt.x} ${pt.y}`)
              .join(" ");
            const path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            path.setAttribute("d", d);
            path.setAttribute("fill", "none");
            path.setAttribute("stroke", color);
            path.setAttribute("stroke-width", dashed ? "1.5" : "2.5");
            if (dashed) path.setAttribute("stroke-dasharray", "6,4");
            svg.appendChild(path);
          };

          drawPath(fogPoints, "#35b779", false);
          drawPath(knownPoints, "rgba(255, 255, 255, 0.55)", true);

          const addPointMarkers = (points, color, label, drawAxisLabels) => {
            points.forEach((pt, idx) => {
              if (typeof pt.value !== "number") return;
              const circle = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              circle.setAttribute("cx", pt.x);
              circle.setAttribute("cy", pt.y);
              circle.setAttribute("r", "4");
              circle.setAttribute("fill", color);
              circle.addEventListener("mouseover", (evt) => {
                const delta =
                  idx > 0
                    ? pt.value - points[idx - 1].value
                    : pt.value - pt.entry.omniscient;
                const deltaLabel =
                  idx > 0
                    ? `Î” prev: ${delta >= 0 ? "+" : ""}${delta.toFixed(1)}%`
                    : label === "Unknown Villains"
                    ? `Gap vs revealed: ${delta >= 0 ? "+" : ""}${delta.toFixed(
                        1
                      )}%`
                    : "";
                showTooltip(
                  evt,
                  `${STREET_LABELS[pt.entry.street]}<br>${label}: ${pt.value.toFixed(
                    1
                  )}%${deltaLabel ? `<br>${deltaLabel}` : ""}`
                );
              });
              circle.addEventListener("mouseout", hideTooltip);
              svg.appendChild(circle);

              if (drawAxisLabels) {
                const axisLabel = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "text"
                );
                axisLabel.setAttribute("x", pt.x);
                axisLabel.setAttribute("y", margin.top + plotHeight + 18);
                axisLabel.setAttribute("fill", "#aaa");
                axisLabel.setAttribute("font-size", "10");
                axisLabel.setAttribute("text-anchor", "middle");
                axisLabel.textContent = STREET_LABELS[pt.entry.street];
                svg.appendChild(axisLabel);
              }
            });
          };

          addPointMarkers(fogPoints, "#35b779", "Unknown Villains", true);
          addPointMarkers(
            knownPoints,
            "rgba(255, 255, 255, 0.65)",
            "All Cards Revealed",
            false
          );
        }

        function renderEquitySparkline(history) {
          const spark = document.getElementById("equity-delta-sparkline");
          if (!spark) return;
          if (!history || !history.length) {
            spark.innerHTML = "";
            return;
          }
          const width = 120;
          const height = 40;
          const padding = 4;
          const deltas = history.map((entry) => entry.delta || 0);
          const min = Math.min(...deltas, 0);
          const max = Math.max(...deltas, 0);
          const range = Math.max(0.5, max - min || 1);
          const step =
            history.length > 1
              ? (width - padding * 2) / (history.length - 1)
              : 0;
          const linePoints = deltas.map((delta, idx) => {
            const x = padding + (history.length > 1 ? idx * step : (width - padding * 2) / 2);
            const y =
              height -
              padding -
              ((delta - min) / range) * (height - padding * 2);
            return `${idx === 0 ? "M" : "L"}${x} ${y}`;
          });
          const baselineY =
            height -
            padding -
            ((0 - min) / range) * (height - padding * 2);
          spark.innerHTML = `
            <path d="M${padding} ${baselineY} L${width - padding} ${baselineY}" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
            <path d="${linePoints.join(" ")}" fill="none" stroke="#35b779" stroke-width="2"/>
          `;
        }

        function renderSuitTracker(heroHand, opponentHands, boardCards) {
          const section = document.getElementById("suit-tracker-section");
          if (!section) return;
          if (!heroHand || !heroHand.length) {
            section.style.display = "none";
            return;
          }
          section.style.display = "block";

          const heroCounts = SUITS.reduce((acc, suit) => {
            acc[suit] = 0;
            return acc;
          }, {});
          heroHand.forEach((card) => {
            heroCounts[card.slice(-1)]++;
          });

          const boardCounts = SUITS.reduce((acc, suit) => {
            acc[suit] = 0;
            return acc;
          }, {});
          boardCards.forEach((card) => {
            boardCounts[card.slice(-1)]++;
          });

          const baseKnown = new Set([...heroHand, ...boardCards]);
          const opponentFlat = opponentHands.flat();
          const opponentSet = new Set(opponentFlat);
          const blockers = SUITS.reduce((acc, suit) => {
            acc[suit] = 0;
            return acc;
          }, {});
          opponentFlat.forEach((card) => (blockers[card.slice(-1)] += 1));

          const baseDeck = createDeck().filter((card) => !baseKnown.has(card));

          const actualDeck = appState.showOpponentCards
            ? baseDeck.filter((card) => !opponentSet.has(card))
            : baseDeck;
          const actualCounts = SUITS.reduce((acc, suit) => {
            acc[suit] = 0;
            return acc;
          }, {});
          actualDeck.forEach((card) => {
            actualCounts[card.slice(-1)]++;
          });

          const summary = document.getElementById("suit-summary");
          const donutContainer = document.getElementById("suit-donut-chart");
          if (donutContainer) {
            renderSuitDonut(donutContainer, actualCounts);
          }

          if (!summary) return;
          const heroSummaries = SUITS.map((suit) => {
            const heroCards = heroCounts[suit];
            if (!heroCards) return null;
            const boardSuitCards = boardCounts[suit];
            const totalSeen = heroCards + boardSuitCards;
            const cardsNeeded = Math.max(0, 5 - totalSeen);
            const outsWithoutBlockers = Math.max(0, 13 - totalSeen);
            const blocked = appState.showOpponentCards ? blockers[suit] : 0;
            const liveOuts = appState.showOpponentCards
              ? Math.max(0, outsWithoutBlockers - blocked)
              : outsWithoutBlockers;
            const remainingSuitCards = actualDeck
              .filter((card) => card.slice(-1) === suit)
              .sort(
                (a, b) =>
                  RANK_INDEX[a[0]] - RANK_INDEX[b[0]]
              );
            const cleanList = remainingSuitCards
              .slice(0, 4)
              .map((card) => formatCardLabel(card))
              .join(", ");
            let status;
            if (totalSeen >= 5) {
              status = "Flush made";
            } else if (boardSuitCards >= 3 || totalSeen >= 4) {
              status = "Four to a flush";
            } else if (totalSeen >= 3) {
              status = "Backdoor draw";
            } else {
              status = "Runner-runner needed";
            }
            return {
              suit,
              heroCards,
              boardSuitCards,
              cardsNeeded,
              outsWithoutBlockers,
              liveOuts,
              blocked,
              cleanList,
              status,
            };
          }).filter(Boolean);

          const boardThreats = SUITS.map((suit) => {
            const boardSuitCards = boardCounts[suit];
            if (boardSuitCards < 3) return null;
            const blockersKnown = appState.showOpponentCards
              ? blockers[suit]
              : null;
            return {
              suit,
              boardSuitCards,
              blockersKnown,
            };
          }).filter(Boolean);

          const buildHeroMarkup = heroSummaries
            .map((entry) => {
              const pipStyle = `background:${SUIT_COLOR_MAP[entry.suit]}`;
              return `
                <div class="suit-summary-item">
                  <div class="suit-tag">
                    <span class="pip" style="${pipStyle}">${SUIT_SYMBOLS[entry.suit]}</span>
                    ${SUIT_LABELS[entry.suit]}
                  </div>
                  <div>${entry.status} Â· needs ${entry.cardsNeeded} ${
                entry.cardsNeeded === 1 ? "card" : "cards"
              }</div>
                  <div>${entry.liveOuts} live outs${
                appState.showOpponentCards
                  ? ` (${entry.blocked} blocked)`
                  : ""
              }</div>
                  ${
                    entry.cleanList
                      ? `<div>Top outs: ${entry.cleanList}</div>`
                      : ""
                  }
                </div>
              `;
            })
            .join("");

          const boardMarkup = boardThreats.length
            ? `<div class="suit-summary-item"><strong>Board Flush Threats</strong>
              ${boardThreats
                .map((entry) => {
                  const pipStyle = `background:${SUIT_COLOR_MAP[entry.suit]}`;
                  return `<div class="suit-tag">
                      <span class="pip" style="${pipStyle}">${SUIT_SYMBOLS[entry.suit]}</span>
                      ${entry.boardSuitCards} on board${
                    entry.blockersKnown !== null
                      ? ` Â· ${entry.blockersKnown} blocked`
                      : ""
                  }
                    </div>`;
                })
                .join("")}
             </div>`
            : "";

          const blocks = [];
          if (heroSummaries.length) blocks.push(buildHeroMarkup);
          if (boardMarkup) blocks.push(boardMarkup);
          summary.innerHTML = blocks.length
            ? blocks.join("")
            : '<div class="suit-summary-item">No flush potential with your current hand.</div>';
        }

        function renderSuitDonut(container, counts) {
          const total = Object.values(counts).reduce((acc, val) => acc + val, 0);
          container.innerHTML = `<svg viewBox="-1.2 -1.2 2.4 2.4"></svg>`;
          const svg = container.querySelector("svg");
          if (!total) {
            svg.innerHTML =
              '<text x="0" y="0" text-anchor="middle" fill="#aaa" font-size="0.14">No Cards</text>';
            return;
          }
          let cumulative = 0;
          SUITS.forEach((suit, idx) => {
            const count = counts[suit];
            if (!count) return;
            const percent = count / total;
            const [startX, startY] = [
              Math.cos(2 * Math.PI * cumulative),
              Math.sin(2 * Math.PI * cumulative),
            ];
            cumulative += percent;
            const [endX, endY] = [
              Math.cos(2 * Math.PI * cumulative),
              Math.sin(2 * Math.PI * cumulative),
            ];
            const path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            path.setAttribute(
              "d",
              `M ${startX} ${startY} A 1 1 0 ${
                percent > 0.5 ? 1 : 0
              } 1 ${endX} ${endY} L 0 0`
            );
            path.setAttribute("fill", SUIT_COLOR_MAP[suit]);
            path.addEventListener("mouseover", (evt) =>
              showTooltip(
                evt,
                `${SUIT_LABELS[suit]}<br>${count} cards (${(
                  percent * 100
                ).toFixed(1)}%)`
              )
            );
            path.addEventListener("mouseout", hideTooltip);
            svg.appendChild(path);
          });
        }

        function renderSensitivitySection() {
          const section = document.getElementById("sensitivity-section");
          const container = document.getElementById(
            "sensitivity-table-container"
          );
          const fogBtn = document.getElementById("sensitivity-fog-btn");
          const knownBtn = document.getElementById("sensitivity-known-btn");
          if (!section || !container) return;

          const currentStreet =
            appState.currentDeal && appState.currentDeal.street;
          const mode = appState.sensitivityMode || "fog";
          const latest = appState.latestLiveResult || {};
          const activeResult = latest[mode];

          if (
            !currentStreet ||
            currentStreet === "river" ||
            !activeResult ||
            !activeResult.nextCardImpacts.length
          ) {
            section.style.display = "none";
            container.innerHTML = "";
            return;
          }

          section.style.display = "block";
          if (fogBtn && knownBtn) {
            fogBtn.classList.toggle("active", mode === "fog");
            knownBtn.classList.toggle("active", mode === "omniscient");
          }

          renderSensitivityTable(
            container,
            activeResult.nextCardImpacts,
            activeResult.equity,
            mode
          );
        }

        function renderSensitivityTable(container, impacts, baseline, mode) {
          if (!impacts || !impacts.length) {
            container.innerHTML =
              '<div class="info-box"><p>No future cards remain to analyse.</p></div>';
            return;
          }

          const improvers = impacts
            .filter((impact) => impact.delta > 0)
            .sort((a, b) => b.delta - a.delta)
            .slice(0, 5);
          const busters = impacts
            .filter((impact) => impact.delta < 0)
            .sort((a, b) => a.delta - b.delta)
            .slice(0, 5);

          const rows = [...improvers, ...busters];
          const modeLabel =
            mode === "fog" ? "Unknown Villains" : "All Cards Revealed";

          container.innerHTML = `
            <table>
              <thead>
                <tr>
                  <th>Card</th>
                  <th>Î” Equity (${modeLabel})</th>
                  <th>Equity</th>
                  <th>Samples</th>
                </tr>
              </thead>
              <tbody>
                ${
                  rows.length
                    ? rows
                        .map((impact) => {
                          const isImprover = impact.delta >= 0;
                          return `<tr class="${
                            isImprover ? "improver" : "buster"
                          }">
                            <td class="card">${formatCardLabel(impact.card)}</td>
                            <td class="delta">${impact.delta >= 0 ? "+" : ""}${impact.delta.toFixed(2)}%</td>
                            <td>${impact.equity.toFixed(2)}%</td>
                            <td>${impact.count}</td>
                          </tr>`;
                        })
                        .join("")
                    : '<tr><td colspan="4">Insufficient data</td></tr>'
                }
              </tbody>
            </table>
          `;
        }

        function formatCardLabel(card) {
          if (!card) return "--";
          const rank = card[0];
          const suit = card.slice(-1);
          return `${rank}${SUIT_SYMBOLS[suit] || ""}`;
        }

        function handleShowdown() {
          const { heroHand, opponentHands, board } = appState.currentDeal;
          const allHands = [heroHand, ...opponentHands];
          const allScores = allHands.map((h) => evaluateHand([...h, ...board]));
          let bestScore = [-1];
          allScores.forEach((score) => {
            if (compareScores(score, bestScore) > 0) bestScore = score;
          });
          const winners = [];
          allScores.forEach((score, i) => {
            if (compareScores(score, bestScore) === 0) winners.push(i);
          });

          // Identify winning cards for each player
          const winningHands = allHands.map((hand, i) => {
            if (!winners.includes(i)) return null;
            return identifyWinningCards([...hand, ...board]);
          });

          renderPokerTable(true, winners, winningHands);

          const allPlayerEquities = allHands.map((_, i) => ({
            label: i === 0 ? "Hero" : `Opp. ${i}`,
            percent: winners.includes(i) ? 1 / winners.length : 0,
          }));

          const liveChartsGrid = document.getElementById("live-charts-grid");
          liveChartsGrid.innerHTML +=
            '<div class="chart-container" id="showdown-pie-chart"></div>';
          createPieChart(
            document.getElementById("showdown-pie-chart"),
            "Showdown Results (All Hands Known)",
            allPlayerEquities
          );
        }

        function identifyWinningCards(sevenCards) {
          if (sevenCards.length <= 5) return [...sevenCards];
          const combos = getFiveCardCombinations(sevenCards);
          let bestCombo = combos[0];
          let bestScore = evaluateHand(bestCombo);
          for (let i = 1; i < combos.length; i++) {
            const combo = combos[i];
            const comboScore = evaluateHand(combo);
            if (compareScores(comboScore, bestScore) > 0) {
              bestScore = comboScore;
              bestCombo = combo;
            }
          }
          return bestCombo;
        }

        function getFiveCardCombinations(cards) {
          const result = [];
          const combo = new Array(5);
          const n = cards.length;
          (function backtrack(start, depth) {
            if (depth === 5) {
              result.push(combo.slice());
              return;
            }
            for (let i = start; i <= n - (5 - depth); i++) {
              combo[depth] = cards[i];
              backtrack(i + 1, depth + 1);
            }
          })(0, 0);
          return result;
        }

        // SECTION 4: CHARTING ENGINE
        const tooltip = document.getElementById("tooltip");
        function showTooltip(evt, text) {
          tooltip.innerHTML = text;
          tooltip.style.opacity = "1";
          tooltip.style.left = `${evt.pageX + 10}px`;
          tooltip.style.top = `${evt.pageY + 10}px`;
        }
        function hideTooltip() {
          tooltip.style.opacity = "0";
        }
        function createLineChart(container, title, data, dataLabel) {
          container.innerHTML = `<h3>${title}</h3><svg viewBox="0 0 300 200"></svg>`;
          const svg = container.querySelector("svg");
          const points = data.map((d, i) => ({
            x: 30 + i * (260 / (data.length - 1)),
            y: 180 - d.y * 1.6,
          }));
          svg.innerHTML = `<line x1="30" y1="180" x2="290" y2="180" stroke="#777" /><line x1="30" y1="20" x2="30" y2="180" stroke="#777" /><text x="160" y="195" text-anchor="middle" font-size="10" fill="#aaa">Opponents</text><text x="15" y="100" transform="rotate(-90 15 100)" text-anchor="middle" font-size="10" fill="#aaa">Equity %</text>`;
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          path.setAttribute(
            "d",
            "M" + points.map((p) => `${p.x} ${p.y}`).join(" L ")
          );
          path.setAttribute("fill", "none");
          path.setAttribute("stroke", "#35b779");
          path.setAttribute("stroke-width", "2");
          svg.appendChild(path);
          data.forEach((d, i) => {
            const circle = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "circle"
            );
            circle.setAttribute("cx", points[i].x);
            circle.setAttribute("cy", points[i].y);
            circle.setAttribute("r", "4");
            circle.setAttribute("fill", "#35b779");
            circle.addEventListener("mouseover", (evt) =>
              showTooltip(
                evt,
                `Vs ${d.x} Opps<br>${dataLabel}: ${d.y.toFixed(1)}%`
              )
            );
            circle.addEventListener("mouseout", hideTooltip);
            svg.appendChild(circle);
          });
        }
        function createPieChart(container, title, data) {
          container.innerHTML = `<h3>${title}</h3><svg viewBox="-1.1 -1.1 2.2 2.2" style="transform: rotate(-90deg)"></svg>`;
          const svg = container.querySelector("svg");
          let cumulativePercent = 0;
          data.forEach((slice, i) => {
            if (slice.percent === 0) return;
            const sliceColor =
              slice.color || getViridisColor(i / (data.length - 1));
            const [x1, y1] = [
              Math.cos(2 * Math.PI * cumulativePercent),
              Math.sin(2 * Math.PI * cumulativePercent),
            ];
            cumulativePercent += slice.percent;
            const [x2, y2] = [
              Math.cos(2 * Math.PI * cumulativePercent),
              Math.sin(2 * Math.PI * cumulativePercent),
            ];
            const path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            path.setAttribute(
              "d",
              `M ${x1} ${y1} A 1 1 0 ${
                slice.percent > 0.5 ? 1 : 0
              } 1 ${x2} ${y2} L 0 0`
            );
            path.setAttribute("fill", sliceColor);
            path.addEventListener("mouseover", (evt) =>
              showTooltip(
                evt,
                `${slice.label}: ${(slice.percent * 100).toFixed(1)}%`
              )
            );
            path.addEventListener("mouseout", hideTooltip);
            svg.appendChild(path);
          });
        }
        function createDistributionBarChart(container, title, data) {
          container.innerHTML = `<h3>${title}</h3><svg viewBox="0 0 300 200"></svg>`;
          const svg = container.querySelector("svg");
          const maxVal = Math.max(...data.map((d) => d.value));
          if (maxVal === 0) {
            svg.innerHTML = `<text x="150" y="100" text-anchor="middle" fill="#aaa">No Data</text>`;
            return;
          }
          const barWidth = 300 / data.length;
          data.forEach((d, i) => {
            if (d.value === 0) return;
            const barHeight = (d.value / maxVal) * 160;
            const rect = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect"
            );
            rect.setAttribute("x", i * barWidth + barWidth * 0.1);
            rect.setAttribute("y", 180 - barHeight);
            rect.setAttribute("width", barWidth * 0.8);
            rect.setAttribute("height", barHeight);
            rect.setAttribute("fill", getViridisColor(i / (data.length - 1)));
            rect.addEventListener("mouseover", (evt) =>
              showTooltip(
                evt,
                `${d.label}<br>Prob: ${(d.value * 100).toFixed(1)}%`
              )
            );
            rect.addEventListener("mouseout", hideTooltip);
            svg.appendChild(rect);
            const text = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            text.setAttribute("x", i * barWidth + barWidth / 2);
            text.setAttribute("y", 195);
            text.setAttribute("font-size", "8px");
            text.setAttribute("fill", "#aaa");
            text.setAttribute("text-anchor", "middle");
            text.textContent = d.label
              .replace("3-of-a-Kind", "Set")
              .replace("4-of-a-Kind", "Quads")
              .replace("Straight Flush", "Str. Flush")
              .split(" ")[0];
            svg.appendChild(text);
          });
        }

        // SECTION 5: EVENT HANDLERS & WORKFLOW
        function setupEventListeners() {
          document
            .getElementById("opponent-slider")
            .addEventListener("input", handleOpponentChange);
          document
            .getElementById("heatmap")
            .addEventListener("click", handleHeatmapClick);
          document
            .getElementById("start-interactive-btn")
            .addEventListener("click", startInteractiveHand);
          document
            .getElementById("deal-street-btn")
            .addEventListener("click", dealNextStreet);
          document
            .getElementById("reset-hand-btn")
            .addEventListener("click", () => {
              if (appState.selectedHand) {
                handleHandSelection(appState.selectedHand);
              }
            });
          document
            .getElementById("toggle-cards-btn")
            .addEventListener("click", toggleOpponentCards);
          document
            .querySelectorAll(".sensitivity-controls .sim-button")
            .forEach((btn) =>
              btn.addEventListener("click", (evt) => {
                const mode = evt.currentTarget.dataset.sensitivityMode;
                if (!mode || appState.sensitivityMode === mode) return;
                appState.sensitivityMode = mode;
                document
                  .querySelectorAll(".sensitivity-controls .sim-button")
                  .forEach((button) =>
                    button.classList.toggle(
                      "active",
                      button.dataset.sensitivityMode === mode
                    )
                  );
                renderLiveCharts();
                renderSensitivitySection();
              })
            );
        }

        function toggleOpponentCards() {
          appState.showOpponentCards = !appState.showOpponentCards;
          const btn = document.getElementById("toggle-cards-btn");
          btn.textContent = appState.showOpponentCards
            ? "Hide Opponent Cards"
            : "Reveal Opponent Cards";
          renderPokerTable();
          if (appState.currentDeal) {
            const { heroHand, opponentHands, board, street } = appState.currentDeal;
            const boardCards =
              street === "preflop"
                ? []
                : board.slice(
                    0,
                    street === "flop" ? 3 : street === "turn" ? 4 : 5
                  );
            renderSuitTracker(heroHand, opponentHands, boardCards);
          }
        }

        function handleOpponentChange(e) {
          appState.numOpponents = parseInt(e.target.value);
          document.getElementById("opponent-count-label").textContent = `${
            appState.numOpponents
          } Opponent${appState.numOpponents > 1 ? "s" : ""}`;
          updateHeatmapColors();
          if (appState.selectedHand) {
            handleHandSelection(appState.selectedHand);
          }
        }

        function handleHeatmapClick(e) {
          const cell = e.target.closest(".heatmap-cell");
          if (cell) {
            handleHandSelection(cell.dataset.hand);
          }
        }

        function handleHandSelection(hand) {
          appState.selectedHand = hand;
          resetUIForNewSelection();
          document
            .querySelectorAll(".heatmap-cell.selected")
            .forEach((c) => c.classList.remove("selected"));
          const selectedCell = document.querySelector(`.heatmap-cell[data-hand="${hand}"]`);
          if (selectedCell) selectedCell.classList.add("selected");

          const cacheKey = `${hand}|${appState.numOpponents}`;
          const tableEntry = equityData[hand] && equityData[hand][appState.numOpponents];
          const preflopChartsGrid = document.getElementById("preflop-charts-grid");
          preflopChartsGrid.innerHTML =
            '<div class="chart-container" id="line-chart-container"></div>';

          if (equityData[hand]) {
            createLineChart(
              document.getElementById("line-chart-container"),
              "Theoretical Equity vs. Opponents",
              Object.entries(equityData[hand]).map(([opps, eq]) => ({
                x: parseInt(opps, 10),
                y: eq,
              })),
              "Equity"
            );
          } else {
            document.getElementById("line-chart-container").innerHTML =
              '<div class="info-box"><p>No precomputed data available for this hand.</p></div>';
          }

          if (typeof tableEntry === "number") {
            const result = {
              equity: tableEntry,
              samples: null,
            };
            appState.theoreticalCache.set(cacheKey, result);
            appState.currentTheoretical = result;
            updateEquityDisplay(result, appState.latestLiveResult);
          } else {
            const cached = appState.theoreticalCache.get(cacheKey);
            if (cached) {
              appState.currentTheoretical = cached;
              updateEquityDisplay(cached, appState.latestLiveResult);
            } else {
              appState.currentTheoretical = null;
              updateEquityDisplay(null, appState.latestLiveResult);
            }
          }

          renderPokerTable();
        }

        // Initialize the application
        renderHeatmap();
        updateHeatmapColors();
        setupEventListeners();
        resetUIForNewSelection();
      });
    </script>
  </body>
</html>
