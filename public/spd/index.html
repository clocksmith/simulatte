<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SPD - Stochastic Phase Dynamics</title>
    <meta name="description" content="Interactive double pendulum physics simulation with real-time visualization and data tracking" />
    <link rel="stylesheet" href="../simulatte-core.css">
    <!-- Minimal inline KaTeX styles for math rendering -->
    <style>
      .katex{font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0;text-rendering:auto}
      .katex-display{display:block;margin:1em 0;text-align:center}
      .katex .katex-mathml{display:none}
    </style>
    <style>
      /* DPS-specific overrides */
      :root {
        --page-padding: 24px;
        --font-main: var(--font-sans);
        --bg-color: var(--bg-dark);
        --text-color-dark: var(--text-primary);
        --border-color: var(--border);
        --border-light-color: var(--border);
        --card-bg-color: var(--bg-medium);
        --card-border: 1px solid var(--border);
        --chart-bg: var(--bg-light);
        --accent-light-grey: #666666;
        --accent-grey: var(--text-secondary);
        --accent-crimson: var(--accent-primary);
        --accent-purple: #9b66ff;
        --accent-cyan: var(--accent-tertiary);
        --accent-pink: var(--accent-primary);
        --accent-green: var(--accent-secondary);
        --accent-blue: #46a0ff;
      }

      body {
        background-color: var(--bg-color);
        color: var(--text-color-dark);
        font-family: var(--font-main);
        margin: 0;
        padding: var(--page-padding);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 25px;
        min-height: 100vh;
        position: relative;
        width: 100%;
        overflow-x: hidden;
        /* Hardware acceleration */
        transform: translateZ(0);
        backface-visibility: hidden;
      }


      h1 {
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 8px;
        width: 100%;
        text-align: center;
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .main-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
        width: 100%;
        align-items: stretch;
      }

      .simulation-row {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 20px;
        width: 100%;
        align-items: flex-start;
      }

      .card {
        background-color: var(--card-bg-color);
        color: var(--text-color-dark);
        border-radius: 4px;
        border: var(--card-border);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
        flex-grow: 1;
      }

      .simulation-row > .card {
        flex-basis: calc(50% - 10px);
        min-width: 300px;
      }

      .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px;
        border-bottom: 2px solid var(--border-light-color);
        cursor: pointer;
      }
      .card-header h2 {
        margin: 0;
        color: var(--text-color-dark);
        font-weight: 600;
        font-size: 1.2em;
      }
      .card-toggle {
        font-size: 1.5em;
        font-weight: bold;
        user-select: none;
      }

      .card-content {
        padding: 20px;
        display: block;
      }
      .card-content.collapsed {
        display: none;
      }

      #simulation-card .card-content {
        padding: 0;
        overflow: hidden;
      }

      #pendulum-canvas {
        display: block;
        background-color: #fff;
        border: none;
        cursor: grab;
        border-radius: 4px;
        width: 100%;
        aspect-ratio: 1 / 1;
        position: relative;
        /* Optimize canvas rendering */
        image-rendering: optimizeSpeed;
        image-rendering: -webkit-optimize-contrast;
        contain: strict;
        will-change: transform;
      }
      #pendulum-canvas:active {
        cursor: grabbing;
      }
      #pendulum-canvas {
        background-color: var(--bg-light);
      }

      #visuals-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 15px;
        align-items: stretch;
      }

      .visual-item {
        background-color: var(--bg-medium);
        padding: 12px 15px;
        border-radius: 6px;
        border: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        color: var(--text-primary);
        box-shadow: var(--shadow-sm);
      }

      .visual-item.chart-item {
        grid-column: span 2;
        min-height: 180px;
        min-width: 340px;
      }

      .visual-item.rpm-gauge-item {
        min-height: 120px;
      }

      .visual-item h3 {
        margin: 0 0 10px 0;
        font-size: 0.95em;
        color: var(--accent-secondary);
        font-weight: 600;
        flex-shrink: 0;
        border-bottom: 1px solid var(--border);
        padding-bottom: 6px;
        margin-bottom: 8px;
      }
      .visual-item p {
        margin: 4px 0;
        font-size: 0.9em;
        color: var(--text-secondary);
        display: flex;
        justify-content: space-between;
      }
      .visual-item small {
        font-size: 0.75em;
        color: var(--accent-grey);
        display: block;
        margin-top: 6px;
      }

      .position-visual {
        display: flex;
        justify-content: space-around;
        align-items: center;
        height: 60px;
        margin-bottom: 5px;
        flex-grow: 1;
      }

      .pos-circle {
        width: 50px;
        height: 50px;
        border: 2px solid var(--border);
        border-radius: 50%;
        position: relative;
        background-color: var(--bg-light);
      }

      .pos-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        transition: transform 0.05s linear;
      }
      #pos-dot-1 {
        background-color: var(--accent-crimson);
      }
      #pos-dot-2 {
        background-color: var(--accent-purple);
      }

      .data-display span {
        font-weight: bold;
        font-size: 0.95em;
        min-width: 50px;
        display: inline-block;
        text-align: right;
        font-family: "Consolas", "Monaco", monospace;
      }
      .data-display p > span:first-child {
        text-align: left;
        font-weight: normal;
        min-width: 30px;
        margin-right: 5px;
      }

      .rpm-gauge-container {
        display: flex;
        justify-content: space-around;
        align-items: center;
        flex-grow: 1;
        margin-top: 10px;
      }
      .rpm-gauge {
        width: 60px;
        height: 60px;
        border: 2px solid var(--accent-light-grey);
        border-radius: 50%;
        position: relative;
        background-color: var(--bg-light);
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7em;
        color: var(--accent-grey);
      }

      .rpm-needle {
        width: 2px;
        height: 45%;
        background-color: var(--accent-secondary);
        position: absolute;
        bottom: 50%;
        left: calc(50% - 1px);
        transform-origin: 50% 100%;
        transition: transform 0.1s linear;
      }
      .rpm-gauge small {
        font-size: 0.9em;
        margin-top: 0;
      }

      .history-chart-canvas {
        display: block;
        width: 100%;
        height: 156px;
        background-color: var(--chart-bg);
        border: 1px solid var(--border-light-color);
        border-radius: 4px;
        margin-top: auto;
        /* Optimize chart rendering */
        image-rendering: optimizeSpeed;
        contain: layout style paint;
      }

      #controls-container fieldset {
        border: 1px solid var(--border);
        border-radius: 6px;
        margin-bottom: 20px;
        padding: 15px 20px;
        background-color: var(--bg-medium);
        box-shadow: var(--shadow-sm);
      }
      #controls-container legend {
        font-weight: 600;
        color: var(--text-color-dark);
        padding: 0 8px;
        font-size: 1.1em;
      }

      .control-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px 20px;
        align-items: center;
      }
      .control-grid-initial {
        grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
        gap: 15px 15px;
      }
      .control-grid-force {
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 12px 15px;
      }
      .control-grid-data {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 12px 15px;
        align-items: end;
      }

      .control-item {
        display: flex;
        flex-direction: column;
        gap: 6px;
        position: relative;
      }
      .control-item label {
        font-size: 0.9em;
        color: var(--text-color-dark);
        font-weight: 500;
      }
      .control-item input[type="number"],
      .control-item input[type="text"],
      .control-item select {
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: 4px;
        font-size: 0.9em;
        width: 100%;
        background-color: var(--bg-light);
        color: var(--text-primary);
      }
      .control-item input[readonly] {
        background-color: var(--bg-medium);
        cursor: default;
      }

      .control-item input[type="radio"] {
        margin-right: 5px;
      }
      .radio-group {
        display: flex;
        gap: 15px;
        margin-top: 5px;
        align-items: center;
        flex-wrap: wrap;
      }
      .radio-group label {
        font-size: 0.9em;
        font-weight: normal;
        display: flex;
        align-items: center;
        cursor: pointer;
      }

      button.start {
        background-color: var(--accent-secondary);
        color: #000;
      }
      button.stop {
        background-color: var(--accent-pink);
      }
      button.reset {
        background-color: var(--accent-grey);
      }
      button.start:hover:not(:disabled) {
        background-color: var(--accent-green);
        border-color: var(--accent-green);
        color: #000;
        box-shadow: var(--glow-green);
      }
      button.start:active:not(:disabled) {
        background-color: var(--accent-green-dim);
        border-color: var(--accent-green-dim);
      }
      button.download {
        background-color: var(--accent-purple);
      }

      .button-group {
        display: flex;
        gap: 12px;
        margin-top: 5px;
        flex-wrap: wrap;
      }
      #data-recording-status {
        margin-top: 10px;
        font-style: italic;
        color: var(--accent-grey);
        font-size: 0.9em;
        min-height: 1.2em;
      }
      #estimated-size {
        font-size: 0.85em;
        color: var(--accent-grey);
        margin-top: 4px;
        display: block;
      }

      .tooltip {
        visibility: hidden;
        width: max-content;
        max-width: 250px;
        background-color: #333;
        color: #fff;
        text-align: center;
        border-radius: 4px;
        padding: 6px 10px;
        position: absolute;
        z-index: 10;
        bottom: 110%;
        left: 50%;
        transform: translateX(-50%);
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 0.85em;
        white-space: normal;
        pointer-events: none;
      }
      .control-item:hover .tooltip,
      .radio-group label:hover .tooltip,
      button:hover .tooltip {
        visibility: visible;
        opacity: 1;
      }

      #equations-card math {
        display: block;
        padding: 8px 0;
        overflow-x: auto;
        font-size: 1.05em;
      }
      #equations-card p {
        margin: 15px 0 5px 0;
        font-weight: 600;
      }
      #equations-card .explanation {
        font-size: 0.95em;
        font-weight: normal;
        margin-top: 10px;
        line-height: 1.5;
        color: var(--text-secondary);
      }
    </style>
  </head>
  <body>
    <a href="/" style="color: var(--accent-cyan); text-decoration: none; font-size: 0.85rem; display: inline-block; margin-bottom: 12px;">← Back to Gallery</a>
    <h1>SPD - Stochastic Phase Dynamics</h1>
    <div id="loading-indicator" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 1000; color: var(--accent-cyan);">
      <div style="font-size: 1.3rem; margin-bottom: 15px;">Initializing Simulation...</div>
      <div style="width: 40px; height: 40px; border: 3px solid rgba(0,255,255,0.2); border-top-color: var(--accent-cyan); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
    </div>
    <style>
      @keyframes spin { to { transform: rotate(360deg); } }
    </style>

    <div class="main-container">
      <div class="card" id="visuals-card">
        <div class="card-header">
          <h2>Visualizations</h2>
          <span class="card-toggle">−</span>
        </div>
        <div class="card-content">
          <div id="visuals-container">
            <div class="visual-item">
              <h3>Node Angles</h3>
              <div class="position-visual">
                <div class="pos-circle" title="θ₁ Angle">
                  <div id="pos-dot-1" class="pos-dot"></div>
                </div>
                <div class="pos-circle" title="θ₂ Angle">
                  <div id="pos-dot-2" class="pos-dot"></div>
                </div>
              </div>
            </div>
            <div class="visual-item rpm-gauge-item">
              <h3>Angular Velocity</h3>
              <div class="rpm-gauge-container">
                <div class="rpm-gauge" title="Bob 1 Angular Velocity (ω₁)">
                  <div class="rpm-needle" id="rpm-needle-1"></div>
                  <small>ω₁</small>
                </div>
                <div class="rpm-gauge" title="Bob 2 Angular Velocity (ω₂)">
                  <div class="rpm-needle" id="rpm-needle-2"></div>
                  <small>ω₂</small>
                </div>
              </div>
              <p>
                <span>ω₁:</span> <span id="omega1-display">0.00</span> rad/s
              </p>
              <p>
                <span>ω₂:</span> <span id="omega2-display">0.00</span> rad/s
              </p>
            </div>
            <div class="visual-item data-display">
              <h3>System Energy (J)</h3>
              <p><span>KE</span> <span id="ke-total-display">0.00</span></p>
              <p><span>PE</span> <span id="pe-total-display">0.00</span></p>
              <p>
                <span>E<sub>total</sub></span>
                <span id="energy-display">0.00</span>
              </p>
              <p>
                <span>Avg E</span> <span id="avg-energy-display">0.00</span>
              </p>
              <p><span>ΔE</span> <span id="chaos-display">0.00</span> %</p>
              <small>Coefficient of variation (last ~1s)</small>
            </div>
            <div class="visual-item data-display">
              <h3>Energy Detail (J)</h3>
              <p><span>KE₁</span> <span id="ke1-display">0.00</span></p>
              <p><span>KE₂</span> <span id="ke2-display">0.00</span></p>
              <p><span>PE₁</span> <span id="pe1-display">0.00</span></p>
              <p><span>PE₂</span> <span id="pe2-display">0.00</span></p>
            </div>
            <div class="visual-item data-display">
              <h3>Forces on Bob 1 (N)</h3>
              <p>
                <span>F<sub>g,x</sub></span> <span id="f1gx-display">0.00</span>
              </p>
              <p>
                <span>F<sub>g,y</sub></span> <span id="f1gy-display">0.00</span>
              </p>
              <p>
                <span>F<sub>d,x</sub></span> <span id="f1dx-display">0.00</span>
              </p>
              <p>
                <span>F<sub>d,y</sub></span> <span id="f1dy-display">0.00</span>
              </p>
              <p>
                <span>F<sub>B,x</sub></span> <span id="f1bx-display">0.00</span>
              </p>
              <p>
                <span>F<sub>B,y</sub></span> <span id="f1by-display">0.00</span>
              </p>
              <p>
                <span>F<sub>W,x</sub></span> <span id="f1wx-display">0.00</span>
              </p>
              <p>
                <span>F<sub>W,y</sub></span> <span id="f1wy-display">0.00</span>
              </p>
            </div>
            <div class="visual-item data-display">
              <h3>Forces on Bob 2 (N)</h3>
              <p>
                <span>F<sub>g,x</sub></span> <span id="f2gx-display">0.00</span>
              </p>
              <p>
                <span>F<sub>g,y</sub></span> <span id="f2gy-display">0.00</span>
              </p>
              <p>
                <span>F<sub>d,x</sub></span> <span id="f2dx-display">0.00</span>
              </p>
              <p>
                <span>F<sub>d,y</sub></span> <span id="f2dy-display">0.00</span>
              </p>
              <p>
                <span>F<sub>B,x</sub></span> <span id="f2bx-display">0.00</span>
              </p>
              <p>
                <span>F<sub>B,y</sub></span> <span id="f2by-display">0.00</span>
              </p>
              <p>
                <span>F<sub>W,x</sub></span> <span id="f2wx-display">0.00</span>
              </p>
              <p>
                <span>F<sub>W,y</sub></span> <span id="f2wy-display">0.00</span>
              </p>
            </div>
            <div class="visual-item chart-item">
              <h3>Angular Velocity History</h3>
              <canvas
                id="omega-history-chart-canvas"
                class="history-chart-canvas"
              ></canvas>
            </div>
            <div class="visual-item chart-item">
              <h3>Energy History</h3>
              <canvas
                id="energy-history-chart-canvas"
                class="history-chart-canvas"
              ></canvas>
            </div>
            <div class="visual-item chart-item">
              <h3>Energy Stability</h3>
              <canvas
                id="chaos-history-chart-canvas"
                class="history-chart-canvas"
              ></canvas>
            </div>
          </div>
        </div>
      </div>

      <div class="simulation-row">
        <div class="card" id="simulation-card">
          <div class="card-header">
            <h2>Simulation Canvas</h2>
            <span class="card-toggle">−</span>
          </div>
          <div class="card-content">
            <canvas id="pendulum-canvas" width="600" height="600"></canvas>
          </div>
        </div>

        <div class="card" id="controls-card">
          <div class="card-header">
            <h2>Controls & Parameters</h2>
            <span class="card-toggle">−</span>
          </div>
          <div class="card-content" id="controls-container">
            <fieldset>
              <legend>Simulation Control</legend>
              <div class="button-group">
                <button id="start-button" class="start">
                  Start<span class="tooltip"
                    >Begin or resume the simulation</span
                  >
                </button>
                <button id="stop-button" class="stop">
                  Stop<span class="tooltip">Pause the simulation</span>
                </button>
                <button id="reset-button" class="reset">
                  Reset<span class="tooltip"
                    >Reset to default initial state and parameters</span
                  >
                </button>
              </div>
              <div class="control-grid" style="margin-top: 15px">
                <div class="control-item">
                  <label for="sim-rate-input">Physics Rate (Hz)</label>
                  <input
                    type="number"
                    id="sim-rate-input"
                    value="120"
                    step="10"
                    min="10"
                  />
                  <span class="tooltip"
                    >Updates per second for physics calculations. Higher is more
                    accurate but slower. (e.g., 120)</span
                  >
                </div>
                <div class="control-item">
                  <label for="render-rate-input">Render Rate (FPS)</label>
                  <input
                    type="number"
                    id="render-rate-input"
                    value="60"
                    step="5"
                    min="1"
                  />
                  <span class="tooltip"
                    >Frames per second for updating the canvas visuals. (e.g.,
                    60)</span
                  >
                </div>
              </div>
            </fieldset>

            <fieldset>
              <legend>Initial State (Defaults on Reset)</legend>
              <div class="control-grid control-grid-initial">
                <div class="control-item">
                  <label for="default-theta1-input">θ₁ (deg)</label>
                  <input
                    type="number"
                    id="default-theta1-input"
                    value="120"
                    step="1"
                  />
                  <span class="tooltip"
                    >Default initial angle for Bob 1. Vertical down is 0. (e.g.,
                    120)</span
                  >
                </div>
                <div class="control-item">
                  <label for="default-theta2-input">θ₂ (deg)</label>
                  <input
                    type="number"
                    id="default-theta2-input"
                    value="-30"
                    step="1"
                  />
                  <span class="tooltip"
                    >Default initial angle for Bob 2. Vertical down is 0. (e.g.,
                    -30)</span
                  >
                </div>
                <div class="control-item">
                  <label>x₁ (m)</label>
                  <input type="text" id="default-x1-display" readonly />
                  <span class="tooltip"
                    >Calculated default X position of Bob 1</span
                  >
                </div>
                <div class="control-item">
                  <label>y₁ (m)</label>
                  <input type="text" id="default-y1-display" readonly />
                  <span class="tooltip"
                    >Calculated default Y position of Bob 1 (relative to
                    pivot)</span
                  >
                </div>
                <div class="control-item">
                  <label>x₂ (m)</label>
                  <input type="text" id="default-x2-display" readonly />
                  <span class="tooltip"
                    >Calculated default X position of Bob 2</span
                  >
                </div>
                <div class="control-item">
                  <label>y₂ (m)</label>
                  <input type="text" id="default-y2-display" readonly />
                  <span class="tooltip"
                    >Calculated default Y position of Bob 2 (relative to
                    pivot)</span
                  >
                </div>
                <div class="control-item">
                  <label>Current θ₁ (deg)</label>
                  <input
                    type="text"
                    id="current-theta1-display"
                    readonly
                    value="120.0"
                  />
                  <span class="tooltip"
                    >Current angle of Bob 1. Can be set by dragging when
                    paused.</span
                  >
                </div>
                <div class="control-item">
                  <label>Current θ₂ (deg)</label>
                  <input
                    type="text"
                    id="current-theta2-display"
                    readonly
                    value="-30.0"
                  />
                  <span class="tooltip"
                    >Current angle of Bob 2. Can be set by dragging when
                    paused.</span
                  >
                </div>
              </div>
            </fieldset>

            <fieldset>
              <legend>Pendulum Parameters</legend>
              <div class="control-grid">
                <div class="control-item">
                  <label for="length1-input">Length 1 (m)</label>
                  <input
                    type="number"
                    id="length1-input"
                    value="1.0"
                    step="0.1"
                    min="0.1"
                  />
                  <span class="tooltip"
                    >Length of the first rod. (e.g., 1.0)</span
                  >
                </div>
                <div class="control-item">
                  <label for="length2-input">Length 2 (m)</label>
                  <input
                    type="number"
                    id="length2-input"
                    value="1.0"
                    step="0.1"
                    min="0.1"
                  />
                  <span class="tooltip"
                    >Length of the second rod. (e.g., 1.0)</span
                  >
                </div>
                <div class="control-item">
                  <label for="mass1-input">Mass 1 (kg)</label>
                  <input
                    type="number"
                    id="mass1-input"
                    value="1.0"
                    step="0.1"
                    min="0.1"
                  />
                  <span class="tooltip"
                    >Mass of the first bob (at end of L1). (e.g., 1.0)</span
                  >
                </div>
                <div class="control-item">
                  <label for="mass2-input">Mass 2 (kg)</label>
                  <input
                    type="number"
                    id="mass2-input"
                    value="1.0"
                    step="0.1"
                    min="0.1"
                  />
                  <span class="tooltip"
                    >Mass of the second bob (at end of L2). (e.g., 1.0)</span
                  >
                </div>
                <div class="control-item">
                  <label for="gravity-input">Gravity (m/s²)</label>
                  <input
                    type="number"
                    id="gravity-input"
                    value="9.80665"
                    step="0.1"
                    min="0"
                  />
                  <span class="tooltip"
                    >Acceleration due to gravity. (e.g., 9.81)</span
                  >
                </div>
                <div class="control-item">
                  <label for="damping1-input">Damping 1</label>
                  <input
                    type="number"
                    id="damping1-input"
                    value="0"
                    step="0.005"
                    min="0"
                    max="1"
                  />
                  <span class="tooltip"
                    >Frictional drag coefficient for Bob 1 (proportional to
                    velocity). 0 = no damping. (e.g., 0.01)</span
                  >
                </div>
                <div class="control-item">
                  <label for="damping2-input">Damping 2</label>
                  <input
                    type="number"
                    id="damping2-input"
                    value="0"
                    step="0.005"
                    min="0"
                    max="1"
                  />
                  <span class="tooltip"
                    >Frictional drag coefficient for Bob 2. (e.g., 0.01)</span
                  >
                </div>
              </div>
            </fieldset>

            <fieldset>
              <legend>Visualization Settings</legend>
              <div class="control-grid">
                <div class="control-item">
                  <label for="trace1-length-input">Trace 1 Length</label>
                  <input
                    type="number"
                    id="trace1-length-input"
                    value="600"
                    step="50"
                    min="0"
                  />
                  <span class="tooltip"
                    >Number of points in the trail of Bob 1. (e.g., 500)</span
                  >
                </div>
                <div class="control-item">
                  <label for="trace2-length-input">Trace 2 Length</label>
                  <input
                    type="number"
                    id="trace2-length-input"
                    value="600"
                    step="50"
                    min="0"
                  />
                  <span class="tooltip"
                    >Number of points in the trail of Bob 2. (e.g., 500)</span
                  >
                </div>
              </div>
            </fieldset>

            <fieldset>
              <legend>Scene Forces (Optional)</legend>
              <div class="control-grid control-grid-force">
                <div class="control-item">
                  <label for="dir-force-mag-input">Wind Mag (N)</label>
                  <input
                    type="number"
                    id="dir-force-mag-input"
                    value="0"
                    step="0.1"
                    min="0"
                  />
                  <span class="tooltip"
                    >Magnitude of a constant wind force applied to both bobs.
                    (e.g., 0.5)</span
                  >
                </div>
                <div class="control-item">
                  <label for="dir-force-angle-input">Wind Angle (deg)</label>
                  <input
                    type="number"
                    id="dir-force-angle-input"
                    value="0"
                    step="5"
                  />
                  <span class="tooltip"
                    >Direction of the wind force (0=right, 90=up). (e.g.,
                    0)</span
                  >
                </div>
                <div class="control-item">
                  <label for="charge1-input">Charge 1 (q)</label>
                  <input
                    type="number"
                    id="charge1-input"
                    value="0"
                    step="0.1"
                  />
                  <span class="tooltip"
                    >Electric charge of Bob 1 (for Lorentz force). (e.g.,
                    1.0)</span
                  >
                </div>
                <div class="control-item">
                  <label for="charge2-input">Charge 2 (q)</label>
                  <input
                    type="number"
                    id="charge2-input"
                    value="0"
                    step="0.1"
                  />
                  <span class="tooltip"
                    >Electric charge of Bob 2. (e.g., -1.0)</span
                  >
                </div>
                <div class="control-item">
                  <label for="mag-field-input">Mag Field (Bz)</label>
                  <input
                    type="number"
                    id="mag-field-input"
                    value="0"
                    step="0.1"
                  />
                  <span class="tooltip"
                    >Strength of a uniform magnetic field perpendicular to the
                    plane (z-axis). >0 is into page (⊗), <0 is out of page (⊙).
                    (e.g., 0.5)</span
                  >
                </div>
              </div>
              <small
                >Applies uniform wind force and/or Lorentz force
                (simplified).</small
              >
            </fieldset>

            <fieldset>
              <legend>Data Recording & Export</legend>
              <div class="control-grid control-grid-data">
                <div class="control-item">
                  <label for="max-record-time-input">Max Record Time (s)</label>
                  <input
                    type="number"
                    id="max-record-time-input"
                    value="60"
                    step="10"
                    min="1"
                  />
                  <span class="tooltip"
                    >Maximum duration of simulation data to record. Large values
                    use more memory. (e.g., 60)</span
                  >
                  <span id="estimated-size">Est. Size: 0.0 MB</span>
                </div>
                <div class="control-item">
                  <label>Recording Mode</label>
                  <div class="radio-group">
                    <label>
                      <input
                        type="radio"
                        name="recordMode"
                        value="live"
                        checked
                      />
                      Live
                      <span class="tooltip"
                        >Record data progressively while the simulation runs and
                        renders normally.</span
                      >
                    </label>
                    <label>
                      <input type="radio" name="recordMode" value="fast" /> Fast
                      CSV
                      <span class="tooltip"
                        >Run simulation at maximum speed without rendering to
                        generate the CSV data quickly. UI will be unresponsive
                        during generation.</span
                      >
                    </label>
                  </div>
                </div>
              </div>
              <div class="button-group" style="margin-top: 15px">
                <button id="download-data-button" class="download">
                  Download Recorded Data (CSV)
                  <span class="tooltip"
                    >Download the data currently stored from the last recording
                    session.</span
                  >
                </button>
              </div>
              <div id="data-recording-status">
                Ready to record. Press Start.
              </div>
            </fieldset>
          </div>
        </div>
      </div>

      <div class="card" id="equations-card">
        <div class="card-header">
          <h2>Equations Used</h2>
          <span class="card-toggle">−</span>
        </div>
        <div class="card-content">
          <p>Coordinates:</p>
          <div style="font-family: 'Times New Roman', serif; margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-left: 3px solid #00ff00;">
            x<sub>1</sub> = L<sub>1</sub> sin θ<sub>1</sub><br>
            y<sub>1</sub> = L<sub>1</sub> cos θ<sub>1</sub><br>
            x<sub>2</sub> = x<sub>1</sub> + L<sub>2</sub> sin θ<sub>2</sub> = L<sub>1</sub> sin θ<sub>1</sub> + L<sub>2</sub> sin θ<sub>2</sub><br>
            y<sub>2</sub> = y<sub>1</sub> + L<sub>2</sub> cos θ<sub>2</sub> = L<sub>1</sub> cos θ<sub>1</sub> + L<sub>2</sub> cos θ<sub>2</sub>
          </div>
          <p>Lagrangian (ℒ = T − V):</p>
          <div style="font-family: 'Times New Roman', serif; margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-left: 3px solid #00ff00;">
            T = ½ m<sub>1</sub> (L<sub>1</sub> θ̇<sub>1</sub>)<sup>2</sup> + ½ m<sub>2</sub> [(L<sub>1</sub> θ̇<sub>1</sub>)<sup>2</sup> + (L<sub>2</sub> θ̇<sub>2</sub>)<sup>2</sup> + 2L<sub>1</sub>L<sub>2</sub> θ̇<sub>1</sub> θ̇<sub>2</sub> cos(θ<sub>1</sub> − θ<sub>2</sub>)]<br>
            V = −m<sub>1</sub> g L<sub>1</sub> cos θ<sub>1</sub> − m<sub>2</sub> g (L<sub>1</sub> cos θ<sub>1</sub> + L<sub>2</sub> cos θ<sub>2</sub>)
          </div>
          <p>
            Equations of Motion (from Euler-Lagrange: d/dt(∂ℒ/∂θ̇<sub>i</sub>) − ∂ℒ/∂θ<sub>i</sub> = Q<sub>i</sub>):
          </p>
          <div style="font-family: 'Times New Roman', serif; margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-left: 3px solid #00ff00; text-align: center;">
            <div style="display: inline-block; vertical-align: middle;">
              <div style="border: 1px solid #666; padding: 5px; display: inline-block;">
                M<sub>11</sub> &nbsp; M<sub>12</sub><br>
                M<sub>21</sub> &nbsp; M<sub>22</sub>
              </div>
              <div style="display: inline-block; vertical-align: middle; padding: 5px; border: 1px solid #666; margin: 0 10px;">
                θ̈<sub>1</sub><br>
                θ̈<sub>2</sub>
              </div>
              =
              <div style="display: inline-block; vertical-align: middle; padding: 5px; border: 1px solid #666; margin: 0 10px;">
                F<sub>1</sub><br>
                F<sub>2</sub>
              </div>
              +
              <div style="display: inline-block; vertical-align: middle; padding: 5px; border: 1px solid #666; margin: 0 10px;">
                Q<sub>1,ext</sub><br>
                Q<sub>2,ext</sub>
              </div>
            </div>
          </div>
          <small
            >Where M is the mass matrix, F contains gravitational and
            centrifugal/Coriolis terms, and Q<sub>ext</sub> are external generalized
            forces (damping, wind, Lorentz).</small
          >
          <div style="font-family: 'Times New Roman', serif; margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-left: 3px solid #00ff00; font-size: 0.9em;">
            θ̈<sub>1</sub> = [−g(2m<sub>1</sub>+m<sub>2</sub>)sin θ<sub>1</sub> − m<sub>2</sub>g sin(θ<sub>1</sub>−2θ<sub>2</sub>) − 2sin(θ<sub>1</sub>−θ<sub>2</sub>)m<sub>2</sub>(L<sub>2</sub>θ̇<sub>2</sub><sup>2</sup> + L<sub>1</sub>θ̇<sub>1</sub><sup>2</sup>cos(θ<sub>1</sub>−θ<sub>2</sub>))] / [L<sub>1</sub>(2m<sub>1</sub>+m<sub>2</sub>−m<sub>2</sub>cos(2θ<sub>1</sub>−2θ<sub>2</sub>))] + Q′<sub>1</sub><br><br>
            θ̈<sub>2</sub> = [2sin(θ<sub>1</sub>−θ<sub>2</sub>)(L<sub>1</sub>θ̇<sub>1</sub><sup>2</sup>(m<sub>1</sub>+m<sub>2</sub>)+g(m<sub>1</sub>+m<sub>2</sub>)cos θ<sub>1</sub>+L<sub>2</sub>m<sub>2</sub>θ̇<sub>2</sub><sup>2</sup>cos(θ<sub>1</sub>−θ<sub>2</sub>))] / [L<sub>2</sub>(2m<sub>1</sub>+m<sub>2</sub>−m<sub>2</sub>cos(2θ<sub>1</sub>−2θ<sub>2</sub>))] + Q′<sub>2</sub>
          </div>
          <small
            >Q′<sub>i</sub> represents the effect of external torques after inverting
            the mass matrix.</small
          >
          <p>
            External Forces (Cartesian Components & Generalized Torques Q<sub>i</sub>):
          </p>
          <div style="font-family: 'Times New Roman', serif; margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-left: 3px solid #00ff00;">
            <b>F</b><sub>g,j</sub> = (0, −m<sub>j</sub> g)<br>
            <b>F</b><sub>d,j</sub> = −d<sub>j</sub> <b>v</b><sub>j</sub><br>
            <b>F</b><sub>wind</sub> = (F<sub>W</sub> cos φ<sub>W</sub>, F<sub>W</sub> sin φ<sub>W</sub>)<br>
            <b>F</b><sub>B,j</sub> = q<sub>j</sub> (<b>v</b><sub>j</sub> × <b>B</b>) = q<sub>j</sub> (v<sub>j,y</sub> B<sub>z</sub>, −v<sub>j,x</sub> B<sub>z</sub>)<br>
            Q<sub>i,ext</sub> = Σ<sub>j=1,2</sub> (<b>r</b><sub>j</sub> × (<b>F</b><sub>d,j</sub> + <b>F</b><sub>wind</sub> + <b>F</b><sub>B,j</sub>))<sub>z</sub>
          </div>
          <p>Total Energy (E = T + V):</p>
          <div style="font-family: 'Times New Roman', serif; margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-left: 3px solid #00ff00;">
            E = Kinetic Energy (T) + Potential Energy (V)
          </div>
          <p>Numerical Integration (Symplectic Semi-Implicit Euler):</p>
          <div style="font-family: 'Times New Roman', serif; margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-left: 3px solid #00ff00;">
            θ̇<sub>n+½</sub> = θ̇<sub>n</sub> + (h/2)θ̈(θ<sub>n</sub>, θ̇<sub>n</sub>)<br>
            θ<sub>n+1</sub> = θ<sub>n</sub> + h θ̇<sub>n+½</sub><br>
            θ̇<sub>n+1</sub> = θ̇<sub>n+½</sub> + (h/2)θ̈(θ<sub>n+1</sub>, θ̇<sub>n+½</sub>)
          </div>
          <p class="explanation">
            <b>Energy Conservation:</b> This simulation uses a symplectic (energy-preserving) integrator
            that maintains the Hamiltonian structure of the system. In an ideal system with no damping
            (d<sub>1</sub>=d<sub>2</sub>=0) and no external forces (wind/Lorentz forces = 0), the
            total mechanical energy E = T + V remains nearly constant over
            long simulations. Unlike standard explicit methods, symplectic integrators prevent
            long-term energy drift by preserving the phase-space volume. The "Energy Variation" metric
            reflects small bounded oscillations in energy (not cumulative drift) or actual energy changes if
            non-conservative forces are active. For the default parameters
            (L<sub>1</sub>=L<sub>2</sub>=1, m<sub>1</sub>=m<sub>2</sub>=1, g=9.80665, θ<sub>1</sub>=120°,
            θ<sub>2</sub>=−30°, θ̇<sub>1</sub>=θ̇<sub>2</sub>=0), the
            initial total energy is approximately 1.314 Joules.
          </p>
        </div>
      </div>
    </div>

    <script>
      'use strict';
      
      // Performance optimizations
      const RAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
      const PERF = window.performance || Date;
      
      // Cache DOM elements
      const canvas = document.getElementById("pendulum-canvas");
      const ctxOptions = { alpha: false, desynchronized: true };
      let ctx = null;
      let canvasError = null;

      // Try to get canvas context with progressively simpler options
      try {
        ctx = canvas.getContext("2d", ctxOptions);
        if (!ctx) {
          ctx = canvas.getContext("2d", { alpha: false });
        }
        if (!ctx) {
          ctx = canvas.getContext("2d");
        }
      } catch (e) {
        canvasError = e;
      }

      if (!ctx) {
        // Show user-friendly error message in the canvas container
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = 'position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px;background:var(--bg-medium);color:var(--text-primary);padding:20px;text-align:center;';
        errorMsg.innerHTML = `
          <h3 style="color:var(--accent-primary);margin:0;">Canvas Error</h3>
          <p style="margin:0;max-width:400px;">Unable to initialize the simulation canvas. This may be due to browser restrictions or hardware limitations.</p>
          <p style="margin:0;font-size:0.85em;color:var(--text-secondary);">Try refreshing the page or using a different browser.</p>
        `;
        canvas.parentNode.style.position = 'relative';
        canvas.parentNode.appendChild(errorMsg);
        console.error("Canvas initialization failed:", canvasError || "Context unavailable");
      }

      const omegaHistoryChartCanvas = document.getElementById(
        "omega-history-chart-canvas"
      );
      const omegaChartCtx = omegaHistoryChartCanvas.getContext("2d");
      const energyHistoryChartCanvas = document.getElementById(
        "energy-history-chart-canvas"
      );
      const energyChartCtx = energyHistoryChartCanvas.getContext("2d");
      const chaosHistoryChartCanvas = document.getElementById(
        "chaos-history-chart-canvas"
      );
      const chaosChartCtx = chaosHistoryChartCanvas.getContext("2d");

      const startButton = document.getElementById("start-button");
      const stopButton = document.getElementById("stop-button");
      const resetButton = document.getElementById("reset-button");

      const simRateInput = document.getElementById("sim-rate-input");
      const renderRateInput = document.getElementById("render-rate-input");
      const defaultTheta1Input = document.getElementById(
        "default-theta1-input"
      );
      const defaultTheta2Input = document.getElementById(
        "default-theta2-input"
      );
      const defaultX1Display = document.getElementById("default-x1-display");
      const defaultY1Display = document.getElementById("default-y1-display");
      const defaultX2Display = document.getElementById("default-x2-display");
      const defaultY2Display = document.getElementById("default-y2-display");
      const currentTheta1Display = document.getElementById(
        "current-theta1-display"
      );
      const currentTheta2Display = document.getElementById(
        "current-theta2-display"
      );
      const length1Input = document.getElementById("length1-input");
      const length2Input = document.getElementById("length2-input");
      const gravityInput = document.getElementById("gravity-input");
      const mass1Input = document.getElementById("mass1-input");
      const mass2Input = document.getElementById("mass2-input");
      const damping1Input = document.getElementById("damping1-input");
      const damping2Input = document.getElementById("damping2-input");
      const trace1LengthInput = document.getElementById("trace1-length-input");
      const trace2LengthInput = document.getElementById("trace2-length-input");
      const dirForceMagInput = document.getElementById("dir-force-mag-input");
      const dirForceAngleInput = document.getElementById(
        "dir-force-angle-input"
      );
      const charge1Input = document.getElementById("charge1-input");
      const charge2Input = document.getElementById("charge2-input");
      const magFieldInput = document.getElementById("mag-field-input");

      const maxRecordTimeInput = document.getElementById(
        "max-record-time-input"
      );
      const estimatedSizeDisplay = document.getElementById("estimated-size");
      const downloadDataButton = document.getElementById(
        "download-data-button"
      );
      const dataRecordingStatus = document.getElementById(
        "data-recording-status"
      );
      const recordingModeRadios = document.querySelectorAll(
        'input[name="recordMode"]'
      );

      const omega1Display = document.getElementById("omega1-display");
      const omega2Display = document.getElementById("omega2-display");
      const rpmNeedle1 = document.getElementById("rpm-needle-1");
      const rpmNeedle2 = document.getElementById("rpm-needle-2");
      const keTotalDisplay = document.getElementById("ke-total-display");
      const peTotalDisplay = document.getElementById("pe-total-display");
      const energyDisplay = document.getElementById("energy-display");
      const ke1Display = document.getElementById("ke1-display");
      const ke2Display = document.getElementById("ke2-display");
      const pe1Display = document.getElementById("pe1-display");
      const pe2Display = document.getElementById("pe2-display");
      const avgEnergyDisplay = document.getElementById("avg-energy-display");
      const chaosDisplay = document.getElementById("chaos-display");
      const posDot1 = document.getElementById("pos-dot-1");
      const posDot2 = document.getElementById("pos-dot-2");

      const f1gxDisplay = document.getElementById("f1gx-display");
      const f1gyDisplay = document.getElementById("f1gy-display");
      const f1dxDisplay = document.getElementById("f1dx-display");
      const f1dyDisplay = document.getElementById("f1dy-display");
      const f1bxDisplay = document.getElementById("f1bx-display");
      const f1byDisplay = document.getElementById("f1by-display");
      const f1wxDisplay = document.getElementById("f1wx-display");
      const f1wyDisplay = document.getElementById("f1wy-display");
      const f2gxDisplay = document.getElementById("f2gx-display");
      const f2gyDisplay = document.getElementById("f2gy-display");
      const f2dxDisplay = document.getElementById("f2dx-display");
      const f2dyDisplay = document.getElementById("f2dy-display");
      const f2bxDisplay = document.getElementById("f2bx-display");
      const f2byDisplay = document.getElementById("f2by-display");
      const f2wxDisplay = document.getElementById("f2wx-display");
      const f2wyDisplay = document.getElementById("f2wy-display");

      let gravity = 9.80665;
      let length1 = 1.0;
      let length2 = 1.0;
      let mass1 = 1.0;
      let mass2 = 1.0;
      let damping1 = 0;
      let damping2 = 0;
      let trace1MaxLength = 600;
      let trace2MaxLength = 600;
      let dirForceMag = 0;
      let dirForceAngleRad = 0;
      let charge1 = 0;
      let charge2 = 0;
      let magFieldBz = 0;

      let defaultTheta1 = (120 * Math.PI) / 180;
      let defaultTheta2 = (-30 * Math.PI) / 180;
      let theta1 = defaultTheta1;
      let theta2 = defaultTheta2;
      let omega1 = 0;
      let omega2 = 0;

      let time = 0;
      let simulationUpdateRateHz = 120;
      let timeStep = 1 / simulationUpdateRateHz;
      let canvasRenderRateFps = 60;
      let timeSinceLastRender = 0;
      let timeSinceLastPhysicsUpdate = 0;
      let lastTimestamp = 0;

      let pixelsPerMeter = 100;
      let isRunning = false;
      let animationFrameId = null;
      let isDraggingM1 = false;
      let isDraggingM2 = false;
      let originX, originY;

      const sanitizeTraceLimit = (value) => Math.max(0, Math.floor(value));
      const computeTraceCapacity = (limit) => Math.max(1, limit || 1);

      const createTraceBuffer = (maxPoints) => {
        const limit = sanitizeTraceLimit(maxPoints);
        const capacity = computeTraceCapacity(limit);
        return {
          xs: new Float32Array(capacity),
          ys: new Float32Array(capacity),
          start: 0,
          size: 0,
          capacity,
          limit,
        };
      };

      const resizeTraceBuffer = (buffer, maxPoints) => {
        const limit = sanitizeTraceLimit(maxPoints);
        const capacity = computeTraceCapacity(limit);
        if (buffer.capacity !== capacity) {
          buffer.xs = new Float32Array(capacity);
          buffer.ys = new Float32Array(capacity);
          buffer.capacity = capacity;
        }
        buffer.start = 0;
        buffer.size = 0;
        buffer.limit = limit;
        return buffer;
      };

      const clearTraceBuffer = (buffer) => {
        buffer.start = 0;
        buffer.size = 0;
      };

      const pushTracePoint = (buffer, x, y) => {
        if (buffer.limit === 0) return;
        const idx = (buffer.start + buffer.size) % buffer.capacity;
        buffer.xs[idx] = x;
        buffer.ys[idx] = y;
        if (buffer.size < buffer.limit) {
          buffer.size++;
        } else {
          buffer.start = (buffer.start + 1) % buffer.capacity;
        }
      };

      let trace1 = createTraceBuffer(trace1MaxLength);
      let trace2 = createTraceBuffer(trace2MaxLength);

      const fieldVisualCache = {
        magnetic: {
          positions: new Float32Array(0),
          strength: 0,
          symbol: "⊗",
          fillStyle: "",
          fontSize: 12,
          fieldLines: [], // Array of {x, y, vx, vy} for field line segments
        },
        wind: {
          positions: new Float32Array(0),
          color: "",
          magnitude: 0,
          length: 0,
          angle: 0,
          streamlines: [], // Better visualization with streamlines
        },
        electric: {
          charges: [], // {x, y, q} for visualizing charges
          fieldArrows: [], // Electric field arrows around charges
        },
      };

      const fract = (value) => value - Math.floor(value);
      const seededRandom = (index, salt) =>
        fract(Math.sin(index * 12.9898 + salt * 78.233) * 43758.5453);
      let chaosValueHistory = [];
      const CHAOS_HISTORY_LENGTH = 120;
      let colorBob1, colorBob2, colorTrace1, colorTrace2, colorRod, colorPivot;
      let colorEnergy,
        colorChaos,
        colorOmega1,
        colorOmega2,
        colorChartBg,
        colorChartGrid;
      let colorKE, colorPE, colorKE1, colorKE2, colorPE1, colorPE2;

      const HISTORY_LENGTH = 200;
      let omega1History = [];
      let omega2History = [];
      let energyPlotHistory = [];
      let kePlotHistory = [];
      let pePlotHistory = [];
      let ke1PlotHistory = [];
      let ke2PlotHistory = [];
      let pe1PlotHistory = [];
      let pe2PlotHistory = [];

      let recordedData = [];
      let maxRecordingTime = 60;
      let currentRecordingMode = "live";
      const LOCAL_STORAGE_KEY = "pendulumRecordedData_v2";
      let isGeneratingFastCSV = false;
      let fastCsvStartTime = 0;

      function getCssVariable(varName) {
        return getComputedStyle(document.documentElement)
          .getPropertyValue(varName)
          .trim();
      }

      function loadColors() {
        colorBob1 = getCssVariable("--accent-crimson");
        colorBob2 = getCssVariable("--accent-purple");
        colorTrace1 = `${colorBob1}99`;
        colorTrace2 = `${colorBob2}99`;
        colorRod = getCssVariable("--accent-grey");
        colorPivot = getCssVariable("--text-color-dark");
        colorEnergy = getCssVariable("--accent-cyan");
        colorChaos = getCssVariable("--accent-pink");
        colorOmega1 = colorBob1;
        colorOmega2 = colorBob2;
        colorKE = getCssVariable("--accent-green");
        colorPE = getCssVariable("--accent-blue");
        colorKE1 = `${colorKE}aa`;
        colorKE2 = `${colorKE}66`;
        colorPE1 = `${colorPE}aa`;
        colorPE2 = `${colorPE}66`;
        colorChartBg = getCssVariable("--chart-bg");
        colorChartGrid = getCssVariable("--accent-light-grey");
        omega1Display.style.color = colorOmega1;
        omega2Display.style.color = colorOmega2;
        energyDisplay.style.color = colorEnergy;
        keTotalDisplay.style.color = colorKE;
        peTotalDisplay.style.color = colorPE;
        ke1Display.style.color = colorKE1;
        ke2Display.style.color = colorKE2;
        pe1Display.style.color = colorPE1;
        pe2Display.style.color = colorPE2;
        chaosDisplay.style.color = colorChaos;
        avgEnergyDisplay.style.color = colorEnergy;
      }

      function calculateAccelerations(
        currentTheta1,
        currentTheta2,
        currentOmega1,
        currentOmega2
      ) {
        const s1 = Math.sin(currentTheta1);
        const c1 = Math.cos(currentTheta1);
        const s2 = Math.sin(currentTheta2);
        const c2 = Math.cos(currentTheta2);
        const deltaTheta = currentTheta1 - currentTheta2;
        const sinDeltaTheta = Math.sin(deltaTheta);
        const cosDeltaTheta = Math.cos(deltaTheta);
        const m1PlusM2 = mass1 + mass2;
        const epsilon = 1e-9;
        const commonDenominatorTerm =
          2 * mass1 + mass2 - mass2 * Math.cos(2 * deltaTheta);
        let num1 = -gravity * (2 * mass1 + mass2) * s1;
        num1 -= mass2 * gravity * Math.sin(currentTheta1 - 2 * currentTheta2);
        num1 -=
          2 *
          sinDeltaTheta *
          mass2 *
          (currentOmega2 * currentOmega2 * length2 +
            currentOmega1 * currentOmega1 * length1 * cosDeltaTheta);
        let den1 = length1 * commonDenominatorTerm;
        let angularAccel1 = Math.abs(den1) > epsilon ? num1 / den1 : 0;
        let num2 = 2 * sinDeltaTheta;
        num2 *=
          currentOmega1 * currentOmega1 * length1 * m1PlusM2 +
          gravity * m1PlusM2 * c1 +
          currentOmega2 * currentOmega2 * length2 * mass2 * cosDeltaTheta;
        let den2 = length2 * commonDenominatorTerm;
        let angularAccel2 = Math.abs(den2) > epsilon ? num2 / den2 : 0;
        let torque1Ext = 0;
        let torque2Ext = 0;
        const { f1bx, f1by, f1wx, f1wy, f2bx, f2by, f2wx, f2wy } =
          calculateExternalForces(
            currentTheta1,
            currentTheta2,
            currentOmega1,
            currentOmega2
          );
        if (
          Math.abs(f1wx) > epsilon ||
          Math.abs(f1wy) > epsilon ||
          Math.abs(f1bx) > epsilon ||
          Math.abs(f1by) > epsilon ||
          Math.abs(f2wx) > epsilon ||
          Math.abs(f2wy) > epsilon ||
          Math.abs(f2bx) > epsilon ||
          Math.abs(f2by) > epsilon
        ) {
          const x1Pos = length1 * s1;
          const y1Pos = length1 * c1;
          const x2PosRel = length2 * s2;
          const y2PosRel = length2 * c2;
          const r1CrossF1 = x1Pos * (f1wy + f1by) - y1Pos * (f1wx + f1bx);
          const r2CrossF2 =
            (x1Pos + x2PosRel) * (f2wy + f2by) -
            (y1Pos + y2PosRel) * (f2wx + f2bx);
          const r2RelCrossF2 =
            x2PosRel * (f2wy + f2by) - y2PosRel * (f2wx + f2bx);
          torque1Ext += r1CrossF1 + r2CrossF2;
          torque2Ext += r2RelCrossF2;
        }
        if (Math.abs(torque1Ext) > epsilon || Math.abs(torque2Ext) > epsilon) {
          const M11 = (mass1 + mass2) * length1 * length1;
          const M12 = mass2 * length1 * length2 * cosDeltaTheta;
          const M22 = mass2 * length2 * length2;
          const detM = M11 * M22 - M12 * M12;
          if (Math.abs(detM) > epsilon) {
            const invM11 = M22 / detM;
            const invM12 = -M12 / detM;
            const invM22 = M11 / detM;
            angularAccel1 += invM11 * torque1Ext + invM12 * torque2Ext;
            angularAccel2 += invM12 * torque1Ext + invM22 * torque2Ext;
          }
        }
        angularAccel1 -= damping1 * currentOmega1;
        angularAccel2 -= damping2 * currentOmega2;
        return { angularAccel1, angularAccel2 };
      }

      // Velocity Verlet integrator (symplectic, energy-preserving)
      // Also known as leapfrog method: half-step velocity, full-step position, half-step velocity
      // Conserves energy better than standard explicit Euler methods
      function symplecticIntegrate(dt) {
        const halfStep = dt * 0.5;

        // Half-step velocity update using current positions
        const firstAccel = calculateAccelerations(
          theta1,
          theta2,
          omega1,
          omega2
        );
        omega1 += firstAccel.angularAccel1 * halfStep;
        omega2 += firstAccel.angularAccel2 * halfStep;

        // Full-step position update using half-stepped velocities
        theta1 += omega1 * dt;
        theta2 += omega2 * dt;

        // Complete velocity update using new positions
        const secondAccel = calculateAccelerations(
          theta1,
          theta2,
          omega1,
          omega2
        );
        omega1 += secondAccel.angularAccel1 * halfStep;
        omega2 += secondAccel.angularAccel2 * halfStep;
      }

      function updatePhysics() {
        symplecticIntegrate(timeStep);
        time += timeStep;
        if (
          currentRecordingMode === "live" &&
          time <= maxRecordingTime &&
          isRunning
        ) {
          recordDataPoint();
          if (
            recordedData.length === 1 ||
            recordedData.length % simulationUpdateRateHz === 0
          ) {
            updateRecordingStatus();
          }
        }
      }

      function recordDataPoint() {
        const { ke1, ke2, pe1, pe2 } = calculateEnergies();
        const s1 = Math.sin(theta1);
        const c1 = Math.cos(theta1);
        const s2 = Math.sin(theta2);
        const c2 = Math.cos(theta2);
        const x1m = length1 * s1;
        const y1m = length1 * c1;
        const x2m = x1m + length2 * s2;
        const y2m = y1m + length2 * c2;
        recordedData.push({
          time: time,
          theta1,
          theta2,
          omega1,
          omega2,
          x1: x1m,
          y1: y1m,
          x2: x2m,
          y2: y2m,
          ke1,
          ke2,
          pe1,
          pe2,
          ke_total: ke1 + ke2,
          pe_total: pe1 + pe2,
          e_total: ke1 + ke2 + pe1 + pe2,
        });
      }

      function updateRecordingStatus() {
        if (isGeneratingFastCSV) return;
        if (time > maxRecordingTime) {
          dataRecordingStatus.textContent = `Max recording time (${maxRecordingTime}s) reached. Data saved.`;
        } else if (isRunning) {
          const progress = (time / maxRecordingTime) * 100;
          dataRecordingStatus.textContent = `Recording... ${time.toFixed(
            1
          )}s / ${maxRecordingTime}s (${progress.toFixed(0)}%)`;
        } else if (recordedData.length > 0) {
          dataRecordingStatus.textContent = `Recording paused at ${time.toFixed(
            1
          )}s. Data saved.`;
        } else {
          dataRecordingStatus.textContent = `Ready to record (max ${maxRecordingTime}s). Press Start.`;
        }
      }

      function drawElectricCharges(x1, y1, x2, y2) {
        const epsilon = 0.01;
        if (Math.abs(charge1) < epsilon && Math.abs(charge2) < epsilon) return;

        ctx.save();

        // Draw charge indicators on the bobs
        if (Math.abs(charge1) >= epsilon) {
          const radius = 8 + Math.min(12, Math.abs(charge1) * 10);
          ctx.strokeStyle = charge1 > 0
            ? `rgba(255, 0, 255, ${Math.min(0.8, 0.3 + Math.abs(charge1) * 0.2)})`
            : `rgba(0, 255, 255, ${Math.min(0.8, 0.3 + Math.abs(charge1) * 0.2)})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x1, y1, radius, 0, Math.PI * 2);
          ctx.stroke();

          // Draw + or - symbol
          ctx.fillStyle = ctx.strokeStyle;
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(charge1 > 0 ? '+' : '−', x1, y1 - radius - 12);
        }

        if (Math.abs(charge2) >= epsilon) {
          const radius = 8 + Math.min(12, Math.abs(charge2) * 10);
          ctx.strokeStyle = charge2 > 0
            ? `rgba(255, 0, 255, ${Math.min(0.8, 0.3 + Math.abs(charge2) * 0.2)})`
            : `rgba(0, 255, 255, ${Math.min(0.8, 0.3 + Math.abs(charge2) * 0.2)})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x2, y2, radius, 0, Math.PI * 2);
          ctx.stroke();

          ctx.fillStyle = ctx.strokeStyle;
          ctx.font = 'bold 16px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(charge2 > 0 ? '+' : '−', x2, y2 - radius - 12);
        }

        // Draw electric field lines if both charges exist and magnetic field is present
        if (Math.abs(charge1) >= epsilon && Math.abs(charge2) >= epsilon && Math.abs(magFieldBz) >= epsilon) {
          // Show Lorentz force effect - curved trajectory indicators
          const s1 = Math.sin(theta1);
          const c1 = Math.cos(theta1);
          const s2 = Math.sin(theta2);
          const c2 = Math.cos(theta2);
          const vx1 = length1 * c1 * omega1;
          const vy1 = -length1 * s1 * omega1;
          const vx2 = vx1 + length2 * c2 * omega2;
          const vy2 = vy1 - length2 * s2 * omega2;

          const v1mag = Math.hypot(vx1, vy1);
          const v2mag = Math.hypot(vx2, vy2);

          if (v1mag > epsilon) {
            const forceScale = 30;
            const fx = charge1 * vy1 * magFieldBz * forceScale;
            const fy = -charge1 * vx1 * magFieldBz * forceScale;
            drawArrow(x1, y1, Math.atan2(fy, fx), Math.min(40, Math.hypot(fx, fy)),
              `rgba(255, 0, 255, 0.6)`, false);
          }

          if (v2mag > epsilon) {
            const forceScale = 30;
            const fx = charge2 * vy2 * magFieldBz * forceScale;
            const fy = -charge2 * vx2 * magFieldBz * forceScale;
            drawArrow(x2, y2, Math.atan2(fy, fx), Math.min(40, Math.hypot(fx, fy)),
              `rgba(255, 0, 255, 0.6)`, false);
          }
        }

        ctx.restore();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = getCssVariable("--bg-color");
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawMagneticField();
        drawWindField();
        const l1Px = length1 * pixelsPerMeter;
        const l2Px = length2 * pixelsPerMeter;
        const s1 = Math.sin(theta1);
        const c1 = Math.cos(theta1);
        const s2 = Math.sin(theta2);
        const c2 = Math.cos(theta2);
        const x1Rel = l1Px * s1;
        const y1Rel = l1Px * c1;
        const x2Rel = x1Rel + l2Px * s2;
        const y2Rel = y1Rel + l2Px * c2;
        const x1 = originX + x1Rel;
        const y1 = originY + y1Rel;
        const x2 = originX + x2Rel;
        const y2 = originY + y2Rel;
        drawElectricCharges(x1, y1, x2, y2);
        if (isRunning || isDraggingM1 || isDraggingM2) {
          pushTracePoint(trace1, x1, y1);
          pushTracePoint(trace2, x2, y2);
        }
        drawTrace(trace1, colorTrace1);
        drawTrace(trace2, colorTrace2);
        drawRod(originX, originY, x1, y1);
        drawRod(x1, y1, x2, y2);
        drawPivot(originX, originY);
        drawBob(x1, y1, mass1, colorBob1);
        drawBob(x2, y2, mass2, colorBob2);
        drawDampingForces(x1, y1, x2, y2);
      }

      function refreshMagneticFieldCache() {
        const cache = fieldVisualCache.magnetic;
        cache.strength = Math.abs(magFieldBz);
        cache.symbol = magFieldBz >= 0 ? "⊗" : "⊙";
        cache.fillStyle = cache.strength < 0.01
          ? ""
          : `${magFieldBz >= 0 ? "rgba(0, 0, 255," : "rgba(255, 0, 0,"}${Math.min(
              0.35,
              0.1 + cache.strength * 0.05
            )})`;
        cache.fontSize = 10 + Math.min(10, cache.strength * 2);

        if (cache.strength < 0.01 || canvas.width === 0 || canvas.height === 0) {
          cache.positions = new Float32Array(0);
          cache.fieldLines = [];
          return;
        }

        const densityFactor = Math.min(10, 1 + cache.strength * 2);
        const baseDensityArea = 400 * 400;
        const numSymbols = Math.floor(
          ((canvas.width * canvas.height) / baseDensityArea) * densityFactor * 20
        );
        const positions = new Float32Array(numSymbols * 2);
        for (let i = 0; i < numSymbols; i++) {
          const x = seededRandom(i + 1, 0.5) * canvas.width;
          const y = seededRandom(i + 1, 1.5) * canvas.height;
          positions[i * 2] = x;
          positions[i * 2 + 1] = y;
        }
        cache.positions = positions;

        // Generate circular magnetic field lines (perpendicular to B field)
        cache.fieldLines = [];
        const numCircles = Math.min(8, Math.floor(2 + cache.strength));
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const maxRadius = Math.min(canvas.width, canvas.height) * 0.45;

        for (let i = 1; i <= numCircles; i++) {
          const radius = (maxRadius / numCircles) * i;
          const numPoints = Math.max(24, Math.floor(radius / 8));
          const points = [];
          for (let j = 0; j < numPoints; j++) {
            const angle = (j / numPoints) * Math.PI * 2;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);
            // Tangent direction (perpendicular to radius)
            const tx = -Math.sin(angle) * (magFieldBz >= 0 ? 1 : -1);
            const ty = Math.cos(angle) * (magFieldBz >= 0 ? 1 : -1);
            points.push({ x, y, tx, ty });
          }
          cache.fieldLines.push(points);
        }
      }

      function refreshWindFieldCache() {
        const cache = fieldVisualCache.wind;
        cache.magnitude = dirForceMag;
        cache.angle = dirForceAngleRad;

        if (cache.magnitude < 0.01 || canvas.width === 0 || canvas.height === 0) {
          cache.positions = new Float32Array(0);
          cache.color = "";
          cache.length = 0;
          cache.streamlines = [];
          return;
        }

        const densityFactor = Math.min(5, cache.magnitude) * 10;
        const baseDensityArea = 400 * 400;
        const numArrows = Math.floor(
          ((canvas.width * canvas.height) / baseDensityArea) * densityFactor * 10
        );
        const alpha = Math.min(0.4, 0.1 + cache.magnitude * 0.1);
        cache.color = `rgba(0, 255, 0, ${alpha})`;
        cache.length = 15 + Math.min(15, cache.magnitude * 10);
        const positions = new Float32Array(numArrows * 2);
        for (let i = 0; i < numArrows; i++) {
          const x = seededRandom(i + 1, 2.5) * canvas.width;
          const y = seededRandom(i + 1, 3.5) * canvas.height;
          positions[i * 2] = x;
          positions[i * 2 + 1] = y;
        }
        cache.positions = positions;

        // Generate streamlines for better wind visualization
        cache.streamlines = [];
        const numStreams = Math.max(5, Math.floor(cache.magnitude * 3));
        const streamLength = cache.length * 2;
        const dx = Math.cos(cache.angle);
        const dy = Math.sin(cache.angle);

        for (let i = 0; i < numStreams; i++) {
          const startX = seededRandom(i + 100, 4.5) * canvas.width;
          const startY = seededRandom(i + 100, 5.5) * canvas.height;
          const points = [];
          for (let j = 0; j <= 8; j++) {
            const t = j / 8;
            points.push({
              x: startX + dx * streamLength * t,
              y: startY + dy * streamLength * t,
            });
          }
          cache.streamlines.push(points);
        }
      }

      function drawMagneticField() {
        const cache = fieldVisualCache.magnetic;
        if (cache.positions.length < 2 || cache.strength < 0.01) return;
        ctx.save();

        // Draw circular field lines (improved visualization)
        if (cache.fieldLines.length > 0) {
          ctx.strokeStyle = magFieldBz >= 0
            ? `rgba(0, 255, 255, ${Math.min(0.6, 0.2 + cache.strength * 0.1)})`
            : `rgba(255, 0, 255, ${Math.min(0.6, 0.2 + cache.strength * 0.1)})`;
          ctx.lineWidth = 2;

          for (const circle of cache.fieldLines) {
            ctx.beginPath();
            ctx.moveTo(circle[0].x, circle[0].y);
            for (let i = 1; i < circle.length; i++) {
              ctx.lineTo(circle[i].x, circle[i].y);
            }
            ctx.closePath();
            ctx.stroke();

            // Draw direction arrows on field lines
            const arrowCount = Math.max(3, Math.floor(circle.length / 8));
            for (let i = 0; i < arrowCount; i++) {
              const idx = Math.floor((i / arrowCount) * circle.length);
              const pt = circle[idx];
              const arrowSize = 8;
              ctx.save();
              ctx.translate(pt.x, pt.y);
              const angle = Math.atan2(pt.ty, pt.tx);
              ctx.rotate(angle);
              ctx.fillStyle = ctx.strokeStyle;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(-arrowSize, -arrowSize/2);
              ctx.lineTo(-arrowSize, arrowSize/2);
              ctx.closePath();
              ctx.fill();
              ctx.restore();
            }
          }
        }

        // Still draw symbols for density indication
        ctx.font = `${cache.fontSize}px Arial`;
        ctx.fillStyle = cache.fillStyle;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let i = 0; i < cache.positions.length; i += 2) {
          ctx.fillText(cache.symbol, cache.positions[i], cache.positions[i + 1]);
        }
        ctx.restore();
      }

      function drawWindField() {
        const cache = fieldVisualCache.wind;
        if (cache.positions.length < 2 || cache.magnitude < 0.01) return;

        // Draw streamlines for better flow visualization
        if (cache.streamlines.length > 0) {
          ctx.save();
          const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          gradient.addColorStop(0, `rgba(0, 255, 0, ${Math.min(0.3, cache.magnitude * 0.1)})`);
          gradient.addColorStop(1, `rgba(0, 255, 0, ${Math.min(0.6, cache.magnitude * 0.2)})`);
          ctx.strokeStyle = gradient;
          ctx.lineWidth = 2;

          for (const stream of cache.streamlines) {
            ctx.beginPath();
            ctx.moveTo(stream[0].x, stream[0].y);
            for (let i = 1; i < stream.length; i++) {
              ctx.lineTo(stream[i].x, stream[i].y);
            }
            ctx.stroke();

            // Draw arrow at end of streamline
            const last = stream[stream.length - 1];
            drawArrow(last.x, last.y, cache.angle, cache.length * 0.6, cache.color, true);
          }
          ctx.restore();
        }

        // Draw individual arrows
        for (let i = 0; i < cache.positions.length; i += 2) {
          drawArrow(
            cache.positions[i],
            cache.positions[i + 1],
            cache.angle,
            cache.length,
            cache.color,
            true
          );
        }
      }

      function drawDampingForces(x1, y1, x2, y2) {
        const epsilon = 0.01;
        const { f1dx, f1dy, f2dx, f2dy } = calculateExternalForces(
          theta1,
          theta2,
          omega1,
          omega2
        );
        const dampingForce1Mag = Math.hypot(f1dx, f1dy);
        if (dampingForce1Mag > epsilon) {
          const scale = Math.min(40, 10 + dampingForce1Mag * 5);
          const angle1 = Math.atan2(f1dy, f1dx);
          drawArrow(
            x1,
            y1,
            angle1,
            scale,
            `rgba(100, 100, 100, ${Math.min(
              0.8,
              0.1 + dampingForce1Mag * 0.5
            )})`
          );
        }
        const dampingForce2Mag = Math.hypot(f2dx, f2dy);
        if (dampingForce2Mag > epsilon) {
          const scale = Math.min(40, 10 + dampingForce2Mag * 5);
          const angle2 = Math.atan2(f2dy, f2dx);
          drawArrow(
            x2,
            y2,
            angle2,
            scale,
            `rgba(100, 100, 100, ${Math.min(
              0.8,
              0.1 + dampingForce2Mag * 0.5
            )})`
          );
        }
      }

      function drawArrow(x, y, angleRad, length, color, isWind = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angleRad);
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = isWind ? 1 : 1.5;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(isWind ? length : -length, 0);
        ctx.stroke();
        const headSize = isWind ? 4 : 6;
        const headOffset = isWind ? length : -length;
        ctx.beginPath();
        ctx.moveTo(headOffset, 0);
        ctx.lineTo(headOffset - headSize, -headSize / 2);
        ctx.lineTo(headOffset - headSize, headSize / 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawTrace(traceBuffer, color) {
        if (traceBuffer.size < 2 || traceBuffer.limit === 0) return;
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        let idx = traceBuffer.start;
        ctx.moveTo(traceBuffer.xs[idx], traceBuffer.ys[idx]);
        for (let i = 1; i < traceBuffer.size; i++) {
          idx = (idx + 1) % traceBuffer.capacity;
          ctx.lineTo(traceBuffer.xs[idx], traceBuffer.ys[idx]);
        }
        ctx.stroke();
      }

      function drawRod(xStart, yStart, xEnd, yEnd) {
        ctx.strokeStyle = colorRod;
        ctx.lineWidth = 4;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(xStart, yStart);
        ctx.lineTo(xEnd, yEnd);
        ctx.stroke();
      }

      function drawPivot(x, y) {
        ctx.fillStyle = colorPivot;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fill();
      }
      function drawBob(x, y, m, color) {
        const radius = 6 + Math.sqrt(Math.max(0.1, m)) * 5;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      function updateHistory() {
        if (!isRunning && !isDraggingM1 && !isDraggingM2) return;
        const { ke1, ke2, pe1, pe2, totalEnergy } = calculateEnergies();
        const { stabilityValue, meanEnergy } = calculateEnergyStability(totalEnergy);
        energyPlotHistory.push(totalEnergy);
        kePlotHistory.push(ke1 + ke2);
        pePlotHistory.push(pe1 + pe2);
        ke1PlotHistory.push(ke1);
        ke2PlotHistory.push(ke2);
        pe1PlotHistory.push(pe1);
        pe2PlotHistory.push(pe2);
        omega1History.push(omega1);
        omega2History.push(omega2);
        chaosValueHistory.push(stabilityValue);
        const shiftIfLonger = (arr) => {
          if (arr.length > HISTORY_LENGTH) arr.shift();
        };
        [
          energyPlotHistory,
          kePlotHistory,
          pePlotHistory,
          ke1PlotHistory,
          ke2PlotHistory,
          pe1PlotHistory,
          pe2PlotHistory,
          omega1History,
          omega2History,
          chaosValueHistory,
        ].forEach(shiftIfLonger);
      }

      function calculateEnergies() {
        const c1 = Math.cos(theta1);
        const c2 = Math.cos(theta2);
        const cosDeltaTheta = Math.cos(theta1 - theta2);
        const ke1 = 0.5 * mass1 * (length1 * omega1) ** 2;
        const ke2_term1 = (length1 * omega1) ** 2;
        const ke2_term2 = (length2 * omega2) ** 2;
        const ke2_term3 =
          2 * length1 * length2 * omega1 * omega2 * cosDeltaTheta;
        const ke2 = 0.5 * mass2 * (ke2_term1 + ke2_term2 + ke2_term3);
        const kineticEnergy = ke1 + ke2;
        const pe1 = -mass1 * gravity * length1 * c1;
        const pe2 = -mass2 * gravity * (length1 * c1 + length2 * c2);
        const potentialEnergy = pe1 + pe2;
        const totalEnergy = kineticEnergy + potentialEnergy;
        return {
          ke1,
          ke2,
          pe1,
          pe2,
          kineticEnergy,
          potentialEnergy,
          totalEnergy,
        };
      }

      let energyHistoryForStability = [];
      function calculateEnergyStability(currentEnergy) {
        if (isDraggingM1 || isDraggingM2) {
          energyHistoryForStability = [];
          return { stabilityValue: 0, meanEnergy: calculateEnergies().totalEnergy };
        }
        energyHistoryForStability.push(currentEnergy);
        if (energyHistoryForStability.length > CHAOS_HISTORY_LENGTH)
          energyHistoryForStability.shift();
        const n = energyHistoryForStability.length;
        if (n < CHAOS_HISTORY_LENGTH / 2)
          return {
            stabilityValue: 0,
            meanEnergy:
              n > 0
                ? energyHistoryForStability.reduce((s, e) => s + e, 0) / n
                : currentEnergy,
          };
        const meanEnergy =
          energyHistoryForStability.reduce((sum, e) => sum + e, 0) / n;
        if (Math.abs(meanEnergy) < 1e-6) return { stabilityValue: 0, meanEnergy };
        const variance =
          energyHistoryForStability.reduce(
            (sum, e) => sum + (e - meanEnergy) ** 2,
            0
          ) / n;
        const stDev = Math.sqrt(variance);
        const stabilityValue = (stDev / Math.abs(meanEnergy)) * 100;
        return { stabilityValue, meanEnergy };
      }

      function calculateExternalForces(
        currentTheta1,
        currentTheta2,
        currentOmega1,
        currentOmega2
      ) {
        const s1 = Math.sin(currentTheta1);
        const c1 = Math.cos(currentTheta1);
        const s2 = Math.sin(currentTheta2);
        const c2 = Math.cos(currentTheta2);
        const vx1 = length1 * c1 * currentOmega1;
        const vy1 = -length1 * s1 * currentOmega1;
        const vx2 = vx1 + length2 * c2 * currentOmega2;
        const vy2 = vy1 - length2 * s2 * currentOmega2;
        const f1gx = 0;
        const f1gy = -mass1 * gravity;
        const f2gx = 0;
        const f2gy = -mass2 * gravity;
        const f1dx = -damping1 * vx1;
        const f1dy = -damping1 * vy1;
        const f2dx = -damping2 * vx2;
        const f2dy = -damping2 * vy2;
        let f1bx = 0,
          f1by = 0,
          f2bx = 0,
          f2by = 0;
        if (Math.abs(magFieldBz) > 1e-9 && Math.abs(charge1) > 1e-9) {
          f1bx = charge1 * vy1 * magFieldBz;
          f1by = -charge1 * vx1 * magFieldBz;
        }
        if (Math.abs(magFieldBz) > 1e-9 && Math.abs(charge2) > 1e-9) {
          f2bx = charge2 * vy2 * magFieldBz;
          f2by = -charge2 * vx2 * magFieldBz;
        }
        let f1wx = 0,
          f1wy = 0,
          f2wx = 0,
          f2wy = 0;
        if (dirForceMag > 1e-9) {
          // dirForceMag is in Newtons (force), use directly without multiplying by mass
          const windForceX = dirForceMag * Math.cos(dirForceAngleRad);
          const windForceY = dirForceMag * Math.sin(dirForceAngleRad);
          f1wx = windForceX;
          f1wy = windForceY;
          f2wx = windForceX;
          f2wy = windForceY;
        }
        return {
          f1gx,
          f1gy,
          f1dx,
          f1dy,
          f1bx,
          f1by,
          f1wx,
          f1wy,
          f2gx,
          f2gy,
          f2dx,
          f2dy,
          f2bx,
          f2by,
          f2wx,
          f2wy,
        };
      }

      function updateVisualsPanel() {
        const circleRadius = 25;
        const dotRadius = 4;
        const angleVizRadius = circleRadius - dotRadius;
        const angle1X = Math.sin(theta1);
        const angle1Y = Math.cos(theta1);
        posDot1.style.transform = `translate(calc(-50% + ${
          angle1X * angleVizRadius
        }px), calc(-50% + ${angle1Y * angleVizRadius}px))`;
        const angle2X = Math.sin(theta2);
        const angle2Y = Math.cos(theta2);
        posDot2.style.transform = `translate(calc(-50% + ${
          angle2X * angleVizRadius
        }px), calc(-50% + ${angle2Y * angleVizRadius}px))`;

        omega1Display.textContent = omega1.toFixed(2);
        omega2Display.textContent = omega2.toFixed(2);
        const maxOmegaVis = 10;
        rpmNeedle1.style.transform = `rotate(${Math.max(
          -135,
          Math.min(135, omega1 * (135 / maxOmegaVis))
        )}deg)`;
        rpmNeedle2.style.transform = `rotate(${Math.max(
          -135,
          Math.min(135, omega2 * (135 / maxOmegaVis))
        )}deg)`;

        const {
          ke1,
          ke2,
          pe1,
          pe2,
          kineticEnergy,
          potentialEnergy,
          totalEnergy,
        } = calculateEnergies();
        keTotalDisplay.textContent = kineticEnergy.toFixed(2);
        peTotalDisplay.textContent = potentialEnergy.toFixed(2);
        energyDisplay.textContent = totalEnergy.toFixed(2);
        ke1Display.textContent = ke1.toFixed(2);
        ke2Display.textContent = ke2.toFixed(2);
        pe1Display.textContent = pe1.toFixed(2);
        pe2Display.textContent = pe2.toFixed(2);
        const { stabilityValue, meanEnergy } = calculateEnergyStability(totalEnergy);
        avgEnergyDisplay.textContent =
          isDraggingM1 || isDraggingM2 ? "N/A" : meanEnergy.toFixed(2);
        chaosDisplay.textContent =
          isDraggingM1 || isDraggingM2 ? "N/A" : stabilityValue.toFixed(2);

        const forces = calculateExternalForces(theta1, theta2, omega1, omega2);
        f1gxDisplay.textContent = forces.f1gx.toFixed(2);
        f1gyDisplay.textContent = forces.f1gy.toFixed(2);
        f1dxDisplay.textContent = forces.f1dx.toFixed(2);
        f1dyDisplay.textContent = forces.f1dy.toFixed(2);
        f1bxDisplay.textContent = forces.f1bx.toFixed(2);
        f1byDisplay.textContent = forces.f1by.toFixed(2);
        f1wxDisplay.textContent = forces.f1wx.toFixed(2);
        f1wyDisplay.textContent = forces.f1wy.toFixed(2);
        f2gxDisplay.textContent = forces.f2gx.toFixed(2);
        f2gyDisplay.textContent = forces.f2gy.toFixed(2);
        f2dxDisplay.textContent = forces.f2dx.toFixed(2);
        f2dyDisplay.textContent = forces.f2dy.toFixed(2);
        f2bxDisplay.textContent = forces.f2bx.toFixed(2);
        f2byDisplay.textContent = forces.f2by.toFixed(2);
        f2wxDisplay.textContent = forces.f2wx.toFixed(2);
        f2wyDisplay.textContent = forces.f2wy.toFixed(2);

        currentTheta1Display.value = ((theta1 * 180) / Math.PI).toFixed(1);
        currentTheta2Display.value = ((theta2 * 180) / Math.PI).toFixed(1);
      }

      function drawHistoryCharts() {
        if (isGeneratingFastCSV) return;
        drawOmegaHistoryChart();
        drawEnergyHistoryChart();
        drawChaosHistoryChart();
      }
      function drawOmegaHistoryChart() {
        const chartCtx = omegaChartCtx;
        const canvas = omegaHistoryChartCanvas;
        const w = canvas.width;
        const h = canvas.height;
        chartCtx.fillStyle = colorChartBg;
        chartCtx.fillRect(0, 0, w, h);
        chartCtx.strokeStyle = colorChartGrid;
        chartCtx.lineWidth = 0.5;
        chartCtx.beginPath();
        chartCtx.moveTo(0, h / 2);
        chartCtx.lineTo(w, h / 2);
        chartCtx.stroke();
        const maxAbsOmega = Math.max(
          1,
          ...omega1History.map(Math.abs),
          ...omega2History.map(Math.abs)
        );
        const scaleOmega = h / 2 / (maxAbsOmega + 1e-6);
        plotHistoryLine(
          chartCtx,
          canvas,
          omega1History,
          colorOmega1,
          scaleOmega,
          h / 2,
          1.5
        );
        plotHistoryLine(
          chartCtx,
          canvas,
          omega2History,
          colorOmega2,
          scaleOmega,
          h / 2,
          1.5
        );
      }
      function drawEnergyHistoryChart() {
        const chartCtx = energyChartCtx;
        const canvas = energyHistoryChartCanvas;
        const w = canvas.width;
        const h = canvas.height;
        chartCtx.fillStyle = colorChartBg;
        chartCtx.fillRect(0, 0, w, h);
        chartCtx.strokeStyle = colorChartGrid;
        chartCtx.lineWidth = 0.5;
        chartCtx.beginPath();
        chartCtx.moveTo(0, h / 3);
        chartCtx.lineTo(w, h / 3);
        chartCtx.moveTo(0, (2 * h) / 3);
        chartCtx.lineTo(w, (2 * h) / 3);
        chartCtx.stroke();
        const allEnergies = [
          ...energyPlotHistory,
          ...kePlotHistory,
          ...pePlotHistory,
        ];
        const finiteEnergies = allEnergies.filter((e) => isFinite(e));
        const minE =
          finiteEnergies.length > 0 ? Math.min(...finiteEnergies) : -1;
        const maxE =
          finiteEnergies.length > 0 ? Math.max(...finiteEnergies) : 1;
        const energyRange = Math.max(1e-6, maxE - minE);
        const scaleEnergy = h / (energyRange + 1e-6);
        const yOffsetEnergy = h - maxE * scaleEnergy;
        plotHistoryLine(
          chartCtx,
          canvas,
          pePlotHistory,
          colorPE,
          scaleEnergy,
          yOffsetEnergy,
          1.5
        );
        plotHistoryLine(
          chartCtx,
          canvas,
          kePlotHistory,
          colorKE,
          scaleEnergy,
          yOffsetEnergy,
          1.5
        );
        plotHistoryLine(
          chartCtx,
          canvas,
          energyPlotHistory,
          colorEnergy,
          scaleEnergy,
          yOffsetEnergy,
          1.0
        );
        plotHistoryLine(
          chartCtx,
          canvas,
          pe1PlotHistory,
          colorPE1,
          scaleEnergy,
          yOffsetEnergy,
          0.8
        );
        plotHistoryLine(
          chartCtx,
          canvas,
          pe2PlotHistory,
          colorPE2,
          scaleEnergy,
          yOffsetEnergy,
          0.8
        );
        plotHistoryLine(
          chartCtx,
          canvas,
          ke1PlotHistory,
          colorKE1,
          scaleEnergy,
          yOffsetEnergy,
          0.8
        );
        plotHistoryLine(
          chartCtx,
          canvas,
          ke2PlotHistory,
          colorKE2,
          scaleEnergy,
          yOffsetEnergy,
          0.8
        );
      }
      function drawChaosHistoryChart() {
        const chartCtx = chaosChartCtx;
        const canvas = chaosHistoryChartCanvas;
        const w = canvas.width;
        const h = canvas.height;
        chartCtx.fillStyle = colorChartBg;
        chartCtx.fillRect(0, 0, w, h);
        chartCtx.strokeStyle = colorChartGrid;
        chartCtx.lineWidth = 0.5;
        chartCtx.beginPath();
        chartCtx.moveTo(0, h);
        chartCtx.lineTo(w, h);
        chartCtx.stroke();
        const finiteChaos = chaosValueHistory.filter(
          (c) => isFinite(c) && c >= 0
        );
        const maxChaos =
          finiteChaos.length > 0 ? Math.max(0.1, ...finiteChaos) : 0.1;
        const scaleChaos = h / (maxChaos + 1e-6);
        plotHistoryLine(
          chartCtx,
          canvas,
          chaosValueHistory,
          colorChaos,
          scaleChaos,
          h,
          1.5,
          true
        );
      }
      function plotHistoryLine(
        chartCtx,
        canvas,
        history,
        color,
        yScale,
        yOffset,
        lineWidth = 1.5,
        plotFromBottom = false
      ) {
        if (history.length < 2) return;
        const w = canvas.width;
        const stepX = w / (HISTORY_LENGTH - 1);
        chartCtx.strokeStyle = color;
        chartCtx.lineWidth = lineWidth;
        chartCtx.beginPath();
        let firstValidIndex = history.findIndex((val) =>
          isFinite(val * yScale)
        );
        if (firstValidIndex === -1) return;
        const getY = (val) =>
          plotFromBottom
            ? yOffset - Math.max(0, val) * yScale
            : yOffset - val * yScale;
        chartCtx.moveTo(
          firstValidIndex * stepX,
          getY(history[firstValidIndex])
        );
        for (let i = firstValidIndex + 1; i < history.length; i++) {
          let yVal = history[i] * yScale;
          if (isFinite(yVal)) {
            chartCtx.lineTo(i * stepX, getY(history[i]));
          } else {
            chartCtx.stroke();
            let nextValidIndex = history.findIndex(
              (val, idx) => idx > i && isFinite(val * yScale)
            );
            if (nextValidIndex !== -1) {
              chartCtx.beginPath();
              chartCtx.moveTo(
                nextValidIndex * stepX,
                getY(history[nextValidIndex])
              );
              i = nextValidIndex - 1;
            } else {
              break;
            }
          }
        }
        chartCtx.stroke();
      }

      function gameLoop(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const elapsed = (timestamp - lastTimestamp) / 1000.0;
        lastTimestamp = timestamp;
        if (isRunning) {
          timeSinceLastPhysicsUpdate += elapsed;
          const physicsInterval = 1.0 / simulationUpdateRateHz;
          while (timeSinceLastPhysicsUpdate >= physicsInterval) {
            updatePhysics();
            updateHistory();
            timeSinceLastPhysicsUpdate -= physicsInterval;
          }
          timeSinceLastRender += elapsed;
          const renderInterval = 1.0 / canvasRenderRateFps;
          if (timeSinceLastRender >= renderInterval) {
            draw();
            updateVisualsPanel();
            drawHistoryCharts();
            timeSinceLastRender = 0;
          }
        } else if (isDraggingM1 || isDraggingM2) {
          draw();
          updateVisualsPanel();
          drawHistoryCharts();
        } else {
          // Draw static state when stopped (not running and not dragging)
          draw();
        }
        animationFrameId = RAF(gameLoop);
      }

      function startSimulation() {
        if (isGeneratingFastCSV) return;

        applyInputConstraints();
        currentRecordingMode = document.querySelector(
          'input[name="recordMode"]:checked'
        ).value;
        if (currentRecordingMode === "fast") {
          generateFastCSV();
          return;
        }
        if (!isRunning) {
          isRunning = true;
          startButton.disabled = true;
          stopButton.disabled = false;
          disableInputs(true);
          if (time <= 1e-6) {
            recordedData = [];
            energyHistoryForStability = [];
            dataRecordingStatus.textContent = "Recording started...";
          }
          updateRecordingStatus();
          if (!animationFrameId) {
            lastTimestamp = PERF.now();
            timeSinceLastRender = 0;
            timeSinceLastPhysicsUpdate = 0;
            gameLoop(lastTimestamp);
          }
        }
      }
      function stopSimulation() {
        if (isGeneratingFastCSV) {
          isGeneratingFastCSV = false;
          dataRecordingStatus.textContent = "Fast CSV generation cancelled.";
          startButton.disabled = false;
          stopButton.disabled = true;
          downloadDataButton.disabled = recordedData.length === 0;
          disableInputs(false);
          return;
        }
        if (isRunning) {
          isRunning = false;
          startButton.disabled = false;
          stopButton.disabled = true;
          disableInputs(false);
          saveRecordedData();
          updateRecordingStatus();
          downloadDataButton.disabled = recordedData.length === 0;
        }
      }
      function generateFastCSV() {
        if (isRunning || isGeneratingFastCSV) return;
        applyInputConstraints();
        resetSimulationStateOnly();
        isGeneratingFastCSV = true;
        recordedData = [];
        startButton.disabled = true;
        stopButton.disabled = false;
        downloadDataButton.disabled = true;
        disableInputs(true);
        dataRecordingStatus.textContent = `Generating CSV (0s / ${maxRecordingTime}s)...`;
        fastCsvStartTime = PERF.now();
        let lastUpdate = fastCsvStartTime;
        function runChunk() {
          if (!isGeneratingFastCSV) return;
          const chunkEndTime = time + 1.0;
          const loopStartTime = PERF.now();
          while (
            time <= chunkEndTime &&
            time <= maxRecordingTime &&
            isGeneratingFastCSV
          ) {
            updatePhysics();
            recordDataPoint();
            if (PERF.now() - loopStartTime > 50) {
              RAF(runChunk);
              return;
            }
          }
          if (PERF.now() - lastUpdate > 500) {
            const progress = (time / maxRecordingTime) * 100;
            dataRecordingStatus.textContent = `Generating CSV... ${time.toFixed(
              1
            )}s / ${maxRecordingTime}s (${progress.toFixed(0)}%)`;
            lastUpdate = performance.now();
          }
          if (time >= maxRecordingTime || !isGeneratingFastCSV) {
            finishFastCSV();
          } else {
            requestAnimationFrame(runChunk);
          }
        }
        requestAnimationFrame(runChunk);
      }
      function finishFastCSV() {
        isGeneratingFastCSV = false;
        const endTime = performance.now();
        const duration = (
          (endTime - (fastCsvStartTime || endTime)) /
          1000
        ).toFixed(2);
        dataRecordingStatus.textContent = `CSV generation complete (${recordedData.length} points in ${duration}s). Data ready.`;
        startButton.disabled = false;
        stopButton.disabled = true;
        downloadDataButton.disabled = false;
        disableInputs(false);
        saveRecordedData();
        resetSimulation();
      }
      function resetSimulationStateOnly() {
        theta1 = defaultTheta1;
        theta2 = defaultTheta2;
        omega1 = 0;
        omega2 = 0;
        time = 0;
        clearTraceBuffer(trace1);
        clearTraceBuffer(trace2);
        chaosValueHistory = [];
        omega1History = [];
        omega2History = [];
        energyPlotHistory = [];
        kePlotHistory = [];
        pePlotHistory = [];
        ke1PlotHistory = [];
        ke2PlotHistory = [];
        pe1PlotHistory = [];
        pe2PlotHistory = [];
        energyHistoryForStability = [];
        recordedData = [];
      }
      function updateDefaultPositionDisplays() {
        const th1 = (parseFloat(defaultTheta1Input.value) * Math.PI) / 180;
        const th2 = (parseFloat(defaultTheta2Input.value) * Math.PI) / 180;
        const l1 = Math.max(0.1, parseFloat(length1Input.value));
        const l2 = Math.max(0.1, parseFloat(length2Input.value));
        const s1 = Math.sin(th1);
        const c1 = Math.cos(th1);
        const s2 = Math.sin(th2);
        const c2 = Math.cos(th2);
        const x1 = l1 * s1;
        const y1 = l1 * c1;
        const x2 = x1 + l2 * s2;
        const y2 = y1 + l2 * c2;
        defaultX1Display.value = x1.toFixed(3);
        defaultY1Display.value = y1.toFixed(3);
        defaultX2Display.value = x2.toFixed(3);
        defaultY2Display.value = y2.toFixed(3);
      }

      function applyInputConstraints() {
        const clampNumber = (input, min, fallback) => {
          let value = parseFloat(input.value);
          if (!Number.isFinite(value)) value = fallback;
          if (min !== null) value = Math.max(min, value);
          input.value = value.toString();
          return value;
        };

        const clampInt = (input, min, fallback) => {
          let value = parseInt(input.value, 10);
          if (!Number.isFinite(value)) value = fallback;
          value = Math.max(min, value);
          input.value = value.toString();
          return value;
        };

        gravity = clampNumber(gravityInput, 0, gravity);
        length1 = clampNumber(length1Input, 0.1, length1);
        length2 = clampNumber(length2Input, 0.1, length2);
        mass1 = clampNumber(mass1Input, 0.1, mass1);
        mass2 = clampNumber(mass2Input, 0.1, mass2);
        damping1 = clampNumber(damping1Input, 0, damping1);
        damping2 = clampNumber(damping2Input, 0, damping2);
        dirForceMag = clampNumber(dirForceMagInput, 0, dirForceMag);
        dirForceAngleRad =
          ((parseFloat(dirForceAngleInput.value) || 0) * Math.PI) / 180;
        charge1 = parseFloat(charge1Input.value) || charge1;
        charge2 = parseFloat(charge2Input.value) || charge2;
        magFieldBz = parseFloat(magFieldInput.value) || magFieldBz;
        trace1MaxLength = clampInt(trace1LengthInput, 0, trace1MaxLength);
        trace2MaxLength = clampInt(trace2LengthInput, 0, trace2MaxLength);
        simulationUpdateRateHz = clampInt(simRateInput, 10, simulationUpdateRateHz);
        canvasRenderRateFps = clampInt(renderRateInput, 1, canvasRenderRateFps);
        maxRecordingTime = clampInt(maxRecordTimeInput, 1, maxRecordingTime);
        timeStep = 1.0 / simulationUpdateRateHz;
        resizeTraceBuffer(trace1, trace1MaxLength);
        resizeTraceBuffer(trace2, trace2MaxLength);
      }
      function resetSimulation() {
        stopSimulation();
        defaultTheta1 = (parseFloat(defaultTheta1Input.value) * Math.PI) / 180;
        defaultTheta2 = (parseFloat(defaultTheta2Input.value) * Math.PI) / 180;
        applyInputConstraints();
        resetSimulationStateOnly();
        updateDefaultPositionDisplays();
        startButton.disabled = false;
        stopButton.disabled = true;
        downloadDataButton.disabled = true;
        localStorage.removeItem(LOCAL_STORAGE_KEY);
        calculateEstimatedSize();
        updateRecordingStatus();
        refreshMagneticFieldCache();
        refreshWindFieldCache();
        resizeCanvas();
        draw();
        updateVisualsPanel();
        drawHistoryCharts();
      }
      function getMousePos(canvasEl, evt) {
        const rect = canvasEl.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
      }
      function handleMouseDown(e) {
        if (isRunning || isGeneratingFastCSV) return;
        const mousePos = getMousePos(canvas, e);
        const l1Px = length1 * pixelsPerMeter;
        const l2Px = length2 * pixelsPerMeter;
        const s1 = Math.sin(theta1);
        const c1 = Math.cos(theta1);
        const s2 = Math.sin(theta2);
        const c2 = Math.cos(theta2);
        const x1 = originX + l1Px * s1;
        const y1 = originY + l1Px * c1;
        const x2 = originX + l1Px * s1 + l2Px * s2;
        const y2 = originY + l1Px * c1 + l2Px * c2;
        const grabRadius1 = 6 + Math.sqrt(mass1) * 5 + 15;
        const grabRadius2 = 6 + Math.sqrt(mass2) * 5 + 15;
        const distToM2 = Math.hypot(mousePos.x - x2, mousePos.y - y2);
        const distToM1 = Math.hypot(mousePos.x - x1, mousePos.y - y1);
        const clearHistory = () => {
          chaosValueHistory = [];
          omega1History = [];
          omega2History = [];
          energyPlotHistory = [];
          kePlotHistory = [];
          pePlotHistory = [];
          ke1PlotHistory = [];
          ke2PlotHistory = [];
          pe1PlotHistory = [];
          pe2PlotHistory = [];
          energyHistoryForStability = [];
        };
        if (distToM2 < grabRadius2) {
          isDraggingM2 = true;
          isDraggingM1 = false;
          canvas.style.cursor = "grabbing";
          clearHistory();
        } else if (distToM1 < grabRadius1) {
          isDraggingM1 = true;
          isDraggingM2 = false;
          canvas.style.cursor = "grabbing";
          clearHistory();
        }
      }
      function handleMouseMove(e) {
        if (!isDraggingM1 && !isDraggingM2) return;
        if (isRunning || isGeneratingFastCSV) {
          isDraggingM1 = false;
          isDraggingM2 = false;
          canvas.style.cursor = "grab";
          return;
        }
        const mousePos = getMousePos(canvas, e);
        if (isDraggingM1) {
          const dx = mousePos.x - originX;
          const dy = mousePos.y - originY;
          theta1 = Math.atan2(dx, dy);
          omega1 = 0;
          omega2 = 0;
        } else if (isDraggingM2) {
          const l1Px = length1 * pixelsPerMeter;
          const x1 = originX + l1Px * Math.sin(theta1);
          const y1 = originY + l1Px * Math.cos(theta1);
          const dx = mousePos.x - x1;
          const dy = mousePos.y - y1;
          theta2 = Math.atan2(dx, dy);
          omega1 = 0;
          omega2 = 0;
        }
        time = 0;
        updateVisualsPanel();
      }
      function handleMouseUpOrLeave() {
        if (isDraggingM1 || isDraggingM2) {
          isDraggingM1 = false;
          isDraggingM2 = false;
          canvas.style.cursor = "grab";
          omega1 = 0;
          omega2 = 0;
          time = 0;
          recordedData = [];
          updateRecordingStatus();
          startButton.disabled = false;
          stopButton.disabled = true;
          draw();
          updateVisualsPanel();
          drawHistoryCharts();
        }
      }
      function saveRecordedData() {
        if (recordedData && recordedData.length > 0) {
          try {
            const dataString = JSON.stringify(recordedData);
            localStorage.setItem(LOCAL_STORAGE_KEY, dataString);
            console.log(
              `Saved ${recordedData.length} points (${(
                dataString.length /
                (1024 * 1024)
              ).toFixed(2)} MB) to localStorage.`
            );
            downloadDataButton.disabled = false;
          } catch (e) {
            console.error("Error saving data to local storage:", e);
            dataRecordingStatus.textContent =
              "Error saving data. Storage might be full.";
            alert(
              `Error saving data to local storage. The browser limit (often 5-10MB) might have been exceeded.\nRecorded data length: ${recordedData.length}. Try reducing Max Record Time.`
            );
            downloadDataButton.disabled = true;
          }
        } else {
          localStorage.removeItem(LOCAL_STORAGE_KEY);
          downloadDataButton.disabled = true;
        }
      }
      function downloadStoredData() {
        stopSimulation();
        let dataString;
        try {
          dataString = localStorage.getItem(LOCAL_STORAGE_KEY);
          if (!dataString) {
            dataRecordingStatus.textContent =
              "No recorded data found in storage.";
            alert("No recorded data found in local storage.");
            return;
          }
        } catch (e) {
          console.error("Error retrieving data from local storage:", e);
          dataRecordingStatus.textContent =
            "Error retrieving data from storage.";
          alert("Error retrieving data from local storage.");
          return;
        }
        let dataArray;
        try {
          dataArray = JSON.parse(dataString);
          if (!Array.isArray(dataArray) || dataArray.length === 0) {
            dataRecordingStatus.textContent =
              "Stored data is invalid or empty.";
            alert("Stored data is invalid or empty.");
            return;
          }
        } catch (e) {
          console.error("Error parsing stored data:", e);
          dataRecordingStatus.textContent = "Error parsing stored data.";
          alert("Error parsing stored data.");
          return;
        }
        dataRecordingStatus.textContent = `Preparing ${dataArray.length} data points for download...`;
        const header = Object.keys(dataArray[0]).join(",");
        const csvRows = dataArray.map((row) =>
          Object.values(row)
            .map((value) =>
              typeof value === "number" ? value.toFixed(8) : value
            )
            .join(",")
        );
        const csvContent = [header, ...csvRows].join("\n");
        try {
          const blob = new Blob([csvContent], {
            type: "text/csv;charset=utf-8;",
          });
          const link = document.createElement("a");
          const url = URL.createObjectURL(blob);
          link.setAttribute("href", url);
          const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
          link.setAttribute(
            "download",
            `pendulum_recorded_data_${timestamp}.csv`
          );
          link.style.visibility = "hidden";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          dataRecordingStatus.textContent = `Downloaded ${dataArray.length} data points.`;
        } catch (error) {
          console.error("Download failed:", error);
          dataRecordingStatus.textContent =
            "Error: Failed to generate or download file.";
          alert("Error generating download file.");
        }
      }
      function resizeCanvas() {
        const simRow = document.querySelector(".simulation-row");
        const availableWidth = simRow.clientWidth;
        const gap = 20;
        const cardWidth = Math.floor((availableWidth - gap) / 2);

        const simCard = document.getElementById("simulation-card");
        const controlsCard = document.getElementById("controls-card");
        simCard.style.flexBasis = `${cardWidth}px`;
        controlsCard.style.flexBasis = `${cardWidth}px`;

        canvas.width = cardWidth;
        canvas.height = cardWidth;

        [
          omegaHistoryChartCanvas,
          energyHistoryChartCanvas,
          chaosHistoryChartCanvas,
        ].forEach((chartCanvas) => {
          const chartContainer = chartCanvas.parentElement;
          if (chartContainer) {
            const containerStyle = getComputedStyle(chartContainer);
            chartCanvas.width =
              chartContainer.clientWidth -
              parseFloat(containerStyle.paddingLeft) -
              parseFloat(containerStyle.paddingRight);
            chartCanvas.height = 156;
          }
        });
        const maxExtent = length1 + length2;
        const paddingFactor = 1.2;
        const scaleX = canvas.width / (maxExtent * 2 * paddingFactor);
        const scaleY = (canvas.height * 0.8) / (maxExtent * 2 * paddingFactor);
        pixelsPerMeter = Math.max(20, Math.min(scaleX, scaleY));
        if (maxExtent < 1e-6) pixelsPerMeter = 50;
        originX = canvas.width / 2;
        originY = canvas.height * 0.4;
        refreshMagneticFieldCache();
        refreshWindFieldCache();
        if (
          !isRunning &&
          !isDraggingM1 &&
          !isDraggingM2 &&
          !isGeneratingFastCSV
        ) {
          draw();
          drawHistoryCharts();
        }
      }
      function calculateEstimatedSize() {
        const pointsPerSecond = simulationUpdateRateHz;
        const totalPoints = pointsPerSecond * maxRecordingTime;
        const fieldsPerPoint = 16;
        const avgCharsPerField = 15;
        const avgCharsPerPoint = fieldsPerPoint * (avgCharsPerField + 5);
        const totalChars = totalPoints * avgCharsPerPoint;
        const estimatedMB = totalChars / (1024 * 1024);
        estimatedSizeDisplay.textContent = `Est. Size: ${estimatedMB.toFixed(
          1
        )} MB`;
        if (estimatedMB > 5) {
          estimatedSizeDisplay.style.color = "red";
          estimatedSizeDisplay.title =
            "Warning: Estimated size exceeds typical 5MB localStorage limit. Saving may fail.";
        } else {
          estimatedSizeDisplay.style.color = getCssVariable("--accent-grey");
          estimatedSizeDisplay.title = "";
        }
      }
      function disableInputs(disabled) {
        const inputs = document.querySelectorAll(
          "#controls-container input, #controls-container select"
        );
        inputs.forEach((input) => {
          if (
            !input.closest(".button-group") &&
            input.type !== "radio" &&
            input.id !== "max-record-time-input"
          ) {
            input.disabled = disabled;
          }
        });
        resetButton.disabled = disabled;
        downloadDataButton.disabled =
          disabled ||
          (recordedData.length === 0 &&
            !localStorage.getItem(LOCAL_STORAGE_KEY));
        recordingModeRadios.forEach((radio) => (radio.disabled = disabled));
        maxRecordTimeInput.disabled = disabled;
      }
      // LocalStorage key for card collapse state persistence
      const CARD_STATE_KEY = 'spd_card_states';

      function toggleCard(cardHeader) {
        const cardContent = cardHeader.nextElementSibling;
        const toggle = cardHeader.querySelector(".card-toggle");
        const isCollapsed = cardContent.classList.toggle("collapsed");
        toggle.textContent = isCollapsed ? "+" : "−";

        // Persist card state to localStorage
        const cardId = cardHeader.closest('.card').id;
        if (cardId) {
          try {
            const states = JSON.parse(localStorage.getItem(CARD_STATE_KEY) || '{}');
            states[cardId] = isCollapsed;
            localStorage.setItem(CARD_STATE_KEY, JSON.stringify(states));
          } catch (e) {
            // Silently fail if localStorage is unavailable
          }
        }
      }

      function restoreCardStates() {
        try {
          const states = JSON.parse(localStorage.getItem(CARD_STATE_KEY) || '{}');
          Object.entries(states).forEach(([cardId, isCollapsed]) => {
            const card = document.getElementById(cardId);
            if (card && isCollapsed) {
              const content = card.querySelector('.card-content');
              const toggle = card.querySelector('.card-toggle');
              if (content && toggle) {
                content.classList.add('collapsed');
                toggle.textContent = '+';
              }
            }
          });
        } catch (e) {
          // Silently fail if localStorage is unavailable
        }
      }
      function initialize() {
        loadColors();
        restoreCardStates(); // Restore collapsed/expanded card states from localStorage
        resetButton.addEventListener("click", resetSimulation);
        startButton.addEventListener("click", startSimulation);
        stopButton.addEventListener("click", stopSimulation);
        downloadDataButton.addEventListener("click", downloadStoredData);
        maxRecordTimeInput.addEventListener("change", calculateEstimatedSize);
        simRateInput.addEventListener("change", () => {
          if (!isRunning && !isGeneratingFastCSV) resetSimulation();
        });
        renderRateInput.addEventListener("change", () => {
          if (!isRunning && !isGeneratingFastCSV) resetSimulation();
        });
        const controlInputs = document.querySelectorAll(
          '#controls-container input[type="number"], #controls-container input[type="checkbox"], #controls-container select'
        );
        controlInputs.forEach((input) => {
          input.addEventListener("change", () => {
            if (
              input.id === "default-theta1-input" ||
              input.id === "default-theta2-input" ||
              input.id === "length1-input" ||
              input.id === "length2-input"
            ) {
              updateDefaultPositionDisplays();
            }
            if (
              !isRunning &&
              !isGeneratingFastCSV &&
              input.id !== "sim-rate-input" &&
              input.id !== "render-rate-input" &&
              input.id !== "max-record-time-input"
            ) {
              resetSimulation();
            }
          });
        });
        document.querySelectorAll(".card-header").forEach((header) => {
          header.addEventListener("click", () => toggleCard(header));
        });
        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseup", handleMouseUpOrLeave);
        canvas.addEventListener("mouseleave", handleMouseUpOrLeave);
        // Debounce resize handler
        let resizeTimeout;
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(resizeCanvas, 100);
        }, { passive: true });
        resetSimulation();
        stopSimulation();
        requestAnimationFrame((ts) => {
          lastTimestamp = ts;
          gameLoop(ts);
        });
        // Hide loading indicator
        setTimeout(() => {
          const loadingIndicator = document.getElementById('loading-indicator');
          if (loadingIndicator) {
            loadingIndicator.style.opacity = '0';
            loadingIndicator.style.transition = 'opacity 0.5s';
            setTimeout(() => loadingIndicator.remove(), 500);
          }
        }, 200);
      }
      document.addEventListener("DOMContentLoaded", initialize);
    </script>
  </body>
</html>
