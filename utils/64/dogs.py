#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
dogs.py: Deconstruct Concatenated Files Tool (v1)

Extracts files from a bundle created by cats.py. It reads the format
header, handles Base64 or Raw UTF-8 content, and reconstructs the
original directory structure relative to a specified output directory.
Replaces hyphens with underscores in extracted filenames.
"""

import sys
import os
import argparse
import base64
import re
import logging

# --- Configuration ---
FILE_START_MARKER_REGEX = r"^-{3}\s*CATS_START_FILE:\s*(.*?)\s*-{3}$"
FILE_END_MARKER = "--- CATS_END_FILE ---"
DEFAULT_INPUT_FILENAME = "cats_out.bundle"
DEFAULT_OUTPUT_DIR = "."
DEFAULT_ENCODING = "utf-8"  # Used for reading the bundle file itself

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
log = logging.getLogger(__name__)
# --- End Configuration ---


def sanitize_filename(path_str):
    """Replaces hyphens with underscores and removes potentially unsafe chars."""
    # Replace hyphens with underscores FIRST
    name = path_str.replace("-", "_")
    # Remove or replace other potentially problematic characters for filenames
    # This is a basic example; more robust sanitization might be needed.
    name = re.sub(r'[<>:"/\\|?*\x00-\x1f]', "_", name)
    # Prevent path traversal attempts (replace '..' components)
    # Normalize path separators to OS default THEN sanitize '..'
    normalized_path = os.path.normpath(name).replace(
        "\\", "/"
    )  # Normalize to forward slash first
    parts = normalized_path.split("/")
    safe_parts = []
    for part in parts:
        if part == "..":
            safe_parts.append("_")  # Replace '..' with underscore
        elif part:  # Skip empty parts resulting from multiple slashes
            safe_parts.append(part)
    # Rejoin using OS-specific separator
    safe_path = os.path.join(*safe_parts)
    return safe_path


def extract_files(input_file_path, output_dir, input_format_override=None):
    """
    Extracts files from the cats.py bundle.

    Args:
        input_file_path (str): Path to the concatenated input file.
        output_dir (str): Directory where files will be extracted.
        input_format_override (str, optional): 'b64' or 'utf8' to override
                                                header detection. Defaults to None (auto).
    """
    extracted_files = 0
    skipped_files = 0
    errors = 0
    detected_format = None  # 'b64' or 'utf8' or None

    log.info(f"Starting extraction from: '{input_file_path}'")
    log.info(f"Output directory: '{os.path.abspath(output_dir)}'")

    try:
        with open(
            input_file_path, "r", encoding=DEFAULT_ENCODING, errors="replace"
        ) as infile:
            content_lines = infile.readlines()

        # --- Detect Format ---
        header_format = None
        for line in content_lines[:5]:  # Check first few lines for header
            if line.startswith("# Format:"):
                format_str = line.split(":", 1)[1].strip().lower()
                if "base64" in format_str:
                    header_format = "b64"
                elif f"raw {DEFAULT_ENCODING}" in format_str:
                    header_format = "utf8"
                log.info(f"Detected format from header: {header_format}")
                break

        if input_format_override:
            detected_format = input_format_override
            log.warning(
                f"Overriding detected format. Using forced format: '{detected_format}'"
            )
        elif header_format:
            detected_format = header_format
        else:
            log.error(
                "Could not determine bundle format from header and no override provided."
            )
            log.error(
                "Please ensure the input file was generated by cats.py or use --input-format."
            )
            return  # Cannot proceed without format

        # --- Process Content ---
        current_file_path_raw = None
        current_file_content_lines = []
        in_file_block = False

        for i, line in enumerate(content_lines):
            start_match = re.match(FILE_START_MARKER_REGEX, line.strip())

            if start_match:
                if in_file_block:
                    log.warning(
                        f"Found new START marker before END marker for '{current_file_path_raw}' near line {i+1}. Skipping previous block."
                    )
                    skipped_files += 1
                current_file_path_raw = start_match.group(1).strip()
                current_file_content_lines = []
                in_file_block = True
                # log.debug(f"Started block for: {current_file_path_raw}")
                continue  # Move to next line

            if in_file_block:
                if line.strip() == FILE_END_MARKER:
                    # --- Process the completed block ---
                    log.info(f"  Extracting: {current_file_path_raw}")
                    # Sanitize filename (hyphen->underscore, etc.)
                    safe_relative_path = sanitize_filename(current_file_path_raw)
                    output_path = os.path.join(output_dir, safe_relative_path)
                    output_subdir = os.path.dirname(output_path)

                    try:
                        if output_subdir and not os.path.exists(output_subdir):
                            # log.debug(f"    Creating subdir: {output_subdir}")
                            os.makedirs(output_subdir)

                        # Join lines, removing the trailing newline added by readlines()
                        # but keeping internal newlines.
                        raw_content_str = "".join(
                            current_file_content_lines
                        )  # [:-1] # No, keep all lines

                        # Decode based on detected format and write bytes
                        with open(output_path, "wb") as outfile:  # Always write binary
                            if detected_format == "b64":
                                decoded_bytes = base64.b64decode(raw_content_str)
                                outfile.write(decoded_bytes)
                            else:  # utf8
                                # Assume content is UTF-8 text, encode back to bytes
                                utf8_bytes = raw_content_str.encode(DEFAULT_ENCODING)
                                outfile.write(utf8_bytes)
                        # log.debug(f"    Successfully written: {output_path}")
                        extracted_files += 1

                    except (IOError, OSError) as e:
                        log.error(f"    Error writing file '{output_path}': {e}")
                        errors += 1
                    except base64.binascii.Error as e:
                        log.error(
                            f"    Base64 Decode Error for '{current_file_path_raw}': {e}. Check bundle format."
                        )
                        errors += 1
                    except Exception as e:
                        log.error(
                            f"    Unexpected error processing block for '{current_file_path_raw}': {e}"
                        )
                        errors += 1
                    finally:
                        in_file_block = False
                        current_file_path_raw = None
                        current_file_content_lines = []
                else:
                    # Append line (including its newline) to the current block buffer
                    current_file_content_lines.append(line)

        if in_file_block:
            log.warning(
                f"Input file ended while still inside a block for '{current_file_path_raw}'. Block skipped."
            )
            skipped_files += 1

    except FileNotFoundError:
        log.error(f"Input file not found: '{input_file_path}'")
        sys.exit(1)
    except IOError as e:
        log.error(f"Error reading input file '{input_file_path}': {e}")
        sys.exit(1)
    except Exception as e:
        log.error(f"An unexpected error occurred during extraction: {e}")
        # import traceback
        # traceback.print_exc()
        sys.exit(1)

    print("\n" + "=" * 30)
    print("Extraction Summary:")
    print(f"  Input bundle: '{input_file_path}'")
    print(f"  Format used: {detected_format}")
    print(f"  Output directory: '{os.path.abspath(output_dir)}'")
    print(f"  Files successfully extracted: {extracted_files}")
    if skipped_files > 0:
        print(f"  Blocks skipped (malformed): {skipped_files}")
    if errors > 0:
        print(f"  Errors during extraction: {errors}")
    print("=" * 30)


def main():
    """Parses arguments and runs the extraction."""
    parser = argparse.ArgumentParser(
        description="Extracts files from a bundle created by cats.py.",
        epilog=(
            "Examples:\n"
            "  python dogs.py project.bundle -d ./extracted_project\n"
            "  python dogs.py config.txt --input-format utf8 -d ./config\n"
            "  python dogs.py image.bundle --input-format b64 -d ./images\n"
        ),
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "input_file",
        nargs="?",  # Make optional if default is used
        default=DEFAULT_INPUT_FILENAME,
        help=f"Input bundle file path (default: {DEFAULT_INPUT_FILENAME}).",
    )
    parser.add_argument(
        "-d",
        "--output-dir",
        default=DEFAULT_OUTPUT_DIR,
        help=f"Directory to extract files into (default: {DEFAULT_OUTPUT_DIR}).",
    )
    parser.add_argument(
        "--input-format",
        choices=["auto", "b64", "utf8"],
        default="auto",
        help=(
            "Override input bundle format detection:\n"
            "  auto: Detect format from bundle header (default).\n"
            "  b64: Assume input content is Base64 encoded.\n"
            f"  utf8: Assume input content is Raw {DEFAULT_ENCODING} text."
        ),
    )
    # Removed --output-encoding as we now always write bytes ('wb')

    args = parser.parse_args()

    # Basic validation
    if not os.path.isfile(args.input_file):
        log.error(f"Input file not found or is not a file: '{args.input_file}'")
        # Try printing help if default was used and not found
        if (
            args.input_file == DEFAULT_INPUT_FILENAME and len(sys.argv) <= 2
        ):  # Check if only script name or script + default input was given
            parser.print_help(sys.stderr)
        sys.exit(1)

    if not os.path.exists(args.output_dir):
        log.info(f"Output directory '{args.output_dir}' not found. Creating it.")
        try:
            os.makedirs(args.output_dir)
        except OSError as e:
            log.error(f"Could not create output directory '{args.output_dir}': {e}")
            sys.exit(1)
    elif not os.path.isdir(args.output_dir):
        log.error(
            f"Specified output path '{args.output_dir}' exists but is not a directory."
        )
        sys.exit(1)

    extract_files(args.input_file, args.output_dir, args.input_format)


if __name__ == "__main__":
    main()
